#!/usr/bin/dash
#!/bin/bash
#! use dash as first line for portability testing


# Utility for configuration of GW-1000
# Only for firmware v1.6.5 or later - for intepretation of battery levels/sensor id new command
# example ./gw -s
# scan for devices
# example ./gw -h 10.42.0.180 -c mac
# read mac

#Documentation:

#Protocol
# https://osswww.ecowitt.net/uploads/20210716/WN1900%20GW1000,1100%20WH2680,2650%20telenet%20v1.6.0%20.pdf (https://www.ecowitt.com/shop/forum/forumDetails/255)
#Shell
# mirbsd ksh http://www.mirbsd.org/htman/i386/man1/mksh.htm
#Netcat
#https://en.wikipedia.org/wiki/Netcat
#choosing which nc on fedora (openbsd/nmap)
#sudo alternatives --config nc
#ubuntu
# sudo update-alternatives --config nc
# sudo update-alternatives --query nc

#testing in android shell
#adb push gw /sdcard && adb shell "sh  /sdcard/gw -h 192.168.3.80 -c livedata"

#set -x # enable for tracing in strace -f -c dash .c './gw -h 192.168.3.80 -c livedata'
#for s in bash dash ksh zsh; do strace -f -c $s -c './gw -h 192.168.3.80 -c livedata' 2>strace-log-$s; done
#not much to gain in time by avoiding subshell, but number of system calls is less. Try not to overoptimize.

DEBUG=0 # 1 will enable additional debug information, -d option to enable

MAX_16BIT_UINT=$(((2 << 16) - 1))


#ERROR_CONNECTION=1
#ERROR_NO_NMCLI=2
ERROR_NC_UDP_SCAN_UNAVAILABLE=3
ERROR_RAINDATA_NOTSPECIFIED=4
ERROR_SYSTEMPARAM_NOTSPECIFIED=5
ERROR_DEPENDENCY_NC=6
ERROR_PRX_PREAMBLE=7
ERROR_OD_BUFFER_EMPTY=8
ERROR_CONVERT=9
ERROR_HTTP_MESSSAGE_EMPTY=10
ERROR_NO_HOST_SPECIFIED=11
ERROR_INVALID_SENSORID=12
ERROR_INVALID_SENSORID_COMMAND=13
ERROR_LISTEN_INVALID_PORTNUMBER=14
ERROR_LISTEN_NOPORT=15
ERROR_LISTEN_UNSUPPORTED_NC=16
ERROR_COMMAND_UNKNOWN=17

#to do: conversion
UNIT_LIGHT="lux"
UNIT_UV="µW/m2"
UNIT_PM25="µg/m3"
UNIT_CO2="ppm"

UNIT_TEMPERATURE_CELCIUS=0
UNIT_TEMPERATURE_FARENHEIT=1

UNIT_PRESSURE_HPA=0
UNIT_PRESSURE_INHG=1

UNIT_RAIN_MM=0
UNIT_RAIN_IN=1

UNIT_WIND_MPS=0
UNIT_WIND_MPH=1

UNIT_UV_MICROWM2=0 # used by Ecowitt protocol
UNIT_UV_WATTM2=1

BATTERY_NORMAL=0
BATTERY_LOW=1
BATTERY_LEVEL_LOW=1 # 1 or 0
BATTERY_VOLTAGE_LOW=12 # scale x 10 <= 1.2V is low

NC_NMAP=0
NC_OPENBSD=1
NC_TOYBOX=2
NC_BUSYBOX=3

PORT_GW_TCP=45000
PORT_GW_UDP=46000
PORT_CLIENT_UDP=59387

CMD_READ_VERSION=$((0x50)) #zsh - wont compare int with hex 16#50 in [ ] expression unless converted to decimal, works in [[ ]] expression
CMD_REBOOT=$((0x40))
CMD_READ_MAC=$((0x26))
CMD_WRITE_SSID=$((0x11))
CMD_BROADCAST=$((0x12))
CMD_WRITE_RESET=$((0x41))

#weather services
CMD_READ_ECOWITT_INTERVAL=$((0x1e))
CMD_WRITE_ECOWITT_INTERVAL=$((0x1f))
CMD_READ_WUNDERGROUND=$((0x20))
CMD_WRITE_WUNDERGROUND=$((0x21))
CMD_READ_WOW=$((0x22))
CMD_WRITE_WOW=$((0x23))
CMD_READ_WEATHERCLOUD=$((0x24))
CMD_WRITE_WEATHERCLOUD=$((0x25))

#customized server for ecowitt/wunderground http requests
CMD_READ_CUSTOMIZED=$((0x2a))
CMD_WRITE_CUSTOMIZED=$((0x2b))
CMD_READ_PATH=$((0x51))
CMD_WRITE_PATH=$((0x52))
CMD_READ_RAINDATA=$((0x34))
CMD_WRITE_RAINDATA=$((0x35))
CMD_LIVEDATA=$((0x27))

#sensors
CMD_READ_SENSOR_ID=$((0x3a))
CMD_WRITE_SENSOR_ID=$((0x3b))
CMD_READ_SENSOR_ID_NEW=$((0x3c)) # for new sensors
CMD_READ_SYSTEM=$((0x30))
CMD_WRITE_SYSTEM=$((0x31))
CMD_READ_CALIBRATION=$((0x38))
CMD_WRITE_CALIBRATION=$((0x39))

#livedata field number from specification

LDF_INTEMP=$((0x01))        #Indoor Temperature (℃) 2
LDF_OUTTEMP=$((0x02))       #Outdoor Temperature (℃) 2
#shellcheck disable=SC2034
{
LDF_DEWPOINT=$((0x03))      #Dew point (℃) 2
LDF_WINDCHILL=$((0x04))     #Wind chill (℃) 2
LDF_HEATINDEX=$((0x05))     #Heat index (℃) 2
}
LDF_INHUMI=$((0x06))        #Indoor Humidity (%) 1
LDF_OUTHUMI=$((0x07))       #Outdoor Humidity (%) 1
LDF_ABSBARO=$((0x08))       #Absolutely Barometric (hpa) 2
LDF_RELBARO=$((0x09))       #Relative Barometric (hpa) 2
LDF_WINDDIRECTION=$((0x0A)) #Wind Direction (360°) 2
LDF_WINDSPEED=$((0x0B))     #Wind Speed (m/s) 2
LDF_WINDGUSTSPPED=$((0x0C)) #Gust Speed (m/s) 2
LDF_RAINEVENT=$((0x0D))     #Rain Event (mm) 2
LDF_RAINRATE=$((0x0E))      #Rain Rate (mm/h) 2
#shellcheck disable=SC2034
LDF_RAINHOUR=$((0x0F))      #Rain hour (mm) 2
LDF_RAINDAY=$((0x10))       #Rain Day (mm) 2
LDF_RAINWEEK=$((0x11))      #Rain Week (mm) 2
LDF_RAINMONTH=$((0x12))     #Rain Month (mm) 4
LDF_RAINYEAR=$((0x13))      #Rain Year (mm) 4
#shellcheck disable=SC2034
LDF_RAINTOTALS=$((0x14))    #Rain Totals (mm) 4
LDF_LIGHT=$((0x15))         #Light (lux) 4
LDF_UV=$((0x16))            #UV (uW/m2) 2
LDF_UVI=$((0x17))           #UVI (0-15 index) 1
#shellcheck disable=SC2034
LDF_TIME=$((0x18))          #Date and time 6
LDF_DAYLWINDMAX=$((0X19))   #Day max wind(m/s) 2

#shellcheck disable=SC2034
{
    LDF_TEMP1=$((0x1A)) #Temperature 1(℃) 2
    LDF_TEMP2=$((0x1B)) #Temperature 2(℃) 2
    LDF_TEMP3=$((0x1C)) #Temperature 3(℃) 2
    LDF_TEMP4=$((0x1D)) #Temperature 4(℃) 2
    LDF_TEMP5=$((0x1E)) #Temperature 5(℃) 2
    LDF_TEMP6=$((0x1F)) #Temperature 6(℃) 2
    LDF_TEMP7=$((0x20)) #Temperature 7(℃) 2
    LDF_TEMP8=$((0x21)) #Temperature 8(℃) 2
    LDF_HUMI1=$((0x22)) #Humidity 1, 0-100% 1
    LDF_HUMI2=$((0x23)) #Humidity 2, 0-100% 1
    LDF_HUMI3=$((0x24)) #Humidity 3, 0-100% 1
    LDF_HUMI4=$((0x25)) #Humidity 4, 0-100% 1
    LDF_HUMI5=$((0x26)) #Humidity 5, 0-100% 1
    LDF_HUMI6=$((0x27)) #Humidity 6, 0-100% 1
    LDF_HUMI7=$((0x28)) #Humidity 7, 0-100% 1
    LDF_HUMI8=$((0x29)) #Humidity 8, 0-100% 1
}
LDF_PM25_CH1=$((0x2A))      #PM2.5 Air Quality Sensor(μg/m3) 2
LDF_SOILTEMP1=$((0x2B))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE1=$((0x2C)) #Soil Moisture(%) 1
LDF_SOILTEMP2=$((0x2D))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE2=$((0x2E)) #Soil Moisture(%) 1
LDF_SOILTEMP3=$((0x2F))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE3=$((0x30)) #Soil Moisture(%) 1
LDF_SOILTEMP4=$((0x31))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE4=$((0x32)) #Soil Moisture(%) 1
LDF_SOILTEMP5=$((0x33))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE5=$((0x34)) #Soil Moisture(%) 1
LDF_SOILTEMP6=$((0x35))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE6=$((0x36)) #Soil Moisture(%) 1
LDF_SOILTEMP7=$((0x37))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE7=$((0x38)) #Soil Moisture(%) 1
LDF_SOILTEMP8=$((0x39))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE8=$((0x3A)) #Soil Moisture(%) 1
#shellcheck disable=SC2034
LDF_LOWBATT=$((0x4C))       #All sensor lowbatt 16 char 16
LDF_PM25_24HAVG1=$((0x4D))  # pm25_ch1 2
#shellcheck disable=SC2034
LDF_PM25_24HAVG2=$((0x4E)) # pm25_ch2 2
#shellcheck disable=SC2034
LDF_PM25_24HAVG3=$((0x4F)) # pm25_ch3 2
LDF_PM25_24HAVG4=$((0x50)) # pm25_ch4 2
LDF_PM25_CH2=$((0x51))     #PM2.5 Air Quality Sensor(μg/m3) 2
#shellcheck disable=SC2034
LDF_PM25_CH3=$((0x52)) #PM2.5 Air Quality Sensor(μg/m3) 2
LDF_PM25_CH4=$((0x53)) #PM2.5 Air Quality Sensor(μg/m3) 2
LDF_LEAK_CH1=$((0x58)) # Leak_ch1 1
#shellcheck disable=SC2034
LDF_LEAK_CH2=$((0x59)) # Leak_ch2 1
#shellcheck disable=SC2034
LDF_LEAK_CH3=$((0x5A))        # Leak_ch3 1
LDF_LEAK_CH4=$((0x5B))        # Leak_ch4 1
LDF_LIGHTNING=$((0x60))       # lightning distance （1~40KM） 1
LDF_LIGHTNING_TIME=$((0x61))  # lightning happened time(UTC) 4
LDF_LIGHTNING_POWER=$((0x62)) # lightning counter for the ay 4
#shellcheck disable=SC2034
{
    LDF_TF_USR1=$((0x63)) #Temperature(℃) 4
    LDF_TF_USR2=$((0x64)) #Temperature(℃) 4
    LDF_TF_USR3=$((0x65)) #Temperature(℃) 4
    LDF_TF_USR4=$((0x66)) #Temperature(℃) 4
    LDF_TF_USR5=$((0x67)) #Temperature(℃) 4
    LDF_TF_USR6=$((0x68)) #Temperature(℃) 4
    LDF_TF_USR7=$((0x69)) #Temperature(℃) 4
    LDF_TF_USR8=$((0x6A)) #Temperature(℃) 4
}
LDF_SENSOR_CO2=$((0x70)) #16
#shellcheck disable=SC2034
LDF_PM25_AQI=$((0x71))   #only for amb
# LDF_PM25_AQI length(n*2)(1byte) 1-aqi_pm25 2-aqi_pm25_24h ... ... n-aqi
#aqi_pm25 AQI derived from PM25 int
#aqi_pm25_24h AQI derived from PM25, 24 hour running average int
#aqi_pm25_in AQI derived from PM25 IN int
#aqi_pm25_in_24h AQI derived from PM25 IN, 24 hour running average int
#aqi_pm25_aqin AQI derived from PM25, AQIN sensor int
#aqi_pm25_24h_aqin AQI derived from PM25, 24 hour running average, AQIN sensor int
#.... n
#shellcheck disable=SC2034
{
    LDF_LEAF_WETNESS_CH1=$((0x72)) # 1
    LDF_LEAF_WETNESS_CH2=$((0x73)) # 1
    LDF_LEAF_WETNESS_CH3=$((0x74)) # 1
    LDF_LEAF_WETNESS_CH4=$((0x75)) # 1
    LDF_LEAF_WETNESS_CH5=$((0x76)) # 1
    LDF_LEAF_WETNESS_CH6=$((0x77)) # 1
    LDF_LEAF_WETNESS_CH7=$((0x78)) # 1
    LDF_LEAF_WETNESS_CH8=$((0x79)) # 1
}

SYSTEM_FREQUENCY_RFM433M=0 # 433MHz
SYSTEM_FREQUENCY_RFM868M=1 # 868Mhz
SYSTEM_FREQUENCY_RFM915M=2 # 915MHz
SYSTEM_FREQUENCY_RFM920M=4 # 920Mhz

SYSTEM_SENSOR_TYPE_WH24=0
SYSTEM_SENSOR_TYPE_WH65=1

#https://www.wxforum.net/index.php?topic=40730.0
case $KSH_VERSION in

    *MIRBSD?KSH*)
        #shellcheck disable=SC3044
        typeset -iU SENSORID_SEARCH  SENSORID_DISABLE VALUE_UINT32BE  VALUE_UINT16BE VALUE_UINT8 SID
        SENSORID_SEARCH=$(( 0xffffffff ))
        SENSORID_DISABLE=$(( 0xfffffffe ))
        # mksh - sets 0xffffffff to -1!? if typeset -i SENSORID_SEARCH=0xffffffff - its using 32-bit signed integer by default unless typeset -iU is used
        ;;

    *)
        SENSORID_SEARCH=$((0xffffffff))
        SENSORID_DISABLE=$((0xfffffffe))
        #ksh typeset option -iu for usigned int https://docstore.mik.ua/orelly/unix3/korn/appb_07.htm
        ;;
esac

WH31_TEMP_MAXCH=8
WH34_SOILTEMP_MAXCH=8
WH35_LEAFWETNESS_MAXCH=8
WH43_PM25_MAXCH=4
WH51_SOILMOISTURE_MAXCH=8
WH55_LEAK_MAXCH=4

SENSORTYPE_MAX=47 # for cmd read sensorid new

SENSORIDSTATE_CONNECTED=${SENSORIDSTATE_CONNECTED:="connected"}
SENSORIDSTATE_SEARCHING=${SENSORIDSTATE_SEARCHING:="searching"}
SENSORIDSTATE_DISABLED=${SENSORIDSTATE_DISABLED:="disabled"}

#default livedata headers
LIVEDATA_INTEMP_HEADER=${LIVEDATA_INTEMP_HEADER:="Indoor temperature"}
LIVEDATA_OUTTEMP_HEADER=${LIVEDATA_OUTTEMP_HEADER:="Outdoor temperature"}
LIVEDATA_INHUMI_HEADER=${LIVEDATA_INHUMI_HEADER:="Indoor humidity"}
LIVEDATA_OUTHUMI_HEADER=${LIVEDATA_OUTHUMI_HEADER:="Outdoor humidity"}

LIVEDATA_ABSBARO_HEADER=${LIVEDATA_ABSBARO_HEADER:="Absolute pressure"}
LIVEDATA_RELBARO_HEADER=${LIVEDATA_RELBARO_HEADER:="Relative pressure"}

LIVEDATA_WINDCHILL_HEADER=${LIVEDATA_WINDCHILL_HEADER:="Windchill"}
LIVEDATA_DEWPOINT_HEADER=${LIVEDATA_DEWPOINT_HEADER:="Dewpoint"}

LIVEDATA_WINDDAILYMAX_HEADER=${LIVEDATA_WINDDAILYMAX_HEADER:="Wind daily maximum"}
LIVEDATA_WINDDIRECTION_HEADER=${LIVEDATA_WINDDIRECTION_HEADER:="Wind direction"}
LIVEDATA_WINDDIRECTION_COMPASS_HEADER=${LIVEDATA_WINDDIRECTION_COMPASS_HEADER:="Wind compass direction"}
LIVEDATA_WINDGUSTSPEED_HEADER=${LIVEDATA_WINDGUSTSPEED_HEADER:="Wind gust speed"}
LIVEDATA_WINDSPEED_HEADER=${LIVEDATA_WINDSPEED_HEADER:="Wind speed"}

LIVEDATA_LIGHT_HEADER=${LIVEDATA_LIGHT_HEADER:="Light"}
LIVEDATA_UV_HEADER=${LIVEDATA_UV_HEADER:="Solar UV radiation"}
LIVEDATA_UVI_HEADER=${LIVEDATA_UVI_HEADER:="Solar UV index"}

LIVEDATA_RAINRATE_HEADER=${LIVEDATA_RAINRATE_HEADER:="Rain rate"}
LIVEDATA_RAINEVENT_HEADER=${LIVEDATA_RAINEVENT_HEADER:="Rain event"}
LIVEDATA_RAINHOUR_HEADER=${LIVEDATA_RAINHOUR_HEADER:="Rain hour"}
LIVEDATA_RAINDAY_HEADER=${LIVEDATA_RAINDAY_HEADER:="Rain day"}
LIVEDATA_RAINWEEK_HEADER=${LIVEDATA_RAINWEEK_HEADER:="Rain week"}
LIVEDATA_RAINMONTH_HEADER=${LIVEDATA_RAINMONTH_HEADER:="Rain month"}
LIVEDATA_RAINYEAR_HEADER=${LIVEDATA_RAINYEAR_HEADER:="Rain year"}

LIVEDATA_LEAK_YES=${LIVEDATA_LEAK_YES:="YES"}
LIVEDATA_LEAK_NO=${LIVEDATA_LEAK_NO:="NO"}

N=1
while [ "$N" -le "$WH31_TEMP_MAXCH" ]; do 
    eval LIVEDATA_TEMP_HEADER$N=\$\{LIVEDATA_TEMP_HEADER$N:=\"Temperature $N\"\}
    eval LIVEDATA_HUMIDITY_HEADER$N=\$\{LIVEDATA_HUMIDITY_HEADER$N:=\"Humidity $N\"\}
    N=$(( N + 1 ))
done

N=1
while [ "$N" -lt "$WH55_LEAK_MAXCH" ]; do 
    eval LIVEDATA_LEAK_HEADER$N=\$\{LIVEDATA_LEAK_HEADER$N:="Leak $N"\}
    N=$(( N + 1 ))
done


N=1
while [ "$N" -lt "$WH43_PM25_MAXCH" ]; do 
    eval LIVEDATA_PM25_HEADER$N=\$\{LIVEDATA_PM25_HEADER$N:="PM 2.5 $N"\}
    eval LIVEDATA_PM25_24HAVG_HEADER$N=\$\{LIVEDATA_PM25_24HAVG_HEADER$N:="PM 2.5 24h avg. $N"\}
    N=$(( N + 1 ))
done

N=1
while [ "$N" -lt "$WH51_SOILMOISTURE_MAXCH" ]; do 
    eval LIVEDATA_SOILMOISTURE_HEADER$N=\$\{LIVEDATA_SOILMOISTURE_HEADER$N:="Soilmoisture $N"\}
    N=$(( N + 1 ))
done

LIVEDATA_SYSTEM_VERSION_HEADER=${LIVEDATA_SYSTEM_VERSION_HEADER:="System version"}
LIVEDATA_SYSTEM_UTC_HEADER=${LIVEDATA_SYSTEM_UTC_HEADER:="System utc"}
LIVEDATA_SYSTEM_FREQUENCY_HEADER=${LIVEDATA_SYSTEM_FREQUENCY_HEADER:="System frequency"}

#ANSI esqape
#disable with -E option
#https://en.wikipedia.org/wiki/ANSI_escape_code
SGI_NORMAL='\e[0m'
SGI_INVERT='\e[1;7m'
#SGI_BLINK='\e[6m'
SGI_LIGHTBLUE_BLACK='\e[1;34m'
SGI_BRIGHTRED_BLACK='\e[1;31m'
SGI_BRIGHTGREEN_BLACK='\e[1;32m'
SGI_LIMIT_LIVEDATA=${SGI_LIMIT_LIVEDATA:=$SGI_INVERT}
SGI_LIMIT_LIVEDATA_OUTTEMP_LOW=${SGI_LIMIT_LIVEDATA_OUTTEMP_LOW:=$SGI_LIGHTBLUE_BLACK}
SGI_LIMIT_LIVEDATA_OUTTEMP_HIGH=${SGI_LIMIT_LIVEDATA_OUTTEMP_HIGH:=$SGI_BRIGHTRED_BLACK}
SGI_LIMIT_LIVEDATA_INTEMP_LOW=${SGI_LIMIT_LIVEDATA_INTEMP_LOW:=$SGI_LIGHTBLUE_BLACK}
SGI_LIMIT_LIVEDATA_INTEMP_HIGH=${SGI_LIMIT_LIVEDATA_INTEMP_HIGH:=$SGI_BRIGHTRED_BLACK}


SGI_BATTERY_LOW=${SGI_BATTERY_LOW:=$SGI_BRIGHTRED_BLACK}
SGI_SIGNAL_LOW=${SGI_SIGNAL_LOW:=$SGI_BRIGHTRED_BLACK}
SGI_LEAK=${SGI_LEAK:="\a"$SGI_BRIGHTRED_BLACK} # add alert/bell \a if leakage detected

#TERM_ANSI_ESCAPE=${TERM_ANSI_ESCAPE:=1}

#Limits for triggering of ansi escape highlights
LIMIT_LIVEDATA_WIND=${LIMIT_LIVEDATA_WIND:=80}  # 8 m/s - set param if value unset/null
LIMIT_LIVEDATA_RAINRATE=${LIMIT_LIVEDATA_RAINRATE:=10} # 1.0 mm/h - scale x10
LIMIT_LIVEDATA_RAINHOUR=${LIMIT_LIVEDATA_RAINHOUR:=10}
LIMIT_LIVEDATA_RAINDAY=${LIMIT_LIVEDATA_RAINDAILY:=30} # 3.0 mm
LIMIT_LIVEDATA_RAINEVENT=${LIMIT_LIVEDATA_RAINEVENT:=30}
LIMIT_LIVEDATA_RELBARO_LOW=${LIMIT_LIVEDATA_BAROREL_LOW:=9900} # 990 hpa - scale x10
LIMIT_LIVEDATA_OUTTEMP_LOW=${LIMIT_LIVEDATA_OUTTEMP_LOW:=-10} # -1.0 - scale x10
LIMIT_LIVEDATA_OUTTEMP_HIGH=${LIMIT_LIVEDATA_OUTTEMP_HIGH:=170} # 17.0 - scale x10
LIMIT_LIVEDATA_INTEMP_LOW=${LIMIT_LIVEDATA_INTEMP_LOW:=200} 
LIMIT_LIVEDATA_INTEMP_HIGH=${LIMIT_LIVEDATA_INTEMP_HIGH:=230} 


#is sent in http get request when data from sensors are not available, for example after reboot
WUNDERGROUND_UNDEFINED_VALUE="-9999"

getSensorBatteryState()
{
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
      #shellcheck disable=SC3044
      typeset channel
    else
      local channel
    fi

    #specification FOS_ENG-022-A, page 28
    unset SBATTERY_STATE

     case "$1" in
        0) getBatteryLowOrNormal "$2" # WH65
           LIVEDATA_WH65_BATTERY="$2"
           LIVEDATA_WH65_BATTERY_STATE="$SBATTERY_STATE"
            ;;
        1) getBatteryVoltageLevelState "$2" #WH68/WH69
           LIVEDATA_WH68_BATTERY="$2"
           LIVEDATA_WH68_BATTERY_STATE="$SBATTERY_STATE"
            ;;
        2) getBatteryVoltageLevelState "$2" #WH80 - ultrasonic
           LIVEDATA_WH80_BATTERY="$2"
           LIVEDATA_WH80_BATTERY_STATE="$SBATTERY_STATE"
            ;;
        3) getBatteryLowOrNormal "$2" #WH40 -rainfall
           LIVEDATA_WH40_RAINFALL_BATTERY="$2"
           LIVEDATA_WH40_RAINFALL_BATTERY_STATE="$SBATTERY_STATE"
            ;;
        5) getBatteryLowOrNormal "$2" #WH32 - temp out
           LIVEDATA_WH32_TEMPERATURE_BATTERY="$2"
           LIVEDATA_WH32_TEMPERATURE_BATTERY_STATE="$SBATTERY_STATE"
            ;;
        6|7|8|9|10|11|12|13)
           getBatteryLowOrNormal "$2" #WH31 - temp in
           channel=$(($1 - 5))
           eval "LIVEDATA_TEMP${channel}_BATTERY=$2"
           eval "LIVEDATA_TEMP${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
           ;;
        14|15|16|17|18|19|20|21)
           getBatteryVoltageLevelState "$2" #WH51 - soilmoisture
           channel=$(( $1 - 13))
           eval "LIVEDATA_SOILMOISTURE_CH${channel}_BATTERY_RAW=$2"
           eval "LIVEDATA_SOILMOISTURE_CH${channel}_BATTERY=$VALUE_BATTERY_VOLTAGE"
           eval "LIVEDATA_SOILMOISTURE_CH${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
          ;;
        22|23|24|25)
          getBatteryLevelState "$2"  #WH41 - PM2.5
          channel=$(( $1 - 21 ))
           eval "LIVEDATA_PM25_CH${channel}_BATTERY=$2"
           eval "LIVEDATA_PM25_CH${channel}_BATTERY_STATE=$SBATTERY_STATE"
          ;;
        26)
          getBatteryLevelState "$2"  #WH57 - Lightning
          LIVEDATA_WH57_LIGHTNING_BATTERY="$2"
          LIVEDATA_WH57_LIGHTNING_BATTERY_STATE="$SBATTERY_STATE"
          ;;
        27|28|29|30)
          getBatteryLevelState "$2"  #WH55 - Leak
          channel=$(( $1 - 26 ))
          eval "LIVEDATA_LEAK_CH${channel}_BATTERY=$2"
          eval "LIVEDATA_LEAK_CH${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
          ;;
        31|32|33|34|35|36|37|38)
           getBatteryVoltageLevelState "$2" #WH34 - Soiltemperature
           channel=$(( $1 - 30))
           eval "LIVEDATA_SOILTEMP_CH${channel}_BATTERY_RAW=$2"
           eval "LIVEDATA_SOILTEMP_CH${channel}_BATTERY=$VALUE_BATTERY_VOLTAGE"
           eval "LIVEDATA_SOILTEMP_CH${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
          ;;
        39)
           getBatteryLevelState "$2"  #WH45 - CO2 PM2.5 PM10 AQ
           #battery info also available from sensor read livedata
           LIVEDATA_WH45_CO2_BATTERY="$2"
           LIVEDATA_WH45_CO2_BATTERY_STATE="$SBATTERY_STATE"
          ;;
        40|41|42|43|44|45|46|47)
           getBatteryVoltageLevelState "$2" #WH35 - Leaf wetness
           channel=$(( $1 - 39))
           eval "LIVEDATA_LEAFWETNESS_CH${channel}_BATTERY_RAW=$2"
           eval "LIVEDATA_LEAFWETNESS_CH${channel}_BATTERY=$VALUE_BATTERY_VOLTAGE"
           eval "LIVEDATA_LEAFWETNESS_CH${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
           ;;
    esac

    if [ -n "$KSH_VERSION" ]; then
      unset channel
    fi
}

getSensorNameShort()
{
    case "$1" in
        0) if [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH24 ]; then
             SENSORNAME_WH='WH24'
             SENSORNAME_SHORT='Wind/Temp./UV'
            else
              SENSORNAME_WH='WH65'
              SENSORNAME_SHORT="Wind/Temp./UV"
            fi
            ;;
        1) SENSORNAME_WH='WH68'
           SENSORNAME_SHORT="Wind/Temp./UV"
            ;;
        2) SENSORNAME_WH="WH80"
           SENSORNAME_SHORT='Wind/Temp./UV'
            ;;
        3) SENSORNAME_WH="WH40"
           SENSORNAME_SHORT="Rainfall"
            ;;
        5) SENSORNAME_WH='WH32'
           SENSORNAME_SHORT='Temperatue out'
            ;;
        6|7|8|9|10|11|12|13)
           SENSORNAME_WH='WH31'
           SENSORNAME_SHORT="Temperature$(($1 - 5))"
           ;;
        14|15|16|17|18|19|20|21)
          SENSORNAME_WH='WH51'
          SENSORNAME_SHORT="Soilmoisture$(($1 - 13))"
          ;;
        22|23|24|25)
          SENSORNAME_WH='WH43'
          SENSORNAME_SHORT="PM2.5 AQ $(($1 - 21))"
          ;;
        26)
          SENSORNAME_SHORT="Lightning"
          SENSORNAME_WH='WH57'
          ;;
        27|28|29|30)
          SENSORNAME_WH='WH55'
          SENSORNAME_SHORT="Leak$(($1 - 26))"
          ;;
        31|32|33|34|35|36|37|38)

          SENSORNAME_WH='WH34'
          SENSORNAME_SHORT="Soiltemperature$(($1 - 30))"
          ;;
        39)
          SENSORNAME_WH='WH45'
          SENSORNAME_SHORT="CO2 PM2.5 PM10 AQ"
          ;;
        40|41|42|43|44|45|46|47)

            SENSORNAME_WH='WH35'
            SENSORNAME_SHORT="Leafwetness$(($1 - 39))"
           ;;
         *)
          SENSORNAME_WH='WH??' 
          SENSORNAME_SHORT='?'
    esac
}

getCommandName() { #$1 -decimal command
    case "$1" in
        "$CMD_READ_VERSION")            COMMAND_NAME='read version' ;;
        "$CMD_READ_VERSION")            COMMAND_NAME='read version' ;;
        "$CMD_REBOOT")                  COMMAND_NAME='reboot' ;;
        "$CMD_READ_MAC")                COMMAND_NAME='read mac' ;;
        "$CMD_WRITE_SSID")              COMMAND_NAME='write ssid' ;;
        "$CMD_BROADCAST")               COMMAND_NAME='broadcast' ;;
        "$CMD_WRITE_RESET")             COMMAND_NAME='write reset' ;;
        "$CMD_READ_ECOWITT_INTERVAL")   COMMAND_NAME='read ecowitt interval' ;;
        "$CMD_WRITE_ECOWITT_INTERVAL")  COMMAND_NAME='write ecowitt interval' ;;
        "$CMD_READ_WUNDERGROUND")       COMMAND_NAME='read wunderground' ;;
        "$CMD_WRITE_WUNDERGROUND")      COMMAND_NAME='write wunderground' ;;
        "$CMD_READ_WOW")                COMMAND_NAME='read wow' ;;
        "$CMD_WRITE_WOW")               COMMAND_NAME='write wow' ;;
        "$CMD_READ_WEATHERCLOUD")       COMMAND_NAME='read weathercloud' ;;
        "$CMD_WRITE_WEATHERCLOUD")      COMMAND_NAME='write weathercloud' ;;
        "$CMD_READ_CUSTOMIZED")         COMMAND_NAME='read customized' ;;
        "$CMD_WRITE_CUSTOMIZED")        COMMAND_NAME='write customized' ;;
        "$CMD_READ_PATH")               COMMAND_NAME='read path' ;;
        "$CMD_WRITE_PATH")              COMMAND_NAME='write path' ;;
        "$CMD_READ_RAINDATA")           COMMAND_NAME='read raindata' ;;
        "$CMD_WRITE_RAINDATA")          COMMAND_NAME='write raindata' ;;
        "$CMD_LIVEDATA")                COMMAND_NAME='livedata' ;;
        "$CMD_READ_SENSOR_ID")          COMMAND_NAME='read sensor id' ;;
        "$CMD_WRITE_SENSOR_ID")         COMMAND_NAME='write sensor id' ;;
        "$CMD_READ_SENSOR_ID_NEW")      COMMAND_NAME='read sensor id new' ;;
        "$CMD_READ_SYSTEM")             COMMAND_NAME='read system' ;;
        "$CMD_WRITE_SYSTEM")            COMMAND_NAME='write system' ;;
        "$CMD_READ_CALIBRATION")        COMMAND_NAME='read calibration' ;;
        "$CMD_WRITE_CALIBRATION")       COMMAND_NAME='write calibration' ;;
    esac
    
    if [ -z "$COMMAND_NAME" ]; then
        COMMAND_NAME="{cmdname missing} $1"
        return 1
    fi
}

newBuffer() {
    eval "$1=\"$2\""
}

writeUInt32BE() {
    PACKET_TX_BODY="$PACKET_TX_BODY $(($1 >> 24)) $((($1 & 0xff0000) >> 16))  $((($1 & 0xff00) >> 8))  $(($1 & 0xff)) "
}

writeUInt16BE() {
    [ "$DEBUG" -eq 1 ] && >&2 echo writeUInt16BE "$1" 
    PACKET_TX_BODY="$PACKET_TX_BODY $(($1 >> 8)) $(($1 & 0xff)) "
}

writeUInt8() {
    PACKET_TX_BODY="$PACKET_TX_BODY $1 "
}

readSlice() { #$1 - number of bytes n to read
    #read bytes available in $B1,...,$Bn
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset n
    else
        local n
    fi

    n=1
    while [ "$n" -le "$1" ]; do
        readUInt8
        eval "B$n=$VALUE_UINT8"
        if [ "$n" -le 6 ]; then # auto convert to hex for printing of MAC/broadcast command
        #shellcheck disable=SC2027
           eval "convertUInt8ToHex \"\$B$n\"; B"$n"HEX=\$VALUE_HEX"
        fi
        n=$((n + 1))
    done

    if [ -n  "$KSH_VERSION" ]; then
      unset n
    fi
}

readUInt8() {
    unset VALUE_UINT8

    if [ ${#OD_BUFFER} -ge 4 ]; then # 4 = max 3 spaces and 1 digit

        for BYTE in $OD_BUFFER; do
            VALUE_UINT8=$((BYTE))
            OD_BUFFER=${OD_BUFFER#*"$BYTE"} #  # - remove shortest prefix pattern
            break
        done
    else
        return "$ERROR_OD_BUFFER_EMPTY"
    fi
}

readInt8() {
    readUInt8
    VALUE_INT8=$((-1 * (VALUE_UINT8 >> 7) * 0x80 + (VALUE_UINT8 & 0x7f)))
}

readUInt16BE() {
    unset VALUE_UINT16BE

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset msb
    else
        local msb
    fi

    readUInt8
    msb=$VALUE_UINT8
    readUInt8
    VALUE_UINT16BE=$(((msb << 8) | VALUE_UINT8))
}

readUInt32BE() {
    unset VALUE_UINT32BE

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset msb lsb msb2 lsb2
    else
        local   msb lsb msb2 lsb2
    fi

    if [ ${#OD_BUFFER} -ge 19 ]; then
        readUInt8
        msb=$VALUE_UINT8
        readUInt8
        lsb=$VALUE_UINT8
        readUInt8
        msb2=$VALUE_UINT8
        readUInt8
        lsb2=$VALUE_UINT8

        VALUE_UINT32BE=$(((msb << 24) | (lsb << 16) | (msb2 << 8) | lsb2))
    else
        return "$ERROR_OD_BUFFER_EMPTY"
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset msb lsb msb2 lsb2
    fi
}

readInt16BE() { #2's complement big endian
    #msb is the sign bit
    #VALUE_INT16BE_HEX=$hexstr
    #Converting from two's complement representation https://en.wikipedia.org/wiki/Two%27s_complement

    readUInt16BE

    VALUE_INT16BE=$((-1 * (VALUE_UINT16BE >> 15) * 32768 + (VALUE_UINT16BE & 32767)))
}

readInt32BE() { #2's complement big endian
    #msb is the sign bit

    readUInt32BE
    VALUE_INT32BE=$((-1 * (VALUE_UINT32BE >> 31) * 0x80000000 + (VALUE_UINT32BE & 0x7fffffff)))

}

writeString()
{
  # PACKET_TX_BODY="${#1} $(printf "%s" "$1" | od -A n -t u1)"

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset len str decstr n
    else
        local  len str decstr n
    fi 

    str=$1
    len=${#str}

    [ "$DEBUG" -eq 1 ] && >&2 echo  "writeString $1 len $len"

    PACKET_TX_BODY="$PACKET_TX_BODY $len"
    unset APPEND_FORMAT APPEND_STRING

    n=1
    while [ -n "$str" ]; do
        suffix=${str#?}
        eval C$n='${str%%"$suffix"}'
        APPEND_FORMAT=$APPEND_FORMAT'%d ' # wait with printf-processing until entire sting is built
        APPEND_STRING=$APPEND_STRING'\"$'"C$n " # \'$var or \"$var - char to ascii conversion in printf bulitin/command argument
        str=$suffix
        n=$(( n + 1 ))
    done

    if [ "$SHELL_SUPPORT_PRINTF_VOPT" -eq  1 ] && [ -n "$APPEND_FORMAT" ]; then
        eval printf -v decstr \""$APPEND_FORMAT"\" "$APPEND_STRING"
        PACKET_TX_BODY="$PACKET_TX_BODY $decstr"
    elif [ -n "$APPEND_FORMAT" ]; then
        PACKET_TX_BODY="$PACKET_TX_BODY $(eval printf \""$APPEND_FORMAT"\" "$APPEND_STRING")" #ok, run in subshell
    fi

    #cleanup variables
    n=1
    while [ "$n" -le "$len" ]; do
        unset C$n 
        n=$(( n + 1 ))
    done

    if [ -n "$KSH_VERSION" ]; then
        unset len str decstr n
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo  "writeString $PACKET_TX_BODY"

}


readString() { #https://bugs.launchpad.net/ubuntu/+source/dash/+bug/1499473
    #\x formatted printf not supported in dash -> must use \nnn-octal
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset len_uint8 n
    else
        local   len_uint8 n
    fi

    readUInt8
    len_uint8=$VALUE_UINT8
    [ $DEBUG -eq 1 ] && echo >&2 "String length $len_uint8"

    unset VALUE_STRING_ESCAPE
    unset VALUE_STRING

    n=1
    while [ "$n" -le "$len_uint8" ]; do

        readUInt8

        convertHexToOctal "$VALUE_UINT8"
        VALUE_STRING_ESCAPE="$VALUE_STRING_ESCAPE\\0$VALUE_OCTAL"

        n=$((n + 1))

    done

    if [ "$SHELL_SUPPORT_PRINTF_VOPT" -eq 1 ]; then
        #shellcheck disable=SC3045
         printf -v VALUE_STRING "%b" "$VALUE_STRING_ESCAPE"
    else
       VALUE_STRING=$(printf "%b" "$VALUE_STRING_ESCAPE") # convert to string
    fi

    if [ -n "$KSH_VERSION" ]; then
        unset len_uint8 n
    fi
}

printBuffer() { # print hex. buffer
    #$1 decimal buffer
    unset APPEND_STRING

    for BYTE in $1; do
        convertUInt8ToHex "$BYTE"
        APPEND_STRING=$APPEND_STRING" $VALUE_HEX"
    done
    
    echo "$APPEND_STRING"
}

convertWindDirectionToCompassDirection() { #$1 - direction in degrees
    #http://snowfence.umn.edu/Components/winddirectionanddegrees.htm
    unset VALUE_COMPASS_DIRECTION

    if [ "$1" -le 11 ] || [ "$1" -gt 349 ]; then
        VALUE_COMPASS_DIRECTION="N"

    elif [ "$1" -gt 11 ] && [ "$1" -lt 34 ]; then
        VALUE_COMPASS_DIRECTION="NNE"

    elif [ "$1" -ge 34 ] && [ "$1" -le 56 ]; then
        VALUE_COMPASS_DIRECTION="NE"

    elif [ "$1" -gt 56 ] && [ "$1" -le 79 ]; then
        VALUE_COMPASS_DIRECTION="ENE"

    elif [ "$1" -gt 79 ] && [ "$1" -le 101 ]; then
        VALUE_COMPASS_DIRECTION="E"

    elif [ "$1" -gt 101 ] && [ "$1" -le 124 ]; then
        VALUE_COMPASS_DIRECTION="ESE"

    elif [ "$1" -gt 124 ] && [ "$1" -le 146 ]; then
        VALUE_COMPASS_DIRECTION="SE"

    elif [ "$1" -gt 146 ] && [ "$1" -le 169 ]; then
        VALUE_COMPASS_DIRECTION="SSE"

    elif [ "$1" -gt 169 ] && [ "$1" -le 191 ]; then
        VALUE_COMPASS_DIRECTION="S"

    elif [ "$1" -gt 191 ] && [ "$1" -le 214 ]; then
        VALUE_COMPASS_DIRECTION="SSW"

    elif [ "$1" -gt 214 ] && [ "$1" -le 236 ]; then
        VALUE_COMPASS_DIRECTION="SW"

    elif [ "$1" -gt 236 ] && [ "$1" -le 259 ]; then
        VALUE_COMPASS_DIRECTION="WSW"

    elif [ "$1" -gt 259 ] && [ "$1" -le 281 ]; then
        VALUE_COMPASS_DIRECTION="W"

    elif [ "$1" -gt 281 ] && [ "$1" -le 304 ]; then
        VALUE_COMPASS_DIRECTION="WNW"

    elif [ "$1" -gt 304 ] && [ "$1" -le 326 ]; then
        VALUE_COMPASS_DIRECTION="NW"

    elif [ "$1" -gt 326 ] && [ "$1" -le 349 ]; then
        VALUE_COMPASS_DIRECTION="NNW"
    fi
}

appendBatteryState()
{
   if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
        SBATTERY_STATE=$SBATTERY_STATE"🔋"
   else
        SBATTERY_STATE=$SBATTERY_STATE"+"
   fi 
}

appendLowBatteryState()
{
   # if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
    #https://emojipedia.org/low-battery/
        # SBATTERY_STATE=$SBATTERY_STATE"🪫" 
    #    SBATTERY_STATE=$SBATTERY_STATE"_"
   # else
   #     SBATTERY_STATE=$SBATTERY_STATE"-"
   # fi
   :
}

getBatteryVoltageLevelState()
#$1 - volatage scaled *10
{
     if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
  #      typeset -i  i
    :
    else
   #     local       i
    :
    fi

   unset SBATTERY_STATE

   if [ "$1" -le 12 ]; then
      appendLowBatteryState
   else
    # i=13
    # while [ "$i" -le "$1" ]; do
       appendBatteryState # not really linear, but approximate 
    #   i=$(( i + 1 ))
    # done
   fi

   convertScale10ToFloat "$1"
   VALUE_BATTERY_VOLTAGE=$VALUE_SCALE10_FLOAT
   SBATTERY_STATE=$SBATTERY_STATE" $VALUE_BATTERY_VOLTAGE V"

   if [ -n "$KSH_VERSION" ]; then
        unset  i
    fi
}

getBatteryLevelState() { # $1 - battery level 0-6, 6 = dc, <=1 low
    
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset -i  l
    else
        local       l
    fi

    unset SBATTERY_STATE
   
    #set -- 0     #debug  set $1 to 0
    if [ "$1" -eq 6 ]; then
      if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
       #https://emojipedia.org/electric-plug/
        SBATTERY_STATE="🔌"
      else
        SBATTERY_STATE="dc" # for example PM 2.5 indoor
      fi
    else
       # l=1
       # while [ "$l" -le 5 ] ; do
       #     if [ "$l" -le "$1" ]; then
       #         appendBatteryState
       #     else
       #         appendLowBatteryState
       #     fi
       #     l=$((l + 1))
       # done
       if [ "$1" -le 1 ]; then
          appendLowBatteryState
       else
          appendBatteryState
       fi

       SBATTERY_STATE=$SBATTERY_STATE" $1"
    fi

    

    if [ -n "$KSH_VERSION" ]; then
        unset  l
    fi
}

getBatteryLowOrNormal() {
    
    unset SBATTERY_STATE

    if [ "$1" -eq $BATTERY_NORMAL ]; then
       appendBatteryState
    elif [ "$1" -eq $BATTERY_LOW ]; then
        appendLowBatteryState
    fi
}

toLowercase() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset -l lowcasestr # -l option -> lowercase on assignment/or ignored
    else
        local lowcasestr
    fi

    if [ -n "$BASH_VERSION" ]; then
        eval 'LOWERCASE=${1,,}' #eval prevents ksh from stopping parsing on syntax error
    elif [ -n "$ZSH_VERSION" ]; then
        #shellcheck disable=SC3057
        LOWERCASE=${1:l}
    elif [ -n "$KSH_VERSION" ]; then
        # Android 11 runds mir bsd korn shell http://www.mirbsd.org/mksh.htm
        lowcasestr=$1
        LOWERCASE=$lowcasestr
    else
        LOWERCASE=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    fi

    if [ -n "$KSH_VERSION" ]; then
       unset lowcasestr
    fi

}

initTimezones() {
    #dash: read only 1 byte each time from pipe/here document, not entire line
    #bash: creates /tmp/sh-thd file
    #tool: strace -f dash -c "./gw -h 192.168.3.80 -c system &>strace-log"
    # if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
    #shellcheck disable=SC3044
    #    typeset n
    # else
    #   local n
    # fi
    #zsh read -A assigns to array, #bash -a assigns to array ?! -> do a while loop over heredoc
    #https://stackoverflow.com/questions/2337616/can-i-read-line-from-a-heredoc-in-bash
    #echo "(UTC-12:00)International Date Line West", "(UTC-11:00)Samoa", "(UTC-11:00)Coordinated Universal Time-11", "(UTC-10:00)Aleutian Islands", "(UTC-10:00)Hawaii", "(UTC-09:30)Marquesas Islands", "(UTC-09:00)Alaska", "(UTC-09:00)Coordinated Universal Time-9", "(UTC-08:00)Pacific Time (US & Canada)", "(UTC-08:00)Baja California", "(UTC-08:00)Coordinated Universal Time-8", "(UTC-07:00)Chihuahua,La Paz,Mazatlan", "(UTC-07:00)Mountain Time (US & Canada)", "(UTC-07:00)Arizona", "(UTC-06:00)Guadalajara,Mexico City,Monterrey", "(UTC-06:00)Saskatchewan", "(UTC-06:00)Central Time (US & Canada)", "(UTC-06:00)Central America", "(UTC-05:00)Bogota,Lima,Quito", "(UTC-05:00)Eastern Time (US & Canada)", "(UTC-05:00)Havana", "(UTC-05:00)Hayti", "(UTC-05:00)Chetumal", "(UTC-05:00)Indiana (East)", "(UTC-04:30)Caracas", "(UTC-04:00)Atlantic Time (Canada)", "(UTC-04:00)Cuiaba", "(UTC-04:00)Georgetown,La Paz,Manaus,San Juan", "(UTC-04:00)Santiago", "(UTC-04:00)Asuncion", "(UTC-03:30)Newfoundland", "(UTC-03:00)Brasilia", "(UTC-03:00)Buenos Aires", "(UTC-03:00)Greenland", "(UTC-03:00)Cayenne,Fortaleza", "(UTC-03:00)Montevideo", "(UTC-02:00)Coordinated Universal Time-02", "(UTC-01:00)Cape Verde Is.", "(UTC-01:00)Azores", "(UTC)Dublin,Edinburgh,Lisbon,London", "(UTC)Casablanca", "(UTC)Monrovia,Reykjavik", "(UTC)Coordinated Universal Time", "(UTC+01:00)Amsterdam,Berlin,Bern,Rome,Stockholm,Vienna", "(UTC+01:00)Belgrade,Bratislava,Budapest,Ljubljana,Prague", "(UTC+01:00)Brussels,Copenhagen,Madrid,Paris", "(UTC+01:00)Sarajevo,Skopje,Warsaw,Zagreb", "(UTC+01:00)Windhoek", "(UTC+01:00)West Central Africa", "(UTC+02:00)Amman", "(UTC+02:00)Beirut", "(UTC+02:00)Damascus", "(UTC+02:00)Harare,Pretoria", "(UTC+02:00)Helsinki,Kyiv,Riga,Sofia,Talinn,Vilnius", "(UTC+02:00)Cairo", "(UTC+02:00)Athens,Bucharest,Istanbul", "(UTC+02:00)Jerusalem", "(UTC+03:00)Baghdad", "(UTC+03:00)Kuwait,Riyadh", "(UTC+03:00)Minsk", "(UTC+03:00)Moscow,St.Petersburg,Volgograd", "(UTC+03:00)Nairobi", "(UTC+03:30)Tehran", "(UTC+04:00)Abu Dhabi,Muscat", "(UTC+04:00)Yerevan", "(UTC+04:00)Baku", "(UTC+04:00)Tbilisi", "(UTC+04:00)Port Louis", "(UTC+04:30)Kabul", "(UTC+05:00)Tashkent", "(UTC+05:00)Ekaterinburg", "(UTC+05:00)Islamabad,Karachi", "(UTC+05:30)Chennai,Kolkata,Mumbai,New Delhi", "(UTC+05:30)Sri Jayawardenepura", "(UTC+05:45)Kathmandu", "(UTC+06:00)Astana", "(UTC+06:00)Dhaka", "(UTC+06:00)Novosibirsk", "(UTC+06:30)Yangon (Rangoon)", "(UTC+07:00)Kobdo", "(UTC+07:00)Krasnoyarsk", "(UTC+07:00)Bangkok,Hanoi,Jakarta", "(UTC+08:00)Beijing,Chongqing,Hong Kong,Urumqi", "(UTC+08:00)Kuala Lumpur,Singapore", "(UTC+08:00)Perth", "(UTC+08:00)Taipei", "(UTC+08:00)Ulaanbaatar", "(UTC+08:00)Irkutsk", "(UTC+09:00)Pyongyang", "(UTC+09:00)Osaka,Sapporo,Tokyo", "(UTC+09:00)Seoul", "(UTC+09:00)Yakutsk", "(UTC+09:30)Adelaide", "(UTC+09:30)Darwin", "(UTC+10:00)Brisbane", "(UTC+10:00)Vladivostok", "(UTC+10:00)Guam,Port Moresby", "(UTC+10:00)Hobart", "(UTC+10:00)Canberra,Melbourne,Sydney", "(UTC+10:30)Lord Howe Island", "(UTC+11:00)Magadan", "(UTC+11:00)Solomon Is.,New Caledonia", "(UTC+12:00)Auckland,Wellington", "(UTC+12:00)Fiji", "(UTC+12:00)Coordinated Universal Time+12", "(UTC+12:45)Chatham Islands", "(UTC+13:00)Nuku'alofa", "(UTC+14:00)Christmas Island" | cut -d ',' -f 1- --output-delimiter=$'\n'
    #Based on decompiled /WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/SystemFragment.java
    # n=0
    # while read -r line; do
    #     eval "SYSTEM_TIMEZONE_$n='$line'"
    #     n=$(( n + 1 ))
    # done <<EOF
    #shellcheck disable=SC2034
    {
        SYSTEM_TIMEZONE_1='(UTC-12:00) International Date Line West'
        SYSTEM_TIMEZONE_2='(UTC-11:00) Samoa'
        SYSTEM_TIMEZONE_3='(UTC-11:00) Coordinated Universal Time-11'
        SYSTEM_TIMEZONE_4='(UTC-10:00) Aleutian Islands'
        SYSTEM_TIMEZONE_5='(UTC-10:00) Hawaii'
        SYSTEM_TIMEZONE_6='(UTC-09:30) Marquesas Islands'
        SYSTEM_TIMEZONE_7='(UTC-09:00) Alaska'
        SYSTEM_TIMEZONE_8='(UTC-09:00) Coordinated Universal Time-9'
        SYSTEM_TIMEZONE_9='(UTC-08:00) Pacific Time (US & Canada)'
        SYSTEM_TIMEZONE_10='(UTC-08:00) Baja California'
        SYSTEM_TIMEZONE_11='(UTC-08:00) Coordinated Universal Time-8'
        SYSTEM_TIMEZONE_12='(UTC-07:00) Chihuahua, La Paz, Mazatlan'
        SYSTEM_TIMEZONE_13='(UTC-07:00) Mountain Time (US & Canada)'
        SYSTEM_TIMEZONE_14='(UTC-07:00) Arizona'
        SYSTEM_TIMEZONE_15='(UTC-06:00) Guadalajara, Mexico City,Monterrey'
        SYSTEM_TIMEZONE_16='(UTC-06:00) Saskatchewan'
        SYSTEM_TIMEZONE_17='(UTC-06:00) Central Time (US & Canada)'
        SYSTEM_TIMEZONE_18='(UTC-06:00) Central America'
        SYSTEM_TIMEZONE_19='(UTC-05:00) Bogota, Lima, Quito'
        SYSTEM_TIMEZONE_20='(UTC-05:00) Eastern Time (US & Canada)'
        SYSTEM_TIMEZONE_21='(UTC-05:00) Havana'
        SYSTEM_TIMEZONE_22='(UTC-05:00) Hayti'
        SYSTEM_TIMEZONE_23='(UTC-05:00) Chetumal'
        SYSTEM_TIMEZONE_24='(UTC-05:00) Indiana (East)'
        SYSTEM_TIMEZONE_25='(UTC-04:30) Caracas'
        SYSTEM_TIMEZONE_26='(UTC-04:00) Atlantic Time (Canada)'
        SYSTEM_TIMEZONE_27='(UTC-04:00) Cuiaba'
        SYSTEM_TIMEZONE_28='(UTC-04:00) Georgetown, La Paz, Manaus, San Juan'
        SYSTEM_TIMEZONE_29='(UTC-04:00) Santiago'
        SYSTEM_TIMEZONE_30='(UTC-04:00) Asuncion'
        SYSTEM_TIMEZONE_31='(UTC-03:30) Newfoundland'
        SYSTEM_TIMEZONE_32='(UTC-03:00) Brasilia'
        SYSTEM_TIMEZONE_33='(UTC-03:00) Buenos Aires'
        SYSTEM_TIMEZONE_34='(UTC-03:00) Greenland'
        SYSTEM_TIMEZONE_35='(UTC-03:00) Cayenne, Fortaleza'
        SYSTEM_TIMEZONE_36='(UTC-03:00) Montevideo'
        SYSTEM_TIMEZONE_37='(UTC-02:00) Coordinated Universal Time-02'
        SYSTEM_TIMEZONE_38='UTC-01:00) Cape Verde Is.'
        SYSTEM_TIMEZONE_39='(UTC-01:00) Azores'
        SYSTEM_TIMEZONE_40='(UTC) Dublin, Edinburgh, Lisbon, London'
        SYSTEM_TIMEZONE_41='(UTC) Casablanca'
        SYSTEM_TIMEZONE_42='(UTC) Monrovia, Reykjavik'
        SYSTEM_TIMEZONE_43='(UTC) Coordinated Universal Time'
        SYSTEM_TIMEZONE_44='(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna'
        SYSTEM_TIMEZONE_45='(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague'
        SYSTEM_TIMEZONE_46='(UTC+01:00) Brussels, Copenhagen, Madrid, Paris'
        SYSTEM_TIMEZONE_47='(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb'
        SYSTEM_TIMEZONE_48='(UTC+01:00) Windhoek'
        SYSTEM_TIMEZONE_49='(UTC+01:00) West Central Africa'
        SYSTEM_TIMEZONE_50='(UTC+02:00) Amman'
        SYSTEM_TIMEZONE_51='(UTC+02:00) Beirut'
        SYSTEM_TIMEZONE_52='(UTC+02:00) Damascus'
        SYSTEM_TIMEZONE_53='(UTC+02:00) Harare, Pretoria'
        SYSTEM_TIMEZONE_54='(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Talinn, Vilnius'
        SYSTEM_TIMEZONE_55='(UTC+02:00) Cairo'
        SYSTEM_TIMEZONE_56='(UTC+02:00) Athens, Bucharest, Istanbul'
        SYSTEM_TIMEZONE_57='(UTC+02:00) Jerusalem'
        SYSTEM_TIMEZONE_58='(UTC+03:00) Baghdad'
        SYSTEM_TIMEZONE_59='(UTC+03:00) Kuwait, Riyadh'
        SYSTEM_TIMEZONE_60='(UTC+03:00) Minsk'
        SYSTEM_TIMEZONE_61='(UTC+03:00) Moscow, St.Petersburg, Volgograd'
        SYSTEM_TIMEZONE_62='(UTC+03:00) Nairobi'
        SYSTEM_TIMEZONE_63='(UTC+03:30) Tehran'
        SYSTEM_TIMEZONE_64='(UTC+04:00) Abu Dhabi, Muscat'
        SYSTEM_TIMEZONE_65='(UTC+04:00) Yerevan'
        SYSTEM_TIMEZONE_66='(UTC+04:00) Baku'
        SYSTEM_TIMEZONE_67='(UTC+04:00) Tbilisi'
        SYSTEM_TIMEZONE_68='(UTC+04:00) Port Louis'
        SYSTEM_TIMEZONE_69='(UTC+04:30) Kabul'
        SYSTEM_TIMEZONE_70='(UTC+05:00) Tashkent'
        SYSTEM_TIMEZONE_71='(UTC+05:00) Ekaterinburg'
        SYSTEM_TIMEZONE_72='(UTC+05:00) Islamabad, Karachi'
        SYSTEM_TIMEZONE_73='(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi'
        SYSTEM_TIMEZONE_74='(UTC+05:30) Sri Jayawardenepura'
        SYSTEM_TIMEZONE_75='(UTC+05:45) Kathmandu'
        SYSTEM_TIMEZONE_76='(UTC+06:00) Astana'
        SYSTEM_TIMEZONE_77='(UTC+06:00) Dhaka'
        SYSTEM_TIMEZONE_78='(UTC+06:00) Novosibirsk'
        SYSTEM_TIMEZONE_79='(UTC+06:30) Yangon (Rangoon)'
        SYSTEM_TIMEZONE_80='(UTC+07:00) Kobdo'
        SYSTEM_TIMEZONE_81='(UTC+07:00) Krasnoyarsk'
        SYSTEM_TIMEZONE_82='(UTC+07:00) Bangkok, Hanoi, Jakarta'
        SYSTEM_TIMEZONE_83='(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi'
        SYSTEM_TIMEZONE_84='(UTC+08:00) Kuala Lumpur, Singapore'
        SYSTEM_TIMEZONE_85='(UTC+08:00) Perth'
        SYSTEM_TIMEZONE_86='(UTC+08:00) Taipei'
        SYSTEM_TIMEZONE_87='(UTC+08:00) Ulaanbaatar'
        SYSTEM_TIMEZONE_88='(UTC+08:00) Irkutsk'
        SYSTEM_TIMEZONE_89='(UTC+09:00) Pyongyang'
        SYSTEM_TIMEZONE_90='(UTC+09:00) Osaka, Sapporo, Tokyo'
        SYSTEM_TIMEZONE_91='(UTC+09:00) Seoul'
        SYSTEM_TIMEZONE_92='(UTC+09:00) Yakutsk'
        SYSTEM_TIMEZONE_93='(UTC+09:30) Adelaide'
        SYSTEM_TIMEZONE_94='(UTC+09:30) Darwin'
        SYSTEM_TIMEZONE_95='(UTC+10:00) Brisbane'
        SYSTEM_TIMEZONE_96='(UTC+10:00) Vladivostok'
        SYSTEM_TIMEZONE_97='(UTC+10:00) GuamPort Moresby'
        SYSTEM_TIMEZONE_98='(UTC+10:00) Hobart'
        SYSTEM_TIMEZONE_99='(UTC+10:00) Canberra, Melbourne, Sydney'
        SYSTEM_TIMEZONE_100='(UTC+10:30) Lord Howe Island'
        SYSTEM_TIMEZONE_101='(UTC+11:00) Magadan'
        SYSTEM_TIMEZONE_102='(UTC+11:00) Solomon Is., New Caledonia'
        SYSTEM_TIMEZONE_103='(UTC+12:00) Auckland, Wellington'
        SYSTEM_TIMEZONE_104='(UTC+12:00) Fiji'
        SYSTEM_TIMEZONE_105='(UTC+12:00) Coordinated Universal Time+12'
        SYSTEM_TIMEZONE_106='(UTC+12:45) Chatham Islands'
        SYSTEM_TIMEZONE_107='(UTC+13:00) Nuku'\''alofa'
        SYSTEM_TIMEZONE_108='(UTC+14:00) Christmas Island'
    }
    #EOF
    SYSTEM_TIMEZONE_MAX_INDEX=108
}

printSystem() {
    echo "system frequency  $C_SYSTEM_FREQUENCY $C_SYSTEM_FREQUENCY_STATE
system sensortype $C_SYSTEM_SENSORTYPE $C_SYSTEM_SENSORTYPE_STATE
system utc        $C_SYSTEM_UTC $C_SYSTEM_UTC_STATE
system tz index   $C_SYSTEM_TIMEZONE_INDEX $C_SYSTEM_TIMEZONE_INDEX_STATE
system dst        $C_SYSTEM_DST_STATUS dst $C_SYSTEM_DST_STATUS_STATE auto $C_SYSTEM_TIMEZONE_AUTO_STATE"
}

parseSystem() {
    readUInt8

    C_SYSTEM_FREQUENCY=$VALUE_UINT8
    if [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM433M ]; then
        C_SYSTEM_FREQUENCY_STATE="433 MHz"
    elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM868M ]; then
        C_SYSTEM_FREQUENCY_STATE="868 MHz"
    elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM915M ]; then
        C_SYSTEM_FREQUENCY_STATE="915 MHz"
    elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM920M ]; then
        C_SYSTEM_FREQUENCY_STATE="920 MHz"
    fi
    LIVEDATA_SYSTEM_FREQUENCY=$C_SYSTEM_FREQUENCY_STATE

    readUInt8

    C_SYSTEM_SENSORTYPE=$VALUE_UINT8
    if [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH24 ]; then
        #       SENSOR_TYPE[WH24_TYPE]="WH24:Outdoor Weather Sensor:16.0:" # overwrite default WH65_TYPE=0
        C_SYSTEM_SENSORTYPE_STATE="WH24"
    elif [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH65 ]; then
        C_SYSTEM_SENSORTYPE_STATE="WH65"
    fi

    readUInt32BE

    C_SYSTEM_UTC=$VALUE_UINT32BE
    C_SYSTEM_UTC_STATE="$(date -u -d @"$VALUE_UINT32BE" +'%F %T')"
    LIVEDATA_SYSTEM_UTC=$C_SYSTEM_UTC_STATE

    readUInt8

    C_SYSTEM_TIMEZONE_INDEX=$VALUE_UINT8

    eval "C_SYSTEM_TIMEZONE_INDEX_STATE=\$SYSTEM_TIMEZONE_$C_SYSTEM_TIMEZONE_INDEX" # set from SYSTEM_TIMEZONE "array" variable with index

    readUInt8

    C_SYSTEM_DST_STATUS=$VALUE_UINT8
    C_SYSTEM_DST_STATUS_BIT=$((C_SYSTEM_DST_STATUS & 0x01))
    if [ "$C_SYSTEM_DST_STATUS_BIT" -eq 1 ]; then
        C_SYSTEM_DST_STATUS_STATE="on"
    elif [ "$C_SYSTEM_DST_STATUS_BIT" -eq 0 ]; then
        C_SYSTEM_DST_STATUS_STATE="off"
    fi

    C_SYSTEM_TIMEZONE_AUTO_BIT=$(((C_SYSTEM_DST_STATUS & 0x2) >> 1)) # bit 2 1= off, 0=on ?
    if [ "$C_SYSTEM_TIMEZONE_AUTO_BIT" -eq 0 ]; then
        C_SYSTEM_TIMEZONE_AUTO_STATE="on"
    elif [ "$C_SYSTEM_TIMEZONE_AUTO_BIT" -eq 1 ]; then
        C_SYSTEM_TIMEZONE_AUTO_STATE="off"
    fi

    printSystem

}



printEcowittInterval() {

    if [ "$C_WS_ECOWITT_INTERVAL" -eq 1 ]; then
        echo "ecowitt interval              $C_WS_ECOWITT_INTERVAL minute"
    elif [ "$C_WS_ECOWITT_INTERVAL" -gt 1 ]; then
        echo "ecowitt interval              $C_WS_ECOWITT_INTERVAL minutes"
    fi
}

parseEcowittInterval() {

    readUInt8
    C_WS_ECOWITT_INTERVAL=$VALUE_UINT8
    printEcowittInterval
}

printKeyValue() {
    printf "%-25s %s\n" "$1" "$2"
}

parseVersion() {
    readString
    C_VERSION="$VALUE_STRING"
    LIVEDATA_SYSTEM_VERSION="$VALUE_STRING"
    echo "$C_VERSION"
}

parseMAC() {
    
    readSlice 6
   
    C_MAC="$B1HEX:$B2HEX:$B3HEX:$B4HEX:$B5HEX:$B6HEX"
    echo "$C_MAC"
}

parseResult() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset -i write_result
    else
        local write_result
    fi

    readUInt8
    write_result=$VALUE_UINT8

    if [ "$write_result" -eq 0 ]; then
    :
     #   echo >&2 "$COMMAND_NAME OK"
    elif [ "$write_result" -eq 1 ]; then
        echo >&2 "$COMMAND_NAME FAIL"
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset write_result
    fi

}

isWriteCommand() {
    [ "$1" -eq $CMD_WRITE_ECOWITT_INTERVAL ] ||
        [ "$1" -eq $CMD_WRITE_RESET ] ||
        [ "$1" -eq $CMD_WRITE_CUSTOMIZED ] ||
        [ "$1" -eq $CMD_WRITE_PATH ] ||
        [ "$1" -eq $CMD_REBOOT ] ||
        [ "$1" -eq $CMD_WRITE_SSID ] ||
        [ "$1" -eq $CMD_WRITE_RAINDATA ] ||
        [ "$1" -eq $CMD_WRITE_WUNDERGROUND ] ||
        [ "$1" -eq $CMD_WRITE_WOW ] ||
        [ "$1" -eq $CMD_WRITE_WEATHERCLOUD ] ||
        [ "$1" -eq $CMD_WRITE_SENSOR_ID ] ||
        [ "$1" -eq $CMD_WRITE_CALIBRATION ] ||
        [ "$1" -eq $CMD_WRITE_SYSTEM ]
}

printBroadcast() {
   # if [ "$SHELL_SUPPORT_PRINTF" -eq 1 ]; then
   #    printf "%-25s %s\n%-25s %s\n%-25s %s\n%-25s %s\n%-25s %s\n" "broadcast mac" "$C_broadcast_mac"\
   #    "broadcast ip" "$C_broadcast_ip" "broadcast port" "$C_broadcast_port" "broadcast ssid" "$C_broadcast_ssid" "broadcast version" "$C_broadcast_version"
   # else
      echo "$C_broadcast_mac $C_broadcast_ip $C_broadcast_port $C_broadcast_ssid $C_broadcast_version"
    #fi
}

parseBroadcast() {

    readSlice 12
    #this is the station MAC/ip on local network.
    #Observation: when device is reset its annoncing hotspot accesspoint/AP with first byte of MAC changed

    C_broadcast_mac="$B1HEX:$B2HEX:$B3HEX:$B4HEX:$B5HEX:$B6HEX"
    C_broadcast_ip="$B7.$B8.$B9.$B10"
    C_broadcast_port="$(( (B11 << 8) | B12 ))"

    readString
    #https://stackoverflow.com/questions/1469849/how-to-split-one-string-into-multiple-strings-separated-by-at-least-one-space-in
    #shellcheck disable=SC2086
    set -- $VALUE_STRING # -- assign words to positional parameters
    C_broadcast_ssid=$1
    C_broadcast_version=$2

    printBroadcast
}

setWindMode()
{
    UNIT_WIND_MODE=$1
    if [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPH ]; then 
          UNIT_WIND="mph"
       
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPS ]; then
         UNIT_WIND="m/s"
    fi
    
    [ "$DEBUG" -eq 1 ] && >&2 echo Unit wind : $UNIT_WIND

}

setUVMode()
{
    UNIT_UV_MODE=$1
    if [ "$UNIT_UV_MODE" -eq $UNIT_UV_MICROWM2 ]; then
      UNIT_UV="W/m2?" # documentation for livedata protocol: ITEM_UV uW/m2?
    elif [ "$UNIT_UV_MODE" -eq $UNIT_UV_WATTM2 ]; then
      UNIT_UV="W/m2"
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo Unit UV : $UNIT_UV

}

setTemperatureMode()
#$1 - mode
{
    UNIT_TEMPERATURE_MODE=$1
    if [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_CELCIUS ]; then 
          UNIT_TEMP="℃"
       
    elif [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_FARENHEIT ]; then
         UNIT_TEMP="℉"
    fi
    
    [ "$DEBUG" -eq 1 ] && >&2 echo Unit temperature : $UNIT_TEMP

}

setPressureMode()
{
    UNIT_PRESSURE_MODE=$1
    if  [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
      UNIT_PRESSURE="hPa"
    elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
      UNIT_PRESSURE="inHg"
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo Unit pressure : $UNIT_PRESSURE


}

setRainMode()
{
    UNIT_RAIN_MODE=$1
    if  [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
      UNIT_RAIN="mm"
    elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
      UNIT_RAIN="in"
    fi

    UNIT_RAINRATE=$UNIT_RAIN"/h"

    [ "$DEBUG" -eq 1 ] && >&2 echo Unit rain rainrate : $UNIT_RAIN $UNIT_RAINRATE

    
}

printLivedataLine()
{

     if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset sgi_normal 
    else
        local sgi_normal
    fi

    if [ -n "$SGI_LIVE" ]; then
      sgi_normal=$SGI_NORMAL
    fi

    if [ "$TERM_ANSI_ESCAPE" -eq 0 ]; then
      unset SGI_LIVE SGI_NORMAL #maybe keep SGI_NORMAL?
    fi

    APPEND_FORMAT=$APPEND_FORMAT"$SGI_LIVE%-27s $3 %$5s$sgi_normal\n" #just use one printf call builtin/external -> builds up entire format and argument strings
    APPEND_ARGS=$APPEND_ARGS"\"$1\" \"$2\" \"$4\" "
    
    unset SGI_LIVE
   
    if [ -n "$LOG_LIVEDATA"  ]; then
      eval "echo \"$2\"  >$DIR_LIVEDATA/\"$6\""
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset sgi_normal
    fi

}

setSGILivedataLtGt()
#$1 - raw value, $2 low limit, 3$ high limit, $4 sgi low, $5 sgi high
{
    if [ "$1" -lt "$2" ]; then
        SGI_LIVE=$4
    elif [ "$1" -gt "$3" ]; then
        SGI_LIVE=$5
    fi
}

setSGILivedataGt()
{
 if [ "$1" -gt "$2" ]; then
     SGI_LIVE=$SGI_LIMIT_LIVEDATA
fi
       
}

printAppendBuffer()
{
    if [ "$DEBUG" -eq 1 ]; then 
        echo >&2 "APPEND_FORMAT $APPEND_FORMAT"
        echo >&2 "APPEND_ARGS $APPEND_ARGS"
    fi

    eval printf \""$APPEND_FORMAT"\" "$APPEND_ARGS"

    resetAppendBuffer

}

printLivedataBatteryLowNormal()
#$1 - battery 0/1, $2 - battery state, $3 header, $4 filename
{
    if [ -n "$1" ]; then

     if [ "$1" -eq "$BATTERY_LOW" ]; then
            SGI_LIVE=$SGI_BATTERY_LOW
     fi
     printLivedataLine "$3" "$2" "%-7s" "" 5 "$4" 
    fi
}

printLivedata() {
#prefer same filenames as the Ecowitt-protocol fieldnames
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset n 
    else
        local n 
    fi

    resetAppendBuffer

    if [ -n "$LIVEDATA_INTEMP" ]; then
        
        setSGILivedataLtGt "$LIVEDATA_INTEMP_RAW" "$LIMIT_LIVEDATA_INTEMP_LOW" "$LIMIT_LIVEDATA_INTEMP_HIGH" "$SGI_LIMIT_LIVEDATA_INTEMP_LOW" "$SGI_LIMIT_LIVEDATA_INTEMP_HIGH"
        printLivedataLine "$LIVEDATA_INTEMP_HEADER"  "$LIVEDATA_INTEMP" "%7.1f" "$UNIT_TEMP" 2 'tempin'
    fi

    if [ -n "$LIVEDATA_OUTTEMP" ]; then

        setSGILivedataLtGt "$LIVEDATA_OUTTEMP_RAW" "$LIMIT_LIVEDATA_OUTTEMP_LOW" "$LIMIT_LIVEDATA_OUTTEMP_HIGH" "$SGI_LIMIT_LIVEDATA_OUTTEMP_LOW" "$SGI_LIMIT_LIVEDATA_OUTTEMP_HIGH"
        printLivedataLine "$LIVEDATA_OUTTEMP_HEADER" "$LIVEDATA_OUTTEMP" "%7.1f" "$UNIT_TEMP" 2 'tempout'
    fi
    
    if [ -n "$LIVEDATA_WINDCHILL" ]; then

        setSGILivedataLtGt "$LIVEDATA_WINDCHILL_RAW" "$LIMIT_LIVEDATA_OUTTEMP_LOW" "$LIMIT_LIVEDATA_OUTTEMP_HIGH" "$SGI_LIMIT_LIVEDATA_OUTTEMP_LOW" "$SGI_LIMIT_LIVEDATA_OUTTEMP_HIGH"
        printLivedataLine "$LIVEDATA_WINDCHILL_HEADER" "$LIVEDATA_WINDCHILL" "%7.1f" "$UNIT_TEMP" 2 'windchill'
    fi

    if [ -n "$LIVEDATA_DEWPOINT" ]; then
        printLivedataLine "$LIVEDATA_DEWPOINT_HEADER" "$LIVEDATA_DEWPOINT" "%7.1f" "$UNIT_TEMP" 2 'dewpoint'
    fi

    [ -n "$LIVEDATA_INHUMI" ] && printLivedataLine  "$LIVEDATA_INHUMI_HEADER" "$LIVEDATA_INHUMI"  "%5u" "%" 4 'humidityin'
    [ -n "$LIVEDATA_OUTHUMI" ] && printLivedataLine "$LIVEDATA_OUTHUMI_HEADER" "$LIVEDATA_OUTHUMI" "%5u" "%" 4 'humidity'

    if [ -n "$LIVEDATA_RELBARO" ]; then

        if [ "$LIVEDATA_RELBARO_RAW" -lt "$LIMIT_LIVEDATA_RELBARO_LOW" ]; then
            SGI_LIVE=$SGI_LIMIT_LIVEDATA
        fi
        
        if [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
            printLivedataLine "$LIVEDATA_RELBARO_HEADER" "$LIVEDATA_RELBARO" "%7.1f" "$UNIT_PRESSURE" 4 'barorel'
            [ -n "$LIVEDATA_ABSBARO" ] && printLivedataLine "$LIVEDATA_ABSBARO_HEADER" "$LIVEDATA_ABSBARO" "%7.1f" "$UNIT_PRESSURE" 4 'baroabs'
        elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
            printLivedataLine "$LIVEDATA_RELBARO_HEADER" "$LIVEDATA_RELBARO" "%8.2f" "$UNIT_PRESSURE" 4 'barorel'
            [ -n "$LIVEDATA_ABSBARO" ] && printLivedataLine "$LIVEDATA_ABSBARO_HEADER" "$LIVEDATA_ABSBARO" "%8.2f" "$UNIT_PRESSURE" 4 'baroabs'
        fi
    fi

    [ -n "$LIVEDATA_WINDDIRECTION" ] && printLivedataLine  "$LIVEDATA_WINDDIRECTION_HEADER" "$LIVEDATA_WINDDIRECTION" "%5u" "" 6 'winddir'
    [ -n "$LIVEDATA_WINDDIRECTION_COMPASS" ] && printLivedataLine "$LIVEDATA_WINDDIRECTION_COMPASS_HEADER" "$LIVEDATA_WINDDIRECTION_COMPASS" "%5s" "" 5 'winddir_compass'
    [ -n "$LIVEDATA_WINDSPEED" ] && {
        setSGILivedataGt "$LIVEDATA_WINDSPEED_RAW"  "$LIMIT_LIVEDATA_WIND" 
        printLivedataLine "$LIVEDATA_WINDSPEED_HEADER" "$LIVEDATA_WINDSPEED" "%7.1f" "$UNIT_WIND" 4 'windspeed' 
    }
    [ -n "$LIVEDATA_WINDGUSTSPEED" ] && 
    {
        setSGILivedataGt "$LIVEDATA_WINDGUSTSPEED_RAW"  "$LIMIT_LIVEDATA_WIND" 
        printLivedataLine "$LIVEDATA_WINDGUSTSPEED_HEADER" "$LIVEDATA_WINDGUSTSPEED" "%7.1f" "$UNIT_WIND" 4 'windgust' 
    }
    [ -n "$LIVEDATA_WINDDAILYMAX" ] && {
        setSGILivedataGt "$LIVEDATA_WINDDAILYMAX_RAW" "$LIMIT_LIVEDATA_WIND" 
        printLivedataLine "$LIVEDATA_WINDDAILYMAX_HEADER" "$LIVEDATA_WINDDAILYMAX" "%7.1f" "$UNIT_WIND" 4 'winddailymax' 
    }
    [ -n "$LIVEDATA_LIGHT" ] && printLivedataLine "$LIVEDATA_LIGHT_HEADER" "$LIVEDATA_LIGHT" "%7.1f" "$UNIT_LIGHT" 4 'light'
    [ -n "$LIVEDATA_UV" ] && printLivedataLine "$LIVEDATA_UV_HEADER" "$LIVEDATA_UV" "%7.1f" "$UNIT_UV" 5 'uv'
    [ -n "$LIVEDATA_UVI" ] && printLivedataLine "$LIVEDATA_UVI_HEADER" "$LIVEDATA_UVI" "%5u" "" 4 'uvi'

    [ -n "$LIVEDATA_RAINRATE" ] && {
        setSGILivedataGt "$LIVEDATA_RAINRATE_RAW" "$LIMIT_LIVEDATA_RAINRATE"

        if [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
          printLivedataLine "$LIVEDATA_RAINRATE_HEADER" "$LIVEDATA_RAINRATE" "%7.1f" "$UNIT_RAINRATE" 5 'rainrate'
        elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
          printLivedataLine "$LIVEDATA_RAINRATE_HEADER" "$LIVEDATA_RAINRATE" "%8.2f" "$UNIT_RAINRATE" 4 'rainrate'
        fi
    }

     #available in Ecowitt http request
     [ -n "$LIVEDATA_RAINHOUR" ] && {
         setSGILivedataGt "$LIVEDATA_RAINHOUR_RAW" "$LIMIT_LIVEDATA_RAINHOUR"
        
        if [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
            printLivedataLine "$LIVEDATA_RAINHOUR_HEADER" "$LIVEDATA_RAINHOUR" "%7.1f" "$UNIT_RAIN" 3 'rainhour'
        elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
            printLivedataLine "$LIVEDATA_RAINHOUR_HEADER" "$LIVEDATA_RAINHOUR" "%8.2f" "$UNIT_RAIN" 2 'rainhour'
        fi
    }

     [ -n "$LIVEDATA_RAINDAY" ] && {
        setSGILivedataGt  "$LIVEDATA_RAINDAY_RAW"  "$LIMIT_LIVEDATA_RAINDAY" 

        if [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
           printLivedataLine "$LIVEDATA_RAINDAY_HEADER" "$LIVEDATA_RAINDAY" "%7.1f" "$UNIT_RAIN" 3 'rainday'
        elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
           printLivedataLine "$LIVEDATA_RAINDAY_HEADER" "$LIVEDATA_RAINDAY" "%8.2f" "$UNIT_RAIN" 2 'rainday'
        fi
    }

    [ -n "$LIVEDATA_RAINEVENT" ] && {
        
        setSGILivedataGt "$LIVEDATA_RAINEVENT_RAW" "$LIMIT_LIVEDATA_RAINEVENT" 
        printLivedataLine "$LIVEDATA_RAINEVENT_HEADER" "$LIVEDATA_RAINEVENT" "%7.1f" "$UNIT_RAIN" 3 'rainevent'
    }

    [ -n "$LIVEDATA_RAINWEEK" ] && printLivedataLine "$LIVEDATA_RAINWEEK_HEADER" "$LIVEDATA_RAINWEEK" "%7.1f" "$UNIT_RAIN" 3 'rainweek'
    [ -n "$LIVEDATA_RAINMONTH" ] && printLivedataLine "$LIVEDATA_RAINMONTH_HEADER" "$LIVEDATA_RAINMONTH" "%7.1f" "$UNIT_RAIN" 3 'rainmonth'
    [ -n "$LIVEDATA_RAINYEAR" ] && printLivedataLine "$LIVEDATA_RAINYEAR_HEADER" "$LIVEDATA_RAINYEAR" "%7.1f" "$UNIT_RAIN" 3 'rainyear'

    n=1
    while [ "$n" -le "$WH51_SOILMOISTURE_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_SOILMOISTURE$n" ] && printLivedataLine  \"\$LIVEDATA_SOILMOISTURE_HEADER$n\" \"\$LIVEDATA_SOILMOISTURE$n\" \"%5u\" \"%\" 4 \"soilmoisture$n\""
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH34_SOILTEMP_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_SOILTEMP$n" ] && printLivedataLine \"Soil temperature CH $n\" \"\$LIVEDATA_SOILTEMP$n\" \"%7.1f\" \"$UNIT_TEMP\" 2 \"soiltemperature$n\" "
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH31_TEMP_MAXCH" ]; do
    #shellcheck disable=SC2153
    {
        eval "[ -n ''"\$LIVEDATA_TEMP$n" ] && printLivedataLine \"\$LIVEDATA_TEMP_HEADER$n\" \"\$LIVEDATA_TEMP$n\" \"%7.1f\"  \"\$UNIT_TEMP\" 2 \"temp$n\""
     }
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH31_TEMP_MAXCH" ]; do
    #shellcheck disable=SC2153
    {
        eval "[ -n ''"\$LIVEDATA_HUMI$n" ] && printLivedataLine \"\$LIVEDATA_HUMIDITY_HEADER$n\" \"\$LIVEDATA_HUMI$n\" \"%5u\" \"%\" 4 \"humidity$n\""
    }
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH31_TEMP_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_TF_USR$n" ] && printLivedataLine \"Temperature USR $n\" \"\$LIVEDATA_TF_USR$n\" \"%7.1f\" \"\$UNIT_TEMP\" 2 \"temp_usr$n\""
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH55_LEAK_MAXCH" ]; do
      #TEST eval LIVEDATA_LEAK_CH$n=1
        LIVEDATA_LEAK_YESNO=$LIVEDATA_LEAK_NO
        #shellcheck disable=SC2034
        eval "[ -n ''"\$LIVEDATA_LEAK_CH$n" ] && [ \"\$LIVEDATA_LEAK_CH$n\" -ne 0 ] && SGI_LIVE=\"$SGI_LEAK\"" && LIVEDATA_LEAK_YESNO=$LIVEDATA_LEAK_YES
        eval "[ -n ''"\$LIVEDATA_LEAK_CH$n" ] && printLivedataLine \"\$LIVEDATA_LEAK_HEADER$n\" \"\$LIVEDATA_LEAK_YESNO\" \"%5s\" \"\" 4 \"leak_ch$n\""
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH43_PM25_MAXCH" ]; do
        #shellcheck disable=SC2153
        eval "[ -n ''"\$LIVEDATA_PM25_CH$n" ] && printLivedataLine \"\$LIVEDATA_PM25_HEADER$n\" \"\$LIVEDATA_PM25_CH$n\" \"%7.1f\" \"\$UNIT_PM25\" 7 \"pm25_ch$n\""
        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH43_PM25_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_PM25_24HAVG$n" ] && printLivedataLine \"\$LIVEDATA_PM25_24HAVG_HEADER$n\" \"\$LIVEDATA_PM25_24HAVG$n\" \"%7.1f\" \"\$UNIT_PM25\" 7 \"pm25_avg_24h_ch$n\""
        n=$((n + 1))
    done


    [ -n "$LIVEDATA_CO2_TEMPF" ] && printLivedataLine "Temperature" "$LIVEDATA_CO2_TEMPF" "%7.1f" "$UNIT_TEMP" 2 "co2-temperaturef"
    [ -n "$LIVEDATA_CO2_HUMI" ] && printLivedataLine "Humidity" "$LIVEDATA_CO2_HUMI" "%5u" "%" 4 "co2-humidity"
    [ -n "$LIVEDATA_CO2_PM10" ] && printLivedataLine "PM10" "$LIVEDATA_CO2_PM10" "%7.1f" "$UNIT_PM25" 7 "co2-pm10"
    [ -n "$LIVEDATA_CO2_PM10_24HAVG" ] && printLivedataLine "PM10 24h avg." "$LIVEDATA_CO2_PM10_24HAVG" "%7.1f" "$UNIT_PM25" 7 "co2-pm_24havg"
    [ -n "$LIVEDATA_CO2_PM25" ] && printLivedataLine "PM25" "$LIVEDATA_CO2_PM25" "%7.1f" "$UNIT_PM25" 7 "co2-pm25"
    [ -n "$LIVEDATA_CO2_PM25_24HAVG" ] && printLivedataLine "PM25 24h avg." "$LIVEDATA_CO2_PM25_24HAVG" "%7.1f" "$UNIT_PM25" 7 "co2-pm25_24havg"
    [ -n "$LIVEDATA_CO2_CO2" ] && printLivedataLine "CO2" "$LIVEDATA_CO2_CO2" "%5u" "$UNIT_CO2" 5 "co2-co2"
    [ -n "$LIVEDATA_CO2_CO2_24HAVG" ] && printLivedataLine "CO2 24h avg." "$LIVEDATA_CO2_CO2_24HAVG" "%7.1f" "$UNIT_CO2" 5 "co2-co2_24havg"
    [ -n "$LIVEDATA_CO2_CO2_BATTERYLEVEL" ] && printLivedataLine "CO2 batterylevel" "$LIVEDATA_CO2_CO2_BATTERYLEVEL" "%5u" "" 5 "co2-batterylevel"

   
    [ -n "$LIVEDATA_LIGHTNING_DISTANCE" ] && printLivedataLine "Lightning distance" "$LIVEDATA_LIGHTNING_DISTANCE" "%5u" "km" 5 "lightning_distance"
    if [ -n "$LIVEDATA_LIGHTNING_TIME" ]; then
      printLivedataLine "Lightning time utc" "$LIVEDATA_LIGHTNING_TIME_UTC" "%7s" "" 5 "ligntning_time_utc"
    fi
    [ -n "$LIVEDATA_LIGHTNING_POWER" ] && printLivedataLine "Lightning power" "$LIVEDATA_LIGHTNING_POWER"  "%7s" "" 5 "lightning_power"

    n=1
    while [ "$n" -le "$WH35_LEAFWETNESS_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_LEAF_WETNESS_CH$n" ] && printLivedataLine \"Leaf wetness CH $n\" \"\$LIVEDATA_LEAF_WETNESS_CH$n\" \"%5u\" \"%\" 5 \"leaf_wetness_ch$n\""
        n=$((n + 1))
    done

    #battery

    printLivedataBatteryLowNormal "$LIVEDATA_WH65_BATTERY" "$LIVEDATA_WH65_BATTERY_STATE" "WH65 Wind/Temp./UV battery" "wh65_battery"
    printLivedataBatteryLowNormal "$LIVEDATA_WH68_BATTERY" "$LIVEDATA_WH68_BATTERY_STATE" "WH68 Wind/Temp./UV battery" "wh68_battery"
    printLivedataBatteryLowNormal "$LIVEDATA_WH80_BATTERY" "$LIVEDATA_WH80_BATTERY_STATE" "WH80 Wind/Temp./UV battery" "wh80_battery"
    printLivedataBatteryLowNormal "$LIVEDATA_WH32_TEMPERATURE_BATTERY" "$LIVEDATA_WH32_TEMPERATURE_BATTERY_STATE" "Temperature out battery" "wh32_temperature_battery"
    printLivedataBatteryLowNormal "$LIVEDATA_WH40_RAINFALL_BATTERY" "$LIVEDATA_WH40_RAINFALL_BATTERY_STATE" "Rainfall battery" "wh40_rainfall_battery"
    printLivedataBatteryLowNormal "$LIVEDATA_WH57_LIGHTNING_BATTERY" "$LIVEDATA_WH57_LIGHTNING_BATTERY_STATE" "Lightning battery" "wh57_lightning_battery"
    
    if [ -n "$LIVEDATA_WH45_CO2_BATTERY" ]; then 
      printLivedataLine  "CO2 PM25 PM10 battery" "$LIVEDATA_WH45_CO2_BATTERY_STATE" "%-7s" "" 2 "wh45_co2_battery"
    fi

    n=1
    while [ "$n" -le "$WH31_TEMP_MAXCH" ]; do
    
        eval "[ -n ''"\$LIVEDATA_TEMP${n}_BATTERY_STATE" ] && [ "\$LIVEDATA_TEMP${n}_BATTERY" -eq $BATTERY_LOW ] && SGI_LIVE=\"$SGI_BATTERY_LOW\""
        eval "[ -n ''"\$LIVEDATA_TEMP${n}_BATTERY_STATE" ] && printLivedataLine \"Temperature CH $n battery\" \"\$LIVEDATA_TEMP${n}_BATTERY_STATE\" \"%-7s\"  \"\" 2 \"temp${n}_battery_state\""
        n=$(( n + 1 ))
    done

    n=1
    while [ "$n" -le "$WH43_PM25_MAXCH" ]; do
        #shellcheck disable=SC2153
        eval  "[ -n ''"\$LIVEDATA_PM25_CH${n}_BATTERY_STATE" ] && [ "\$LIVEDATA_PM25_CH${n}_BATTERY" -le $BATTERY_LEVEL_LOW ] && SGI_LIVE=\"$SGI_BATTERY_LOW\""
        eval "[ -n ''"\$LIVEDATA_PM25_CH${n}_BATTERY_STATE" ] && printLivedataLine \"PM 2.5 CH $n battery\" \"\$LIVEDATA_PM25_CH${n}_BATTERY_STATE\" \"%-7s\" \"\" 7 \"pm25_ch${n}_battery_state\""
        n=$((n + 1))
    done

     n=1
    while [ "$n" -le "$WH51_SOILMOISTURE_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY" ] && [ "\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY_RAW" -le $BATTERY_VOLTAGE_LOW ] && SGI_LIVE=\"$SGI_BATTERY_LOW\""
       # eval "[ -n ''"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY" ] && printLivedataLine  \"Soil moisture CH $n battery\" \"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY\" \"%6.1f\" \"V\" 2 \"soilmoisture${n}_battery\""
        eval "[ -n ''"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY" ] && printLivedataLine  \"Soil moisture CH $n battery\" \"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY_STATE\" \"%-7s\" \"\" 2 \"soilmoisture${n}_battery\""

        n=$((n + 1))
    done

     n=1
    while [ "$n" -le "$WH34_SOILTEMP_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_SOILTEMP_CH${n}_BATTERY" ] && [ "\$LIVEDATA_SOILTEMP_CH${n}_BATTERY_RAW" -le $BATTERY_VOLTAGE_LOW ] && SGI_LIVE=\"$SGI_BATTERY_LOW\""
       # eval "[ -n ''"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY" ] && printLivedataLine  \"Soil moisture CH $n battery\" \"\$LIVEDATA_SOILMOISTURE_CH${n}_BATTERY\" \"%6.1f\" \"V\" 2 \"soiltemperature${n}_battery\""
        eval "[ -n ''"\$LIVEDATA_SOILTEMP_CH${n}_BATTERY" ] && printLivedataLine  \"Soil temp. CH $n battery\" \"\$LIVEDATA_SOILTEMP_CH${n}_BATTERY_STATE\" \"%-7s\" \"\" 2 \"soiltemperature${n}_battery\""

        n=$((n + 1))
    done

    n=1
    while [ "$n" -le "$WH55_LEAK_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_LEAK_CH${n}_BATTERY" ] && [ "\$LIVEDATA_LEAK_CH${n}_BATTERY" -le $BATTERY_LEVEL_LOW ] && SGI_LIVE=\"$SGI_BATTERY_LOW\""
        eval "[ -n ''"\$LIVEDATA_LEAK_CH${n}_BATTERY" ] && printLivedataLine \"Leak CH $n battery\" \"\$LIVEDATA_LEAK_CH${n}_BATTERY_STATE\" \"%-7s\" \"\" 4 \"leak_ch${n}_battery_state\""
        n=$((n + 1))
    done

     n=1
    while [ "$n" -le "$WH35_LEAFWETNESS_MAXCH" ]; do
        eval "[ -n ''"\$LIVEDATA_LEAFWETNESS_CH${n}_BATTERY" ] && [ "\$LIVEDATA_LEAFWETNESS_CH${n}_BATTERY" -le $BATTERY_LEVEL_LOW ] && SGI_LIVE=\"$SGI_BATTERY_LOW\""
        eval "[ -n ''"\$LIVEDATA_LEAFWETNESS_CH${n}_BATTERY" ] && printLivedataLine \"Leaf wetness CH $n battery\" \"\$LIVEDATA_LEAFWETNESS_CH${n}_BATTERY_STATE\" \"%-7s\" \"\" 4 \"leafwetness_ch${n}_battery_state\""
        n=$((n + 1))
    done

   
    #system

    [ -n "$LIVEDATA_SYSTEM_VERSION" ] && printLivedataLine "$LIVEDATA_SYSTEM_VERSION_HEADER" "$LIVEDATA_SYSTEM_VERSION" "%-7s" "" 5 "system_version"
    [ -n "$LIVEDATA_SYSTEM_UTC" ] && printLivedataLine "$LIVEDATA_SYSTEM_UTC_HEADER" "$LIVEDATA_SYSTEM_UTC" "%-20s" "" 5 "system_utc"
    [ -n "$LIVEDATA_SYSTEM_FREQUENCY" ] && printLivedataLine "$LIVEDATA_SYSTEM_FREQUENCY_HEADER" "$LIVEDATA_SYSTEM_FREQUENCY" "%-7s" "" 5 "system_frequency"


    printAppendBuffer

    #unset local variables for ksh -> made global by using () function syntax without function keyword
    #https://www.unix.com/shell-programming-and-scripting/137435-ksh-different-syntax-function.html
    #man ksh93: ksh93 uses static scoping (one global scope, one local scope per function) and allows local variables only on Korn style functions
    if [ -n "$KSH_VERSION" ]; then
     unset n
    fi
}

convertTemperatureLivedata()
{
    if [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_CELCIUS ]; then
        convertScale10ToFloat "$1"
    elif [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_FARENHEIT ]; then
        convertCelciusScale10ToFarenheitScale10 "$1"
        convertScale10ToFloat "$VALUE_FARENHEIT_SCALE10"
    fi
}

convertPressureLivedata()
{
   if [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
        convertScale10ToFloat "$1"
    elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
        convertHpaScale10ToInHgScale10 "$1"
        convertScale10ToFloat "$VALUE_INHG_SCALE10"
    fi
}

parseLivedata() { # ff ff 27 00 53 01 00 e1 06 25 08 27 b3 09 27 c2 02 00 05 07 5d 0a 01 59 0b 00 00 0c 00 00 15 00 00 93 bc 16 00 20 17 00 2c 12 1a 00 87 22 32 1b 00 b0 23 27 1c 00 dd 24 31 58 00 19 00 47 0e 00 00 10 00 08 11 00 42 12 00 00 02 9a 13 00 00 0f 8b 0d 00 42 63
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
            typeset ldf channel checksum
    else
        local ldf channel checksum
    fi

    while [ "${#OD_BUFFER}" -gt 4 ]; do

        [ "$DEBUG" -eq 1 ] && echo >&2 Unparsed "$OD_BUFFER" length "${#OD_BUFFER}"

        readUInt8
        ldf=$VALUE_UINT8

        [ "$DEBUG" -eq 1 ] && echo >&2 Parsing livedata field "$(printf "%02x" "$ldf")"

        if [ "$ldf" -eq $LDF_INTEMP ]; then

            readInt16BE
            LIVEDATA_INTEMP_RAW=$VALUE_INT16BE
            convertTemperatureLivedata "$VALUE_INT16BE"
            LIVEDATA_INTEMP=$VALUE_SCALE10_FLOAT 

        elif [ "$ldf" -eq $LDF_INHUMI ]; then

            readUInt8
            LIVEDATA_INHUMI=$VALUE_UINT8

        elif [ "$ldf" -eq $LDF_ABSBARO ]; then

            readUInt16BE
            #shellcheck disable=SC2034
            LIVEDATA_ABSBARO_RAW=$VALUE_UINT16BE #may use for ansi escape coloring beyond limits
            convertPressureLivedata "$VALUE_UINT16BE"
            LIVEDATA_ABSBARO=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_RELBARO ]; then

            readUInt16BE
            LIVEDATA_RELBARO_RAW=$VALUE_UINT16BE
            convertPressureLivedata "$VALUE_UINT16BE"
            LIVEDATA_RELBARO=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_OUTTEMP ]; then

            readInt16BE
            LIVEDATA_OUTTEMP_RAW=$VALUE_INT16BE
            convertTemperatureLivedata "$VALUE_INT16BE" 
            LIVEDATA_OUTTEMP=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_OUTHUMI ]; then

            readUInt8
            LIVEDATA_OUTHUMI=$VALUE_UINT8

        elif [ "$ldf" -eq $LDF_WINDDIRECTION ]; then

            readUInt16BE
            LIVEDATA_WINDDIRECTION=$VALUE_UINT16BE
            convertWindDirectionToCompassDirection "$LIVEDATA_WINDDIRECTION"
            LIVEDATA_WINDDIRECTION_COMPASS=$VALUE_COMPASS_DIRECTION

        elif [ "$ldf" -eq $LDF_WINDSPEED ]; then

            readUInt16BE
            LIVEDATA_WINDSPEED_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_WINDSPEED=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_WINDGUSTSPPED ]; then

            readUInt16BE
            LIVEDATA_WINDGUSTSPEED_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_WINDGUSTSPEED=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_DAYLWINDMAX ]; then

            readUInt16BE
            LIVEDATA_WINDDAILYMAX_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_WINDDAILYMAX=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_LIGHT ]; then

            readUInt32BE
            LIVEDATA_LIGHT_RAW=$VALUE_UINT32BE
            convertScale10ToFloat "$VALUE_UINT32BE"
            LIVEDATA_LIGHT=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_UV ]; then

            readUInt16BE
            [ "$DEBUG" -eq 1 ] && echo >&2 "RAW UV value $VALUE_UINT16BE, converting lux $LIVEDATA_LIGHT to W/m2 instead "
            #setUVMode $UNIT_UV_MICROWM2
            #is it µW? is it scale 10 ?
            #lux 976 -> solar radiation raw value 11 -> ecowitt protcol: 7.7 W/m2
            #https://help.ambientweather.net/help/why-is-the-lux-to-w-m-2-conversion-factor-126-7/
            setUVMode $UNIT_UV_WATTM2
            VALUE_UINT16BE=$(( LIVEDATA_LIGHT_RAW*1075/136000 ))
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_UV=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_UVI ]; then

            readUInt8
            LIVEDATA_UVI=$VALUE_UINT8

        elif [ "$ldf" -eq $LDF_SOILMOISTURE1 ] || [ "$ldf" -eq $LDF_SOILMOISTURE2 ] ||
            [ "$ldf" -eq $LDF_SOILMOISTURE3 ] || [ "$ldf" -eq $LDF_SOILMOISTURE4 ] ||
            [ "$ldf" -eq $LDF_SOILMOISTURE5 ] || [ "$ldf" -eq $LDF_SOILMOISTURE6 ] ||
            [ "$ldf" -eq $LDF_SOILMOISTURE7 ] || [ "$ldf" -eq $LDF_SOILMOISTURE8 ]; then #is 16 channels supported?

            readUInt8
            channel=$((((ldf - LDF_SOILMOISTURE1) / 2) + 1))
            eval "LIVEDATA_SOILMOISTURE$channel=$VALUE_UINT8"

        elif [ "$ldf" -eq $LDF_SOILTEMP1 ] || [ "$ldf" -eq $LDF_SOILTEMP2 ] ||
            [ "$ldf" -eq $LDF_SOILTEMP3 ] || [ "$ldf" -eq $LDF_SOILTEMP4 ] ||
            [ "$ldf" -eq $LDF_SOILTEMP5 ] || [ "$ldf" -eq $LDF_SOILTEMP6 ] ||
            [ "$ldf" -eq $LDF_SOILTEMP7 ] || [ "$ldf" -eq $LDF_SOILTEMP8 ]; then

            readUInt8
            channel=$((((ldf - LDF_SOILTEMP1) / 2) + 1))
            eval "LIVEDATA_SOILTEMPE$channel=$VALUE_UINT8"

        elif [ "$ldf" -ge $LDF_TEMP1 ] && [ "$ldf" -le $LDF_TEMP8 ]; then

            readInt16BE
            convertTemperatureLivedata "$VALUE_INT16BE"

            channel=$((ldf - LDF_TEMP1 + 1))
            eval "LIVEDATA_TEMP$channel=$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -ge $LDF_HUMI1 ] && [ "$ldf" -le $LDF_HUMI8 ]; then

            readUInt8

            channel=$((ldf - LDF_HUMI1 + 1))
            eval "LIVEDATA_HUMI$channel=$VALUE_UINT8"

        elif [ "$ldf" -eq $LDF_RAINMONTH ]; then

            readUInt32BE
            convertScale10ToFloat "$VALUE_UINT32BE"
            LIVEDATA_RAINMONTH=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_RAINYEAR ]; then

            readUInt32BE
            convertScale10ToFloat "$VALUE_UINT32BE"
            LIVEDATA_RAINYEAR=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_RAINWEEK ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_RAINWEEK=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_RAINDAY ]; then

            readUInt16BE
            LIVEDATA_RAINDAY_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_RAINDAY=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_RAINEVENT ]; then

            readUInt16BE
            LIVEDATA_RAINEVENT_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_RAINEVENT=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -eq $LDF_RAINRATE ]; then

            readUInt16BE
            LIVEDATA_RAINRATE_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_RAINRATE=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -ge $LDF_LEAK_CH1 ] && [ "$ldf" -le $LDF_LEAK_CH4 ]; then

            readUInt8

            channel=$((ldf - LDF_LEAK_CH1 + 1))
            eval "LIVEDATA_LEAK_CH$channel=$VALUE_UINT8"

        elif [ "$ldf" -eq $LDF_PM25_CH1 ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_PM25_CH1=$VALUE_SCALE10_FLOAT

        elif [ "$ldf" -ge $LDF_PM25_CH2 ] && [ "$ldf" -le $LDF_PM25_CH4 ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"

            channel=$((ldf - LDF_PM25_CH1 + 1))
            eval "LIVEDATA_PM25_CH$channel=$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -ge $LDF_PM25_24HAVG1 ] && [ "$ldf" -le $LDF_PM25_24HAVG4 ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"

            channel=$((ldf - LDF_PM25_24HAVG1 + 1))
            eval "LIVEDATA_PM25_24HAVG$channel=$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_SENSOR_CO2 ]; then

            #/* ------------------Ecowitt-----------------
            # 1 tf_co2        short C x10
            # 2 humi_co2      unsigned char %
            # 3 pm10_co2      unsigned short ug/m3 x10
            # 4 pm10_24h_co2  unsigned short ug/m3 x10
            # 5 pm25_co2      unsigned short ug/m3 x10
            # 6 pm25_24h_co2  unsigned short ug/m3 x10
            # 7 co2           unsigned short ppm
            # 8 co2_24h       unsigned short ppm
            # 9 co2_batt      u8 (0~5)

            readInt16BE
            convertScale10ToFloat "$VALUE_INT16BE"
            LIVEDATA_CO2_TEMPF=$VALUE_SCALE10_FLOAT

            readUInt8
            LIVEDATA_CO2_HUMI=$VALUE_UINT8

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_CO2_PM10=$VALUE_SCALE10_FLOAT

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_CO2_PM10_24HAVG=$VALUE_SCALE10_FLOAT

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_CO2_PM25=$VALUE_SCALE10_FLOAT

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            LIVEDATA_CO2_PM25_24HAVG=$VALUE_SCALE10_FLOAT

            readUInt16BE
            LIVEDATA_CO2_CO2=$VALUE_UINT16BE

            readUInt16BE
            LIVEDATA_CO2_CO2_24HAVG=$VALUE_UINT16BE

            readUInt8
            LIVEDATA_CO2_CO2_BATTERYLEVEL=$VALUE_UINT8

        elif [ "$ldf" -ge $LDF_TF_USR1 ] && [ "$ldf" -le $LDF_TF_USR8 ]; then

            readInt16BE
            convertTemperatureLivedata "$VALUE_INT16BE"

            channel=$((ldf - LDF_TF_USR1 + 1))
            eval "LIVEDATA_TF_USR$channel=$VALUE_SCALE10_FLOAT"

            readUInt8
            eval "LIVEDATA_TF_USR${channel}_BATTERY=$VALUE_UINT8" #todo : scaling

        elif [ "$ldf" -ge $LDF_LIGHTNING ]; then

            readUInt8
            LIVEDATA_LIGHTNING_DISTANCE=$VALUE_UINT8 # 1-40km

        elif [ "$ldf" -ge $LDF_LIGHTNING_TIME ]; then

            readUInt32BE
            LIVEDATA_LIGHTNING_TIME=$VALUE_UINT32BE
            LIVEDATA_LIGHTNING_TIME_UTC=$(date -u -d @"$LIVEDATA_LIGHTNING_TIME" +'%F %T') #add field


        elif [ "$ldf" -ge $LDF_LIGHTNING_POWER ]; then

            readUInt32BE
            LIVEDATA_LIGHTNING_POWER=$VALUE_UINT32BE

        elif [ "$ldf" -ge $LDF_LEAF_WETNESS_CH1 ] && [ "$ldf" -le $LDF_LEAF_WETNESS_CH8 ]; then

            readUInt8
            channel=$((ldf - LDF_LEAF_WETNESS_CH1 + 1))

            eval "LIVEDATA_LEAF_WETNESS_CH$channel=$VALUE_UINT8"

        else
            echo >&2 "ERROR Unable to parse livedata field $(printf "%x" $ldf)"
        fi

    done

    if [ ${#OD_BUFFER} -eq 2 ] && [ "$DEBUG" -eq 1 ]; then
        readUInt8
        checksum=$VALUE_UINT8
        echo >&2 checksum "$(printf "%02x" $checksum)"
    fi

    printLivedata

    if [ -n "$KSH_VERSION" ]; then
        unset ldf channel checksum
    fi

}

printRaindata() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
            typeset rr rd rw rm ry
    else
        local rr rd rw rm ry
    fi

    convertScale10ToFloat "$C_RAINRATE"
    rr=$VALUE_SCALE10_FLOAT
    convertScale10ToFloat "$C_RAINDAILY"
    rd=$VALUE_SCALE10_FLOAT
    convertScale10ToFloat "$C_RAINWEEK"
    rw=$VALUE_SCALE10_FLOAT
    convertScale10ToFloat "$C_RAINMONTH"
    rm=$VALUE_SCALE10_FLOAT
    convertScale10ToFloat "$C_RAINYEAR"
    ry=$VALUE_SCALE10_FLOAT

    
    echo "rain rate  $rr $UNIT_RAINRATE
rain day   $rd $UNIT_RAIN
rain week  $rw $UNIT_RAIN
rain month $rm $UNIT_RAIN
rain year  $ry $UNIT_RAIN"
   
    if [ -n "$KSH_VERSION" ]; then
            unset rr rd rw rm ry
    fi
}

parseRaindata() {

    readUInt32BE
    C_RAINRATE=$VALUE_UINT32BE

    readUInt32BE
    C_RAINDAILY=$VALUE_UINT32BE

    readUInt32BE
    C_RAINWEEK=$VALUE_UINT32BE

    readUInt32BE
    C_RAINMONTH=$VALUE_UINT32BE

    readUInt32BE
    C_RAINYEAR=$VALUE_UINT32BE

    printRaindata
}

printCalibration() {
    #if [ "$SHELL_SUPPORT_PRINTF" -eq 1 ]; then
    #   printf "%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n"\
    #    "calibration in temperature offset"           "$C_CALIBRATION_INTEMPOFFSET"     "$UNIT_TEMP"\
    #    "calibration in humidity offset"              "$C_CALIBRATION_INHUMIDITYOFFSET"   "%"\
    #    "calibration absolute pressure offset"        "$C_CALIBRATION_ABSOFFSET"        "$UNIT_PRESSURE"\
    #    "calibration relative pressure offset"        "$C_CALIBRATION_RELOFFSET"        "$UNIT_PRESSURE"\
    #    "calibration out temperature offset"          "$C_CALIBRATION_OUTTEMPOFFSET"    "$UNIT_TEMP"\
    ##    "calibration out humidity offset"             "$C_CALIBRATION_OUTHUMIDITYOFFSET" "%"\
    #    "calibration wind direction offset"           "$C_CALIBRATION_WINDDIROFFSET" ""
    #else
        echo "calibration in temperature offset           $C_CALIBRATION_INTEMPOFFSET $UNIT_TEMP
calibration in humidity offset              $C_CALIBRATION_INHUMIDITYOFFSET   %
calibration absolute pressure offset        $C_CALIBRATION_ABSOFFSET $UNIT_PRESSURE
calibration relative pressure offset        $C_CALIBRATION_RELOFFSET $UNIT_PRESSURE
calibration out temperature offset          $C_CALIBRATION_OUTTEMPOFFSET $UNIT_TEMP
calibration out humidity offset             $C_CALIBRATION_OUTHUMIDITYOFFSET   %
calibration wind direction offset           $C_CALIBRATION_WINDDIROFFSET" 
   # fi

}

parseCalibration() {

    readInt16BE
    convertScale10ToFloat "$VALUE_INT16BE"
    C_CALIBRATION_INTEMPOFFSET="$VALUE_SCALE10_FLOAT"

    readInt8
    C_CALIBRATION_INHUMIDITYOFFSET="$VALUE_INT8"

    readInt32BE
    convertScale10ToFloat "$VALUE_INT32BE"
    C_CALIBRATION_ABSOFFSET="$VALUE_SCALE10_FLOAT"

    readInt32BE
    convertScale10ToFloat "$VALUE_INT32BE"
    C_CALIBRATION_RELOFFSET="$VALUE_SCALE10_FLOAT"

    readInt16BE
    convertScale10ToFloat "$VALUE_INT16BE"
    C_CALIBRATION_OUTTEMPOFFSET="$VALUE_SCALE10_FLOAT"

    readInt8
    C_CALIBRATION_OUTHUMIDITYOFFSET="$VALUE_INT8"

    readInt16BE
    C_CALIBRATION_WINDDIROFFSET="$VALUE_INT16BE"

    printCalibration
}

printPath() {
    echo "path ecowitt      $C_WS_CUSTOMIZED_PATH_ECOWITT
path wunderground $C_WS_CUSTOMIZED_PATH_WU"
}

parsePath() {
    readString
    C_WS_CUSTOMIZED_PATH_ECOWITT=$VALUE_STRING
    readString
    C_WS_CUSTOMIZED_PATH_WU=$VALUE_STRING

    printPath
}

printCustomized() {
    echo "id                 $C_WS_CUSTOMIZED_ID
password           $C_WS_CUSTOMIZED_PASSWORD
server             $C_WS_CUSTOMIZED_SERVER
port               $C_WS_CUSTOMIZED_PORT
interval           $C_WS_CUSTOMIZED_INTERVAL
protocol           $C_WS_CUSTOMIZED_TYPE $C_WS_CUSTOMIZED_TYPE_STATE 
enabled            $C_WS_CUSTOMIZED_ENABLED $C_WS_CUSTOMIZED_ENABLED_STATE
path ecowitt       $C_WS_CUSTOMIZED_PATH_ECOWITT
path wunderground  $C_WS_CUSTOMIZED_PATH_WU"
}

parseCustomized() {
    readString
    C_WS_CUSTOMIZED_ID=$VALUE_STRING

    readString
    C_WS_CUSTOMIZED_PASSWORD=$VALUE_STRING

    readString
    C_WS_CUSTOMIZED_SERVER=$VALUE_STRING

    readUInt16BE
    C_WS_CUSTOMIZED_PORT=$VALUE_UINT16BE

    readUInt16BE
    C_WS_CUSTOMIZED_INTERVAL=$VALUE_UINT16BE

    readUInt8
    C_WS_CUSTOMIZED_TYPE=$VALUE_UINT8

    if [ "$C_WS_CUSTOMIZED_TYPE" -eq 1 ]; then
        C_WS_CUSTOMIZED_TYPE_STATE="wunderground"
    elif [ "$C_WS_CUSTOMIZED_TYPE" -eq 0 ]; then
        C_WS_CUSTOMIZED_TYPE_STATE="ecowitt"
    fi

    readUInt8

    C_WS_CUSTOMIZED_ENABLED=$VALUE_UINT8
    if [ "$C_WS_CUSTOMIZED_ENABLED" -eq 1 ]; then
        C_WS_CUSTOMIZED_ENABLED_STATE="on"
    elif [ "$C_WS_CUSTOMIZED_ENABLED" -eq 0 ]; then
        C_WS_CUSTOMIZED_ENABLED_STATE="off"
    fi

    printCustomized
}

printWunderground() {
    echo "wunderground station id       $C_WS_WUNDERGROUND_ID
wunderground station password $C_WS_WUNDERGROUND_PASSWORD"
}

parseWunderground() {
    readString
    C_WS_WUNDERGROUND_ID=$VALUE_STRING
    readString
    C_WS_WUNDERGROUND_PASSWORD=$VALUE_STRING

    printWunderground
}

printWeathercloud() {
    echo "weathercloud id               $C_WS_WC_ID
weathercloud password         $C_WS_WC_PASSWORD"
}

parseWeathercloud() {
    readString
    C_WS_WC_ID=$VALUE_STRING

    readString
    C_WS_WC_PASSWORD=$VALUE_STRING

    printWeathercloud
}

printWow() {
    echo "wow id                        $C_WS_WOW_ID
wow password                  $C_WS_WOW_PASSWORD"
}

parseWow() {
    readString
    C_WS_WOW_ID=$VALUE_STRING

    readString
    C_WS_WOW_PASSWORD=$VALUE_STRING

    printWow
}

printSensorLine()
{

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
    #shellcheck disable=SC3044
      typeset sensorIdState sensorsignal_unicode sgi_normal
    else
      local sensorIdState sensorsignal_unicode sgi_normal
    fi

    unset SGI_SENSOR SBATTERY_STATE

    getSensorNameShort "$1"

    if [ "$2" -eq "$SENSORID_DISABLE" ]; then 
      SGI_SENSOR=$SGI_BRIGHTRED_BLACK
      sensorIdState=$SENSORIDSTATE_DISABLED
    elif [ "$2" -eq "$SENSORID_SEARCH" ]; then
      SGI_SENSOR=$SGI_BRIGHTGREEN_BLACK
      sensorIdState=$SENSORIDSTATE_SEARCHING
    else
       getSensorBatteryState "$1" "$3"
       sensorIdState=$SENSORIDSTATE_CONNECTED
       if [ "$4" -le 1 ]; then # poor signal
           SGI_SENSOR=$SGI_SIGNAL_LOW
       fi
       if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
            case "$4" in 
                1) sensorsignal_unicode='▁'
                ;;
                2) sensorsignal_unicode='▁▂'
                ;;
                3) sensorsignal_unicode='▁▂▃'
                ;;
                4) sensorsignal_unicode='▁▂▃▄'
                ;;
            esac
        fi
    fi

    if [ -n "$SGI_SENSOR" ]; then
       sgi_normal=$SGI_NORMAL # insert end escape sequence only if sgi is used
    fi
    
    if [ "$TERM_ANSI_ESCAPE" -eq 0  ]; then
       unset SGI_SENSOR SGI_NORMAL
    fi

   # if [ "$2" -ne "$SENSORID_DISABLE" ] && [ "$2" -ne "$SENSORID_SEARCH" ]; then 
     # 1 battery unicode is field size 4 in printf format string. TEST printf  "🔋 1.3 V" | od -A n -t x1 | wc -w -> 10
        APPEND_FORMAT=$APPEND_FORMAT"%6u %9x %3u %1u %4s %-17s $SGI_SENSOR%9s$sgi_normal %-10s %15s\n" #just use one printf call builtin/external -> builds up entire format and argument strings
        APPEND_ARGS=$APPEND_ARGS"\"$1\" \"$2\" \"$3\" \"$4\"  \"$SENSORNAME_WH\" \"$SENSORNAME_SHORT\" \"$sensorIdState\" \"$SBATTERY_STATE\" \"$sensorsignal_unicode\" "
   # else
   #     APPEND_FORMAT=$APPEND_FORMAT"$SGI_SENSOR%2u %9s %3u %1u$SGI_NORMAL\n" 
   #     APPEND_ARGS=$APPEND_ARGS"\"$1\" \"$sensorIdState\" \"$3\" \"$4\" "
   # fi

    if [ -n "$KSH_VERSION" ]; then
      unset sensorIdState sgi_normal
    fi
     
}

resetAppendBuffer()
{
   unset APPEND_FORMAT APPEND_ARGS
}

parseSensorIdNew()
{
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
    #shellcheck disable=SC3044
        typeset stype signal battery
    else
       local stype signal battery
    fi

    resetAppendBuffer
    
    APPEND_FORMAT="%6s %9s %3s %1s %-4s %-17s %-9s %-10s %s\n%s\n"
    SENSORID_HEADER=${SENSORID_HEADER:="Sensor ID B S Type Name State Battery Signal"}
    APPEND_ARGS="$SENSORID_HEADER ───────────────────────────────────────────────────────────────────────── "

    [ "$DEBUG" -eq  1 ] && >&2 echo "SPATTERNID $SPATTERNID"
    
    while [ ${#OD_BUFFER} -ge 7 ]; do
       
       readUInt8            #type
       stype=$VALUE_UINT8
       
       readUInt32BE         #id
       SID=$VALUE_UINT32BE
       
       readUInt8   
       battery=$VALUE_UINT8
       
       readUInt8
       signal=$VALUE_UINT8


       if [ -n "$SPATTERNID" ] && [ "$SPATTERNID" -eq 1 ] && [ $SID -ne $SENSORID_SEARCH ] && [ $SID -ne $SENSORID_DISABLE ] ; then
            printSensorLine $stype $SID $battery $signal
       elif [ -n "$SPATTERNID" ] &&  [ "$SPATTERNID" -eq $SID ] ; then
            printSensorLine $stype $SID $battery $signal
       elif [ -z "$SPATTERNID" ]; then
            printSensorLine $stype $SID $battery $signal
       fi   
       
       [ "$DEBUG" -eq 1 ] && >&2 echo "type $stype id $SID battery $battery signal $signal od_buffer length ${#OD_BUFFER}"
    done

    printAppendBuffer

    if [ -n "$KSH_VERSION" ]; then
      unset stype signal battery
    fi
}

parsePacket() {

    if [ -z "$1" ]; then
        [ "$DEBUG" -eq 1 ] && echo >&2 Empty od buffer
        return "$ERROR_OD_BUFFER_EMPTY"
    fi

    newBuffer "OD_BUFFER" "$1"

    readSlice 4

    PRX_PREAMBLE="$B1 $B2"
    if [ "$PRX_PREAMBLE" != "255 255" ]; then
        return "$ERROR_PRX_PREAMBLE"
    fi

    PRX_CMD_UINT8=$((B3))
    getCommandName "$PRX_CMD_UINT8"
    { [ "$DEBUG" -eq 1 ] || [ "$DEBUG_SHOW_OD_BUFFER" ] ; } && {
       printf >&2 "< %-20s" "$COMMAND_NAME"
       printBuffer >&2 "$1" 
    }

    #Packet length
    if [ "$PRX_CMD_UINT8" -eq $CMD_BROADCAST ] || [ "$PRX_CMD_UINT8" -eq $CMD_LIVEDATA ] || [ "$PRX_CMD_UINT8" -eq $CMD_READ_SENSOR_ID_NEW ]; then
        readUInt8
        PACKET_RX_LENGTH=$(((B4 << 8) & VALUE_UINT8))
    else
        PACKET_RX_LENGTH=$((B4))
    fi

    [ $DEBUG -eq 1 ] && echo >&2 "RX PACKET LENGTH $PACKET_RX_LENGTH"

    if isWriteCommand "$PRX_CMD_UINT8"; then
        parseResult
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_VERSION ]; then
        parseVersion
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_MAC ]; then
        parseMAC
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_ECOWITT_INTERVAL ]; then
        parseEcowittInterval
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_WUNDERGROUND ]; then
        parseWunderground
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_WEATHERCLOUD ]; then
        parseWeathercloud
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_WOW ]; then
        parseWow
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_SYSTEM ]; then
        parseSystem
    elif [ "$PRX_CMD_UINT8" -eq $CMD_LIVEDATA ]; then
        parseLivedata
    elif [ "$PRX_CMD_UINT8" -eq $CMD_BROADCAST ]; then
        parseBroadcast
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_RAINDATA ]; then
        parseRaindata
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_CALIBRATION ]; then
        parseCalibration
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_PATH ]; then
        parsePath
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_CUSTOMIZED ]; then
        parseCustomized
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_SENSOR_ID_NEW ] ||[ "$PRX_CMD_UINT8" -eq $CMD_READ_SENSOR_ID ]; then
        parseSensorIdNew
    else
        echo >&2 ERROR Parsing of command "$COMMAND_NAME" not supported
    fi

    [ $DEBUG -eq 1 ] && echo >&2 "Received command $PRX_CMD integer cmd $PRX_CMD_UINT8"
}

getHexDigit() {
    unset VALUE_HEX_DIGIT

    if [ "$1" -ge 0 ] && [ "$1" -le 9 ]; then
        VALUE_HEX_DIGIT=$1
    elif [ "$1" -eq 10 ]; then
        VALUE_HEX_DIGIT='a'
    elif [ "$1" -eq 11 ]; then
        VALUE_HEX_DIGIT='b'
    elif [ "$1" -eq 12 ]; then
        VALUE_HEX_DIGIT='c'
    elif [ "$1" -eq 13 ]; then
        VALUE_HEX_DIGIT='d'
    elif [ "$1" -eq 14 ]; then
        VALUE_HEX_DIGIT='e'
    elif [ "$1" -eq 15 ]; then
        VALUE_HEX_DIGIT='f'
    fi
}

convertUInt8ToHex() {
#$1 - decimal value to convert to hex
    if [ "$SHELL_SUPPORT_PRINTF_VOPT" -eq 1 ]; then
    #shellcheck disable=SC3045
        printf -v VALUE_HEX "%02x" "$1"
        return
    fi

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset lsb lsb_hexdigit msb
    else
        local lsb lsb_hexdigit msb
    fi
    lsb=$(($1 & 0xf))
    getHexDigit "$lsb"
    lsb_hexdigit=$VALUE_HEX_DIGIT
    if [ "$1" -gt 15 ]; then
        msb=$(($1 >> 4))
        getHexDigit "$msb"
        VALUE_HEX=$VALUE_HEX_DIGIT$lsb_hexdigit
    else
        VALUE_HEX=0$VALUE_HEX_DIGIT
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset lsb lsb_hexdigit msb2
    fi

}

newPacketBody() {
    if [ -z "$1" ]; then
        echo >&2 Error no command given to newPacketBody
        return 1
    fi

    PACKET_TX_CMD=$(($1))
    getCommandName "$PACKET_TX_CMD"

    PACKET_TX_PREAMBLE="255 255"
    unset PACKET_TX_BODY

}

getLength()
#get length of tx packet buffer
#$1 string of uint8 integers with space
{
    IFS=' '
    VALUE_LENGTH=0
    for BYTE in $1; do
      VALUE_LENGTH=$(( VALUE_LENGTH + 1 ))
    done
}

checksumPacketTX() {
    getLength "$PACKET_TX_BODY"
    PACKET_TX_BODY_LENGTH=$((VALUE_LENGTH + 2)) # at least 2 byte for length + checksum bytes

    if [ "$PACKET_TX_CMD" -eq "$CMD_BROADCAST" ] || [ "$PACKET_TX_CMD" -eq $CMD_WRITE_SSID ]; then # 2 byte length 
        PACKET_TX_BODY_LENGTH=$(( PACKET_TX_BODY_LENGTH + 1 ))
        PACKET_TX_LENGTH=" $(( ((PACKET_TX_BODY_LENGTH + 1) & 0xff00) >> 8 )) $(( (PACKET_TX_BODY_LENGTH + 1) & 0xff ))"
    else
        PACKET_TX_LENGTH=$((PACKET_TX_BODY_LENGTH + 1)) # add 1 byte for cmd field
    fi

    if [ -n "$PACKET_TX_BODY" ]; then
        PACKET_TX_BODY="$PACKET_TX_CMD $PACKET_TX_LENGTH $PACKET_TX_BODY"

    else
        PACKET_TX_BODY="$PACKET_TX_CMD $PACKET_TX_LENGTH"
    fi

    checksum "$PACKET_TX_BODY"

    PACKET_TX_BODY="$PACKET_TX_BODY $VALUE_CHECKSUM"
    PACKET_TX="$PACKET_TX_PREAMBLE $PACKET_TX_BODY"

    [ $DEBUG -eq 1 ] && echo >&2 "PACKET_TX $PACKET_TX PACKET_TX_BODY $PACKET_TX_BODY"
}

convertHexToOctal() { #$1 - 0xff format
    if [ "$SHELL_SUPPORT_PRINTF_VOPT" -eq 1 ]; then
    #shellcheck disable=SC3045
       printf -v VALUE_OCTAL "%03o" "$1"
       return
    fi

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset dec lsb msb middle
    else
        local dec lsb msb middle
    fi
    dec=$(($1))

    lsb=$((dec & 7)) #least significant 3-bit sequence
    middle=$(((dec >> 3) & 7))
    msb=$((dec >> 6))
    VALUE_OCTAL=$msb$middle$lsb

    [ $DEBUG -eq 1 ] && echo >&2 Converting "$1" to octal "$VALUE_OCTAL"

    if [ -n "$KSH_VERSION" ]; then
        unset dec lsb msb middle
    fi
}

convertBufferFromDecToOctalEscape() {
    unset VALUE_OCTAL_BUFFER_ESCAPE

    for BYTE in $1; do
        convertHexToOctal "$BYTE"
        VALUE_OCTAL_BUFFER_ESCAPE="$VALUE_OCTAL_BUFFER_ESCAPE\\0$VALUE_OCTAL"
    done

    [ $DEBUG -eq 1 ] && echo >&2 "Octal buffer $VALUE_OCTAL_BUFFER_ESCAPE"
}

sendPacket() {
    sendPacketnc "$@" # $@ each arg expands to a separate word
    EXITCODE_SENDPACKET=$?
    
    [ "$EXITCODE_SENDPACKET" -ne 0 ] && [ "$DEBUG" -eq 1 ] && echo >&2 "Sendpacket failed with error code $EXITCODE_SENDPACKET"
    return $EXITCODE_SENDPACKET
}

sendPacketnc() { #$1 - command
    #$2 - host
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset ncUDPOpt port host timeout_udp_broadcast timeout_nc od_buffer cmdstr nccmdstr odcmdstr
    else
        local   ncUDPOpt port host timeout_udp_broadcast timeout_nc useTimeout od_buffer cmdstr nccmdstr odcmdstr
    fi

    timeout_nc=0.05
    timeout_udp_broadcast=0.236 # timeout selected based on udp port scanning 254 hosts in 60s (60s/254=0.236s)
    useTimeout=0

    #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
    if [ $# -ge 1 ]; then
        newPacketBody "$1"
    fi

    if [ -n "$2" ]; then
        host="$2" # for udp broadcast probing on subnet
    else
        host="$C_host" # -h option
    fi

    if [ -z "$host" ]; then
      echo >&2 No host specified
      return "$ERROR_NO_HOST_SPECIFIED"
    fi

    checksumPacketTX

    convertBufferFromDecToOctalEscape "$PACKET_TX" # \0377 \0377 \0nnn
    PACKET_TX_ESCAPE=$VALUE_OCTAL_BUFFER_ESCAPE

    { [ "$DEBUG" -eq 1 ] || [ "$DEBUG_SHOW_OD_BUFFER" ] ; } &&
    {
        printf >&2 "> %-20s" "$COMMAND_NAME"
        printBuffer >&2 "$PACKET_TX"
    }

    port=$PORT_GW_TCP

    if [ $PACKET_TX_CMD -eq $CMD_BROADCAST ]; then
        ncUDPOpt='-u'
        port=$PORT_GW_UDP
        timeout_nc=$timeout_udp_broadcast
        useTimeout=1
    elif [ "$PACKET_TX_CMD" -eq $CMD_WRITE_RESET ] || [ "$PACKET_TX_CMD" -eq $CMD_WRITE_SSID ]; then
        :
    elif [ "$PACKET_TX_CMD" -eq $CMD_REBOOT ]; then
       useTimeout=1
       timeout_nc=1
       #sometimes result packet from gw is not received, and nc hangs
    fi

    # change between openbsd/nmap ncat in WSL2/ubuntu - sudo update-alternatives --config nc

    odcmdstr="od -A n -t u1 -w$MAX_16BIT_UINT"

    if [ "$NC_VERSION" -eq $NC_OPENBSD ]; then

        # -N shutdown(2) the network socket after EOF on the input / from man nc - otherwise nc hangs
        nccmdstr="$NC_CMD -4 -N $ncUDPOpt $host $port" 
       
        if [ "$useTimeout" -eq 1 ]; then
           nccmdstr="timeout $timeout_nc $nccmdstr"
        fi
        
        cmdstr="printf %b \"$PACKET_TX_ESCAPE\" | $nccmdstr | $odcmdstr"

    elif [ "$NC_VERSION" -eq $NC_NMAP ]; then

        #sleep to disable immediate EOF and shutdown of ncat -> which leads to data not received from udp socket
       
        nccmdstr="$NC_CMD -4 -w 1 $ncUDPOpt $host $port"
        cmdstr="{ printf %b \"$PACKET_TX_ESCAPE\"; sleep $timeout_nc; } |  $nccmdstr | $odcmdstr"

    elif [ "$NC_VERSION" -eq $NC_TOYBOX ]; then

        nccmdstr="$NC_CMD -4 $ncUDPOpt $host $port"
        
        if [ "$useTimeout" -eq 1 ]; then
           nccmdstr="timeout $timeout_nc $nccmdstr"
        fi

        cmdstr="printf %b \"$PACKET_TX_ESCAPE\" | $nccmdstr | $odcmdstr"

    elif [ "$NC_VERSION" -eq $NC_BUSYBOX ]; then

        nccmdstr="$NC_CMD nc $host $port"

        if [ -z "$ncUDPOpt" ]; then
            cmdstr="printf %b \"$PACKET_TX_ESCAPE\" |  $nccmdstr | $odcmdstr"
        else
            echo >&2 Busybox nc does not support UDP
        fi
    else
        echo >&2 "Error nc version $NC_VERSION not supported sendPacketnc $ERROR_DEPENDENCY_NC"
        return "$ERROR_DEPENDENCY_NC"
    fi

    if [ -n "$cmdstr" ]; then
       if [ -n "$OPTION_SHOW_COMMAND" ] && [ "$OPTION_SHOW_COMMAND" -eq 1 ]; then
         printf "%s\n" "$cmdstr"
       fi
       od_buffer=$(eval "$cmdstr" )
       #maybe use: https://stackoverflow.com/questions/1550933/catching-error-codes-in-a-shell-pipe
       parsePacket "$od_buffer"
       EXITCODE_SENDPACKET=$?
    fi

    if [ -n "$KSH_VERSION" ]; then
       unset ncUDPOpt ncIdleOpt port host timeout_udp_broadcast useTimeout timeout_nc od_buffer cmdstr nccmdstr odcmdstr
    fi

}

discovery() {
    if [ -n "$NC_VERSION" ]; then
        discovery_nc "$@"
    else
        echo >&2 Error nc not found, cannot scan for devices
    fi

}

discovery_udp_client() { #$1 - subnet, for example 192.168.3
    #issue: nc fails to read when sending to subnet broadcast address 192.168.3.255
    #host reply with ICMP host/port unreachable or broadcast response
    #send broadcast cmd to port 46000
    #some host responses take a long time > 175ms, but most take only 4-8ms, so -s should be run multiple times to get all hosts on the subnet
    #wireshark filter: ip.addr == 192.168.3.80 or ip.addr == 192.168.3.49 or ip.addr == 192.168.3.204
    #wireshark: Time field: "Delta time displayed"
    #testing environment: vEthernet WSL adapter/ubuntu, Windows 11, Realtek RTL8852AE WiFi 6 802.11ax PCIe, Huawei AX mesh router 5Ghz channel 36,WPA2
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset host
    else
        local host
    fi
    host=1
    while [ $host -le 254 ]; do
        [ $DEBUG -eq 1 ] && echo >&2 Discovery sending broadcast command to "$1.$host"
        sendPacket $CMD_BROADCAST "$1.$host"
        host=$((host + 1))
    done

    if [ -n "$KSH_VERSION" ]; then
      unset host
    fi
}

discovery_nc() { #$1 - subnet for udp scan

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        {
            typeset -i scan_max_iterations n
            typeset scan_nc_idle_timeout  broadcast
        }
    else
        local scan_max_iterations scan_nc_idle_timeout n broadcast
    fi

    scan_max_iterations=10
    scan_nc_idle_timeout=0.005 # 5ms

    case "$KSH_VERSION" in
        *Android*)
            echo >&2 "Error UDP scanning for devices not supported ( -u -l options ), nc version $NC_VERSION_STR"
            # udp -u -l option gives 1 error code and 'nc: listen' output
            return "$ERROR_NC_UDP_SCAN_UNAVAILABLE"
            ;;
    esac

    if [ -z "$1" ]; then # set up server on 59387 port

        if [ "$NC_VERSION" -ne $NC_NMAP ]; then
            scan_max_iterations=30
            SCAN_NC_TIMEOUT=0.1
        fi

        if scan_result=$(
            n=0
            while [ $n -lt $scan_max_iterations ]; do
                if [ "$NC_VERSION" -eq $NC_NMAP ]; then
                    $NC_CMD -4 -u -i $scan_nc_idle_timeout -l $PORT_CLIENT_UDP 2>/dev/null | od -A n -w64 -t x1
                else
                    timeout $SCAN_NC_TIMEOUT "$NC_CMD" -4 -u -l $PORT_CLIENT_UDP 2>/dev/null | od -A n -w64 -t x1
                fi
                n=$((n + 1))
            done | sort -u
        ); then #"A Brief POSIX Advocacy: Shell Script Portability" https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf

            if [ -n "$scan_result" ]; then
                IFS=$(printf "\n\b") # #https://stackoverflow.com/questions/16831429/when-setting-ifs-to-split-on-newlines-why-is-it-necessary-to-include-a-backspac
                for broadcast in $scan_result; do
                    parse_od_hex_packet "$broadcast"
                done
            fi
        else
            echo >&2 Error failed to obtain scan result while listening on UDP port $PORT_CLIENT_UDP, error code $?
        fi
    else
        discovery_udp_client "$1"
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset scan_max_iterations scan_nc_idle_timeout n broadcast
    fi
}

checksum() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset sum
    else
        local sum
    fi

    sum=0

    [ "$DEBUG" -eq 1 ] && >&2 echo  "checksum calculation on $1"
    
    IFS=" "
    for BYTE in $1; do
        [ $DEBUG -eq 1 ] && >&2 echo  "checksum read $BYTE"
        sum=$(( (sum + BYTE) & 255 ))
    done

    [ $DEBUG -eq 1 ] &&  >&2  echo "checksum $sum $(printf "%2x" $sum)"

    VALUE_CHECKSUM=$sum

    if [ -n "$KSH_VERSION" ]; then
      unset sum
    fi
}

newCustomizedPacket() {
    newPacketBody $CMD_WRITE_CUSTOMIZED
    writeString "$C_WS_CUSTOMIZED_ID"
    writeString "$C_WS_CUSTOMIZED_PASSWORD"
    writeString "$C_WS_CUSTOMIZED_SERVER"
    writeUInt16BE "$C_WS_CUSTOMIZED_PORT"
    writeUInt16BE "$C_WS_CUSTOMIZED_INTERVAL"
    writeUInt8 "$C_WS_CUSTOMIZED_TYPE"
    writeUInt8 "$C_WS_CUSTOMIZED_ENABLED"
}

newPathPacket() {
    newPacketBody $CMD_WRITE_PATH
    writeString "$C_WS_CUSTOMIZED_PATH_WU"
    writeString "$C_WS_CUSTOMIZED_PATH_ECOWITT"
}

sendSystem() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset dst
    else
        local dst
    fi

    dst=0

    if ! isNumber "$1" || [ "$1" -gt 1 ]; then
        echo Error: System type must be 0 for WH24, or 1 for WH65 - "$1" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    if ! isNumber "$2" || [ "$2" -ge $SYSTEM_TIMEZONE_MAX_INDEX ]; then
        echo Error: System timezone index must be 0 - "$SYSTEM_TIMEZONE_MAX_INDEX" - "$2" invalid
        printTimezones
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    if ! isNumber "$3" || [ "$3" -gt 1 ]; then
        echo Error: Daylight saving must be 0 for disabled, or 1 for enabled - "$3" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    if ! isNumber "$4" || [ "$4" -gt 1 ]; then
        echo Error: Auto timezone must be 0 for disabled, or 1 for enabled - "$4" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    #TODO dst=

    #        CONFIGURATION[$CONF_system_dst_status_bit]=$(( "${CONFIGURATION[$CONF_system_dst_status]}" & 0x1 ))
    #     CONFIGURATION[$CONF_system_timezone_auto_bit]=$(( ( "${CONFIGURATION[$CONF_system_dst_status]}" & 0x2 ) >> 1 )) # bit 2 1= off, 0=on ?

    if [ "$4" -eq 0 ]; then
        dst=$(($3 | 2))
    else
        dst=$(($3))
    fi

    newPacketBody $CMD_WRITE_SYSTEM
    writeUInt8 0      #frequency - only read
    writeUInt8 "$1"   #sensortype 0=WH24, 1=WH65
    writeUInt32BE 0   #UTC time - only read
    writeUInt8 "$2"   #timezone index
    writeUInt8 "$dst" #daylight saving - dst
    sendPacket

    if [ -n "$KSH_VERSION" ]; then
      unset dst
    fi
}

sendRaindata() {
    # if ! [[ "$1" =~ ^[0-9]+$ ]] || ! [[ "$2" =~ ^[0-9]+$ ]] || ! [[ "$3" =~ ^[0-9]+$ ]] || ! [[ "$4" =~ ^[0-9]+$ ]]; then
    if ! isNumber "$1" || ! isNumber "$2" || ! isNumber "$3" || ! isNumber "$4"; then
        echo Error: Raindata has "element(s)" which is not a number
        return "$ERROR_RAINDATA_NOTSPECIFIED"
    fi

    [ $DEBUG -eq 1 ] && echo >&2 rainday "$2" rainweek "$3" rainmonth "$4" rainyear "$5"

    newPacketBody $CMD_WRITE_RAINDATA
    writeUInt32BE "$1" #rainday
    writeUInt32BE "$2" #rainweek
    writeUInt32BE "$3" #rainmonth
    writeUInt32BE "$4" #rainyear
    [ $DEBUG -eq 1 ] && echo >&2 "Sending raindata rd $1 rw $2 rm $3 ry $4"
    sendPacket
}

sendCalibration() {
    newPacketBody $CMD_WRITE_CALIBRATION
    writeUInt16BE "$1" #intempoffset
    writeUInt8 "$2"    #inhumidityoffset
    writeUInt32BE "$3" #absoffset
    writeUInt32BE "$4" #reloffset
    writeUInt16BE "$5" #outtempoffset
    writeUInt8 "$6"    #outhumidityoffset
    writeUInt16BE "$7" #winddiroffset

    [ $DEBUG -eq 1 ] && echo >&2 "Sending calibration itempo $1 iho $2 abso $3 relo $4 otempo $5 oho $6 wdo $7"
    sendPacket

}

sendEcowittIntervalnew() {
    # observation: GW1000 red-wifi led blinks slowly if not sending data to ecowitt when 0=off
    if [ "$1" -ge 0 ] && [ "$1" -le 5 ]; then
        newPacketBody $CMD_WRITE_ECOWITT_INTERVAL
        writeUInt8 "$1" #interval
        [ $DEBUG -eq 1 ] && echo >&2 Sending ecowitt interval "$1"
        sendPacket
    else
        echo >&2 Error Not a valid ecowitt interval, range 0-5 minutes
    fi
}

sendEcowittInterval() {
    # observation: GW1000 red-wifi led blinks slowly if not sending data to ecowitt when 0=off
    if [ "$1" -ge 0 ] && [ "$1" -le 5 ]; then
        newPacketBody $CMD_WRITE_ECOWITT_INTERVAL
        writeUInt8 "$1" #interval
        [ $DEBUG -eq 1 ] && echo >&2 Sending ecowitt interval "$1"
        sendPacket
    else
        echo >&2 Error Not a valid ecowitt interval, range 0-5 minutes
    fi
}

sendWeatherservice() {

    newPacketBody "$1"
    writeString "$2"
    writeString "$3"

    case "$1" in
    "$CMD_WRITE_WOW")
        writeUInt8 0 # stationnum size - unused
        writeUInt8 1
        ;;

    "$CMD_WRITE_WEATHERCLOUD")
        writeUInt8 1
        ;;
    esac
    [ $DEBUG -eq 1 ] && echo >&2 "Sending weather service $1 id $2 password $3"
    sendPacket
}

sendCustomized() {
    newCustomizedPacket
    sendPacket

    newPathPacket
    sendPacket

}

updateCustomized() {

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
            typeset value key option
    else
        local value key option
    fi

    #readarray -d ',' -t OPTION_CUSTOMIZED < <(echo -n "$1") # <<< HERE string appends 0x0a -> using process substitution

    [ $DEBUG -eq 1 ] && echo >&2 "updateCustomized $1"

    # 1. parse , expressions server=localhost,port=8080,protocol=ecowitt,enabled=yes

     IFS=','
     for option in $1; do
        
        [ $DEBUG -eq 1 ] && echo >&2 "updateCustomized: option $option"

        # 2. parse = expressions

        IFS='='
        #shellcheck disable=SC2086
        set -- $option
        key=$1
        value=$2

        [ $DEBUG -eq 1 ] && echo >&2 "updateCustomized KEY $key len ${#key} VALUE $value len ${#value}"

        case "$key" in

            id)
                [ $DEBUG -eq 1 ] && echo >&2 Update customized_id from "$C_WS_CUSTOMIZED_ID to $value"
                C_WS_CUSTOMIZED_ID=$value
                ;;

            password | pw)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_password from "${C_WS_CUSTOMIZED_PASSWORD} to $value"
                C_WS_CUSTOMIZED_PASSWORD=$value
                #observation: gw1000 client will not send wunderground http request unless password and id is specified
                ;;

            server | s)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_server from "$C_WS_CUSTOMIZED_SERVER to $value"
                C_WS_CUSTOMIZED_SERVER=$value

                ;;

            port)

                if ! isNumber "$value"; then
                    echo >&2 Error NaN cannot set customized port to $((value)) from "$value"
                else
                    C_WS_CUSTOMIZED_PORT=$((value))
                    [ $DEBUG -eq 1 ] && echo >&2 Update customized_port from "$C_WS_CUSTOMIZED_PORT to $value"
                fi

                ;;

            protocol | p)

                case $value in

                    wunderground | wu | w)
                        value=$((1))
                        ;;

                    ecowitt | ec | e)
                        value=$((0))
                        ;;

                esac

                if ! isNumber "$value"; then
                    echo >&2 Error NaN cannot set customized type to "$value"
                else
                    C_WS_CUSTOMIZED_TYPE=$((value))
                    [ $DEBUG -eq 1 ] && echo >&2 Update customized_TYPE from "$C_WS_CUSTOMIZED_TYPE to $value"
                fi

                ;;

            enabled | e)

                case $value in

                    on | 1 | yes | y)
                        value=$((1))
                        ;;

                    off | 0 | no | n)
                        value=$((0))
                        ;;
                esac

                if ! isNumber "$value"; then
                    echo >&2 Error Cannot set customized enabled to "$value"
                else
                    [ $DEBUG -eq 1 ] && echo >&2 Update customized_enabled from "$C_WS_CUSTOMIZED_ENABLED to $value"
                    C_WS_CUSTOMIZED_ENABLED=$value
                fi

                ;;

            interval | i)

                if ! isNumber "$value"; then
                    echo >&2 Error NaN cannot set customized interval to "$value"
                else
                    [ $DEBUG -eq 1 ] && echo >&2 "Update customized_interval from $C_WS_CUSTOMIZED_INTERVAL to $value"
                    C_WS_CUSTOMIZED_INTERVAL=$((value))

                fi

                ;;

            path_wunderground | path_wu | pwu)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_path_wu from "$C_WS_CUSTOMIZED_PATH_WU to $value"
                C_WS_CUSTOMIZED_PATH_WU=$value

                ;;

            path_ecowitt | path_ec | pec)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_ecowitt_path from "$C_WS_CUSTOMIZED_PATH_ECOWITT to $value"
                C_WS_CUSTOMIZED_PATH_ECOWITT=$value

                ;;

            *)
                echo >&2 Skipped updateCustomized: unknown key "$key" value: "$value"
                ;;
        esac

    done

    #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash

    [ $DEBUG -eq 1 ] && printCustomized >&2

    sendCustomized

    if [ -n "$KSH_VERSION" ]; then
      unset key value option
    fi


}

convertScale10ToFloat() {
    # $1 - number to convert
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        {
            typeset -i int frac number
            typeset sign
        }
    else
        local int frac number sign
    fi

    unset VALUE_SCALE10_FLOAT

    if [ -z "$1" ]; then
        echo >&2 Error convertScale10ToFloat empty arg "$1"
        return "$ERROR_CONVERT"
    fi

    number=$(($1))
    if [ "$number" -lt 0 ]; then
        number=$((number * -1))
        sign="-"
    fi

    if [ "$number" -lt 10 ]; then
        VALUE_SCALE10_FLOAT=$sign"0."$number
    else
        int=$((number / 10))
        frac=$((number - int * 10))
        VALUE_SCALE10_FLOAT=$sign$int.$frac
    fi

   if [ -n "$KSH_VERSION" ]; then
        unset int frac number sign
  fi
}

initnc() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        {
            typeset nc_ver nc_ver_header nc_status nc_exec ncat_exec busybox_exec
        }
    else
        local nc_ver nc_ver_header nc_status nc_exec ncat_exec busybox_exec
    fi

    nc_exec=$(which nc 2>/dev/null)
    if [ -z "$nc_exec" ]; then
        ncat_exec=$(which ncat 2>/dev/null) # try ncat, if nc not availale
        if [ -n "$ncat_exec" ]; then
            NC_CMD=$ncat_exec
        else
            busybox_exec=$(which busybox 2>/dev/null) # test busybox nc
            if [ -n "$busybox_exec" ]; then
                NC_CMD="$busybox_exec"
                NC_VERSION=$NC_BUSYBOX
                NC_VERSION_STR="nc busybox"
                return 0
            fi
        fi
    else
        NC_CMD=$nc_exec
    fi

    if [ -n "$NC_CMD" ] && [ -z $NC_VERSION ]; then

        nc_ver=$("$NC_CMD" --version 2>&1) # ""-preserve space
        nc_status=$?

        if [ "$nc_status" -eq 0 ]; then

            case "$nc_ver" in
            *nmap*)
                NC_VERSION=$NC_NMAP
                ;;
            *toybox*)
                NC_VERSION=$NC_TOYBOX
                ;;
            esac

            NC_VERSION_STR=$nc_ver
        else
            #            IFS=' ' read -r nc_ver_header << EOL
            #$nc_ver
            #EOL
            IFS=' '
            set -- "$nc_ver"
            nc_ver_header=$1

            case "$nc_ver_header" in

            $nc_exec:\ invalid\ option*)

                NC_VERSION=$NC_OPENBSD
                NC_VERSION_STR="nc openbsd (probably)"
                ;;

            *)
                echo >&2 "Error Unknown nc version header $nc_ver"
                NC_VERSION=$NC_OPENBSD
                NC_VERSION_STR="nc unknown"
                ;;
            esac

        fi

        [ "$DEBUG" -eq 1 ] && echo >&2 "nc version detection $NC_VERSION_STR"

        if [ -n "$KSH_VERSION" ]; then
           unset nc_ver nc_ver_header nc_status nc_exec ncat_exec busybox_exec
        fi

        return 0
    else
        return "$ERROR_DEPENDENCY_NC"
    fi

    
}

initConfigDir() {

    DIR_CONFIG=$HOME"/.config/gw"                              # .config subdirectory used for configuration on gnome/linux
    
    [ -n "$EXTERNAL_STORAGE" ] && DIR_CONFIG=$EXTERNAL_STORAGE # testing in Android 11 adb shell
    DIR_LIVEDATA="$EXTERNAL_STORAGE/tmp/gw/livedata"
    [ ! -d "$DIR_CONFIG" ] || [ ! -d "$DIR_LIVEDATA" ]  && mkdir -p -v "$DIR_CONFIG" "$DIR_LIVEDATA"   1>&2
    [ "$DEBUG" -eq 1 ] &&  echo >&2 Directory config "$DIR_CONFIG" livedata "$DIR_LIVEDATA"

    #SHELLPID=$$

}

argEmptyOrOption() {
    [ "$DEBUG" -eq 1 ] && echo >&2 argEmptyOrOption "$@"
    if [ -z "$1" ]; then
        return 0
    else
        case "$1" in

        -*)
            return 0
            ;;

        *)
            return 1
            ;;
        esac
    fi
}

printCommands() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
    #shellcheck disable=SC3044
      typeset cmd commands
    else
      local cmd commands
    fi

    commands="$CMDOPT_RESET reboot mac $CMDOPT_VERSION"

    echo "Commands available -c:"
    for cmd in $commands; do
      echo "   $cmd"
    done | sort | uniq 

    if [ -n "$KSH_VERSION" ]; then
      unset cmd commands
    fi
}

initcoptCommands ()
#-c option commands
{
    CMDOPT_RESET='reset'
    CMDOPT_VERSION='version|ver'
}

writeSensorId()
#$1 - low sensortype, $2 - high sensortype, $3 - sensorid
{

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1  ]; then
    #shellcheck disable=SC3044
       typeset n
    else
       local n
    fi

    newPacketBody $CMD_WRITE_SENSOR_ID

    if [ -z "$2" ]; then
     [ "$DEBUG" -eq 1 ] && echo >&2 "Writing sensor type $1, sensor id $3"
      writeUInt8 "$1"
      writeUInt32BE "$3"
    else
      n="$1"
      while [ "$n" -le "$2" ]; do
        [ "$DEBUG" -eq 1 ] && echo >&2 "Writing sensor type $n, sensor id $3"
         writeUInt8 "$n"
         writeUInt32BE "$3"
         n=$(( n + 1 ))
      done
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset n
    fi

    sendPacket
    
}

processSensorOptions()
# format: 31-38=disable,40-47=disable
{
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
       #shellcheck disable=SC3044
       {
        typeset f  sensortypeexpr cmdexpr
        case "$KSH_VERSION" in

          *MIRBSD?KSH*) typeset -iU sensorid
                        ;;
                    *) typeset sensorid
                    ;;
        esac
       }  
    else
       local f sensorid sensortypeexpr cmdexpr
    fi

    [ "$DEBUG" -eq 1 ] && echo >&2 processSensorOptions "$*"

     IFS=,
     for f in $1; do
       IFS='='
       #shellcheck disable=SC2086
       set -- $f
       sensortypeexpr=$1
       cmdexpr=$2
       unset sensorType_low sensorType_high

       case $cmdexpr in 
          disable|d) sensorid=$SENSORID_DISABLE
                   ;;
          search|s|enable|e)  sensorid=$SENSORID_SEARCH
                   ;;
          *) 
              if ! isHex "$cmdexpr"; then
               echo >&2 "Error Invalid hex number for sensor id $cmdexpr"
               return "$ERROR_INVALID_SENSORID_COMMAND"
              else
                 sensorid=$(( "$cmdexpr" ))
              fi
             ;;
       esac

       case $sensortypeexpr in
         *-*)  IFS=- # range with hyphen, for example 31-33
                #shellcheck disable=SC2086
                set -- $sensortypeexpr
                sensorType_low=$1
                sensorType_high=$2
                [ "$DEBUG" -eq 1 ] && >&2 echo "Sensor type low $sensorType_low sensor type high $sensorType_high"
               
                ;;
            *) 
               sensorType_low=$sensortypeexpr # only a single number
               ;;
       esac

       if [ -z "$sensorType_low" ]; then
          echo >&2 "Error Empty sensor id low $sensorType_low"
          return "$ERROR_INVALID_SENSORID"
       fi
       
       if [ -n "$sensorType_low" ] && ! isNumber "$sensorType_low" || [ "$sensorType_low" -gt "$SENSORTYPE_MAX" ]; then
          echo >&2 "Error Not a valid sensor type $sensorType_low, max sensortype $SENSORTYPE_MAX"
          return "$ERROR_INVALID_SENSORID"
       fi
       
       if [ -n "$sensorType_high" ]; then
          if  ! isNumber "$sensorType_high" || [ "$sensorType_high" -gt "$SENSORTYPE_MAX" ]; then
            echo >&2 "Error Not a valid sensor id $sensorType_high, max sensortype $SENSORTYPE_MAX"
            return "$ERROR_INVALID_SENSORID"
          fi

          if [ "$sensorType_low" -gt "$sensorType_high" ]; then
            echo >&2 "Error Sensor id low $sensorType_low is greather than sensorid high $sensorType_high"
            return "$ERROR_INVALID_SENSORID"
          fi

          if [ "$sensorid" -ne $SENSORID_DISABLE ] && [ "$sensorid" -ne $SENSORID_SEARCH ] && [ "$sensorType_low" -ne "$sensorType_high" ]; then
                    echo >&2 "Error Cannot set sensortype range to same sensorid $cmdexpr"
                    return $ERROR_INVALID_SENSORID
          fi
       fi

       writeSensorId "$sensorType_low" "$sensorType_high" "$sensorid"
          
    done

    if [ -n "$KSH_VERSION" ]; then
       unset f sensorid sensortypeexpr cmdexpr
    fi
}

processCommand() {

   [ "$DEBUG" -eq 1 ] && >&2 echo ARGS to processCommand "$@" length "$#" COMMAND "$COMMAND"

   if [ "$#" -ge 1 ]; then
      shift # remove {command} (to -c option) -> all args to {command} starts at $1
   fi

    case $COMMAND in

        "")
            printCommands
            ;;

        "$CMDOPT_RESET")

            sendPacket $CMD_BROADCAST >/dev/null

            echo "Reset $C_broadcast_mac $C_broadcast_ssid (Y/N)? "
            read -r

            case $REPLY in
            Y)
                sendPacket $CMD_WRITE_RESET # 3 blink in red LED
                connectGW                   # assume user wants to reconnect for setting up new WIFI
                ;;
            esac

            ;;

        reboot)

            sendPacket $CMD_REBOOT
            ;;

        mac)

            sendPacket $CMD_READ_MAC
            ;;

        version|ver)

            sendPacket $CMD_READ_VERSION
            ;;

        system | sys)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_SYSTEM
            else
                if [ $# -lt 4 ]; then
                    echo >&2 "Error {sensortype} {timezoneindex} {dst} {autotimezone} must be specified"
                else
                    sendSystem "$1" "$2" "$3" "$4"
                fi
            fi
            ;;

        ecowitt | ec | e)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_ECOWITT_INTERVAL
            else
                #sendEcowittInterval "$1"
                sendEcowittIntervalnew "$1"
            fi
            
            ;;

        wunderground | wu)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WUNDERGROUND
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error {id} {password} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WUNDERGROUND" "$1" "$2"
                fi
            fi

            ;;

        wow)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WOW
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error {id} {password} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WOW" "$1" "$2"
                fi
            fi
            ;;

        weathercloud | wc)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WEATHERCLOUD
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error {id} {key} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WEATHERCLOUD" "$1" "$2"
                fi
            fi
            ;;

        customized | c | cust)

            if argEmptyOrOption "$1"; then
                if ! sendPacket $CMD_READ_PATH >/dev/null || ! sendPacket $CMD_READ_CUSTOMIZED; then
                  >&2 echo Failed to get customized settings
                fi
            else
                
                if sendPacket $CMD_READ_CUSTOMIZED >/dev/null && sendPacket $CMD_READ_PATH >/dev/null; then
                updateCustomized "$1"
                else
                  >&2 echo Cannot update customized, failed to read customized settings
                fi
            fi
            

            ;;

       # path | p) # deprecate?

       #    sendPacket $CMD_READ_PATH
       #    ;;

        broadcast | b)
            sendPacket $CMD_BROADCAST
            ;;

        rain | r)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_RAINDATA
            else

                if [ $# -lt 4 ]; then # validate rain input
                    echo >&2 "Error: {rainday} {week} {month} {year} parameters not specified"
                else
                    sendRaindata "$1" "$2" "$3" "$4"
                fi

            fi

            ;;

        livedata | ld | live | l)

            if [ -z "$LOG_LIVEDATA" ]; then
                sendPacket $CMD_LIVEDATA
                EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
            else
              
                while true; do
                  sendPacket $CMD_LIVEDATA
                  sleep "$LOG_LIVEDATA_INTERVAL"
                done
            fi

            ;;

        sensor_id)

            sendPacket $CMD_READ_SENSOR_ID
            ;;

        sensor_id_new | sid | sensor | s) # for new SENSOR_TYPE types

            if ! argEmptyOrOption "$1"; then
             #filter for senorid; -c sensor connected|-c s c
              case "$1" in 
                connected|c)
                   SPATTERNID=1 #matches connected sensors
                   sendPacket $CMD_READ_SENSOR_ID_NEW
                   ;;
                searching|s)
                   SPATTERNID=$SENSORID_SEARCH
                   sendPacket $CMD_READ_SENSOR_ID_NEW
                   ;;
                disabled|d)
                   SPATTERNID=$SENSORID_DISABLE
                   sendPacket $CMD_READ_SENSOR_ID_NEW
                   ;;
                   
                *)  if isHex "$1"; then #search on hexid (without 0x prefix)
                       SPATTERNID=$(( 0x$1 ))
                       sendPacket $CMD_READ_SENSOR_ID_NEW
                    else
                      processSensorOptions "$1"
                    fi
                   ;;
              esac
            else
                sendPacket $CMD_READ_SENSOR_ID_NEW
            fi

            ;;

        calibration | cal)

            sendPacket $CMD_READ_CALIBRATION
            ;;

        *)

            echo >&2 Error Unknown command "$COMMAND" "$@"
            return "$ERROR_COMMAND_UNKNOWN"
            ;;
    esac

    EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET

    return $EXITCODE_PROCESSCOMMAND
}

isNumber() {
    #https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash?page=1&tab=votes#tab-top
    case $1 in
        '' | *[!0-9]*) return 1 ;;
        *) return 0 ;;
    esac
}

isHex()
{
    case $1 in 
      '' | 0x*[!0-9a-fA-F]*) return 1 ;;
      0x*) return 0 ;;
    esac
}

initShell() {
    #shellcheck disable=SC3010,SC2050
    eval "if 2>/dev/null 1>/dev/null type '[['  && 2>/dev/null [[ a =~ a ]] ; then
        SHELL_SUPPORT_TILDE_REGEX=1
    else
        SHELL_SUPPORT_TILDE_REGEX=0
    fi"

    #shellcheck disable=SC3044
    if type typeset >/dev/null; then
        SHELL_SUPPORT_TYPESET=1
    else
        SHELL_SUPPORT_TYPESET=0
    fi

    if [ -n "$ZSH_VERSION" ]; then
    #https://zsh.sourceforge.io/FAQ/zshfaq03.html
       setopt shwordsplit  #zsh compability for "1 2 3" -> split in 1 2 3
    fi

    case "$(type printf)" in 
        
        *builtin) #mksh does not have printf bulitin -> printf calls clone a new process -> reduced performance -> prefer echo over printf unless formatting is absolutely required
            
            SHELL_SUPPORT_PRINTF=1 

            #storing value in variable from printf
            #shellcheck disable=SC3045
            if printf -v SHELL_SUPPORT_PRINTF_VOPT "%s" "-v" 1>/dev/null 2>/dev/null && [ "$SHELL_SUPPORT_PRINTF_VOPT" = '-v' ]; then
              SHELL_SUPPORT_PRINTF_VOPT=1
            else
              SHELL_SUPPORT_PRINTF_VOPT=0
            fi

            ;;
        
        *)
            #shellcheck disable=SC2034
            SHELL_SUPPORT_PRINTF=0
            ;;
    esac

   #shellcheck disable=SC2034,SC3019
  # I=$(( 10 ** 1 )) 2>/dev/null;
  #dash shell exit with: arithmetic expression: expecting primary: " 10 ** 1 "
    
    if [ -n "$BASH_VERSION" ] || [ -n "$ZSH_VERSION" ]; then
      SHELL_SUPPORT_MATH_POWER=1
    else
      SHELL_SUPPORT_MATH_POWER=0 #probably
    fi
    
    #https://stackoverflow.com/questions/602912/how-do-you-echo-a-4-digit-unicode-character-in-bash/602924#602924

    if [ "$SHELL_SUPPORT_PRINTF_VOPT" -eq 1 ]; then
    #shellcheck disable=SC3045
      printf -v unicode "▃"
      UNICODE_LENGTH=${#unicode}
    else
      # UNICODE_LENGTH=$(printf "\u2620" | { read -r unicode; printf "%d" ${#unicode}; })
      UNICODE_LENGTH=$(printf "▃" | { read -r unicode; printf "%d" ${#unicode}; })
    fi
     
    if [ "$UNICODE_LENGTH" = "1" ] || [ "$UNICODE_LENGTH" = 3 ]; then #dash/mksh -3, zsh/bash/ksh = 1
      SHELL_SUPPORT_UNICODE=1
    else
      SHELL_SUPPORT_UNICODE=0
    fi

    unset UNICODE_LENGTH

    #TEST unciode: i=$(( 0x2500 )); while [ "$i" -le $(( 0x2600 )) ]; do printf -v hex "%x" "$i"; eval 'printf "%s \u$hex\n" "$hex"'; i=$(( i + 1 )); done

#https://www.gnu.org/software/gettext/manual/html_node/The-TERM-variable.html
#https://www.gnu.org/software/gettext/libtextstyle/manual/html_node/The-NO_005fCOLOR-variable.html
# TEST : msgcat --color=test
    [ "$DEBUG" -eq 1 ] && >&2 echo TERM "$TERM"

    if [ -n "$NO_COLOR" ]; then
      TERM_ANSI_ESCAPE=0
    else
        case "$TERM" in
            *color) TERM_ANSI_ESCAPE=1
                    ;;
            *)      TERM_ANSI_ESCAPE=0
                    ;;
        esac
    fi
}

printWeatherServices () {
    sendPacket $CMD_READ_ECOWITT_INTERVAL
    sendPacket $CMD_READ_WUNDERGROUND
    sendPacket $CMD_READ_WOW
    sendPacket $CMD_READ_WEATHERCLOUD
    sendPacket $CMD_READ_CUSTOMIZED
}

getFloatAsIntDecmial()
#$1 - floating point number
#get int and decimal porition; int.decimals
#assumes always . present in $1
{
   if [ "$SHELL_SUPPORT_TYPESET" -eq 1  ]; then
    #shellcheck disable=SC3044
       typeset n
    else
       local n
    fi

    FLOAT_INT=${1%%.*}
    FLOAT_DECIMALS=${1#*.}
    FLOAT_SCALE10=${#FLOAT_DECIMALS}
    if [ "$FLOAT_INT" = 0 ]; then # we have a number 0.???
      while [ ${#FLOAT_DECIMALS} -gt 1 ]; do # removes leadning zeros, otherwise number is intepreted as  octal
        case "$FLOAT_DECIMALS" in
                0*) FLOAT_DECIMALS=${FLOAT_DECIMALS#0} # removes zeros after .
                    true
                    ;;
                *) break # this while loop
                   false
                   ;;
        esac
      done
      FLOAT_AS_INT=$FLOAT_DECIMALS
    else
      FLOAT_AS_INT=$FLOAT_INT$FLOAT_DECIMALS
    fi

    if [ "$SHELL_SUPPORT_MATH_POWER" -eq 1 ]; then
      #shellcheck disable=SC3019
      CONVERT_10MULTIPLIER=$(( 10 ** FLOAT_SCALE10))
    else
        n=2
        CONVERT_10MULTIPLIER=10
        while [ "$n" -le "$FLOAT_SCALE10" ]; do # power of 10 
            CONVERT_10MULTIPLIER=$(( CONVERT_10MULTIPLIER * 10))
            n=$(( n + 1 ))
        done
    fi

    if [ -n "$KSH_VERSION" ]; then
      unset n
    fi
}

convertFarenheitToCelciusScale10()
#tempinf=72.7
#$2 - number of digits after . -> using power to scale value
{
   
   # VALUE_CELCIUS_SCALE10=$(printf %.0f "$(echo "($1 - 32 )*50/9" | bc)")
   getFloatAsIntDecmial "$1"
   
   VALUE_CELCIUS_SCALE10=$(( (FLOAT_AS_INT - 32*CONVERT_10MULTIPLIER) * 50 / (9*CONVERT_10MULTIPLIER) ))

}

convertCelciusToFarenheitScale10()
{
   # VALUE_CELCIUS_SCALE10=$(printf %.0f "$(echo "($1 - 32 )*50/9" | bc)")
   getFloatAsIntDecmial "$1"
   
   VALUE_FARENHEIT_SCALE10=$(( (FLOAT_AS_INT*9/5) + 32*CONVERT_10MULTIPLIER ))
}

convertCelciusScale10ToFarenheitScale10()
{
   VALUE_FARENHEIT_SCALE10=$(( ($1*9/5) + 320 ))
}

convertInHgToHpa()
#convert from inhg to hpa
#baromrelin=29.731 -> 3 decimals -> multiply by 1000 = 29731
#assumes always 3 decimals after .
#some info: http://justinparrtech.com/JustinParr-Tech/programming-tip-turn-floating-point-operations-in-to-integer-operations/
#https://en.wikipedia.org/wiki/Inch_of_mercury
#using: SI unit 1 inHg = 3.38639 kPa
{
       # VALUE_INHG_HPA_SCALE10=$(printf %.0f "$(echo "338.639 * $1" | bc)")

   getFloatAsIntDecmial "$1"

   case "$KSH_VERSION" in 
         *MIRBSD?KSH*)
            # maybe use $((# )) for 32-bit usigned int expression
             VALUE_INHG_HPA_SCALE10=$(( (33864 * FLOAT_AS_INT)/ 10000)) # round conversion constant/scale down 10 -> 33864
             ;;
         *)
            #does not work with 32-bit unsigned integer arithmetic as used by mksh with $((# ... ))
             VALUE_INHG_HPA_SCALE10=$(( (338639 * FLOAT_AS_INT) / 100000)) # use interger arithmetic
             ;;
    esac
   
   round "$VALUE_INHG_HPA_SCALE10"
   VALUE_INHG_HPA_SCALE10=$VALUE_ROUND
}

convertHpaScale10ToInHgScale10()
#using: SI unit 1 inHg = 3.38639 kPa
{
   round $(( $1 * 100000 / 338639 ))
   VALUE_INHG_SCALE10=$VALUE_ROUND
}

round()
{
 if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset modulo
    else
        local modulo
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo "round $1"

    modulo=$(( $1 % 10 ))
    if [ $modulo -ge 5 ]; then
        VALUE_ROUND=$(( $1 + 10 - modulo )) # round up
    else
        VALUE_ROUND=$(( $1 - modulo )) #round down
    fi

   VALUE_ROUND=$(( VALUE_ROUND / 10 ))

    if [ -n "$KSH_VERSION" ]; then
    unset modulo
    fi
}

convertMphTMps()
# https://www.convertunits.com/from/mph/to/m/s
# 1 mph is equal to 0.44704 meter/second.
# format: speedmph=5.82&windgustmph=10.29&maxdailygust=15.88 -> 2 digits after .
#using International mile: using scaling 63360/141732 
{
   #VALUE_MPH_MPS_SCALE10=$(printf %.0f "$(echo "4.4704 * $1" | bc)")
  
   getFloatAsIntDecmial "$1"
#   VALUE_MPH_MPS_SCALE10=$(( 44704 * $FLOAT_INT${FLOAT_DECIMALS}/ 100000)) 
    
    VALUE_MPH_MPS_SCALE10=$(( 63360 * FLOAT_AS_INT/ 141732)) 
  
  round "$VALUE_MPH_MPS_SCALE10"
  VALUE_MPH_MPS_SCALE10=$VALUE_ROUND
}

convertInTomm()
#1 inch SI unit = 25.4 mm
#https://en.wikipedia.org/wiki/Inch
# web format: rainratein=0.000&eventrainin=0.669&hourlyrainin=0.000&dailyrainin=0.028&weeklyrainin=0.831&monthlyrainin=0.972&yearlyrainin=17.130&totalrainin=17.130
{
   getFloatAsIntDecmial "$1"

   VALUE_IN_MM_SCALE10=$(( 254 * FLOAT_AS_INT / 100))
   round $VALUE_IN_MM_SCALE10
   VALUE_IN_MM_SCALE10=$VALUE_ROUND
}

setRainHttpLivedata()
#$1 - field name
#$2 - value
{
    convertInTomm "$2"
    eval "$1"_RAW=$VALUE_IN_MM_SCALE10
    if [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
        convertScale10ToFloat "$VALUE_IN_MM_SCALE10"
        eval "$1"=$VALUE_SCALE10_FLOAT
    elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
        eval "$1"="$2"
    fi
}

setWindHttpLivedata()
{
     if [ "$2" = $WUNDERGROUND_UNDEFINED_VALUE ]; then
      return
    fi

    convertMphTMps "$2"
    eval "$1"_RAW=$VALUE_MPH_MPS_SCALE10
    if [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPS ]; then
       convertScale10ToFloat "$VALUE_MPH_MPS_SCALE10"
       eval "$1"=$VALUE_SCALE10_FLOAT
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPH ]; then
       eval "$1"="$2"
    fi
}

setWindDirHttpLivedata()
{
    if [ "$2" = $WUNDERGROUND_UNDEFINED_VALUE ]; then
      return
    fi
 
    eval "$1"="$2" 
    convertWindDirectionToCompassDirection "$2"
    eval "$1"_COMPASS=$VALUE_COMPASS_DIRECTION

}

setTemperatureHttpLivedata()
{
    #skip undefined value -9999
    if [ "$2" = $WUNDERGROUND_UNDEFINED_VALUE ]; then
      return
    fi

    convertFarenheitToCelciusScale10 "$2" 
    eval "$1"_RAW=$VALUE_CELCIUS_SCALE10
    if [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_CELCIUS ]; then
        convertScale10ToFloat "$VALUE_CELCIUS_SCALE10"
        eval "$1"=$VALUE_SCALE10_FLOAT
    elif [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_FARENHEIT ]; then
        eval "$1"="$2"
    fi
}

setPressureHttpLivedata()
{
    convertInHgToHpa "$2"
    eval "$1"_RAW="$VALUE_INHG_HPA_SCALE10"
    if [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
        convertScale10ToFloat "$VALUE_INHG_HPA_SCALE10"
        eval "$1"=$VALUE_SCALE10_FLOAT
    elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
        eval "$1"="$2"
    fi
}

parseEcowittHttpRequest()
#$1 - http message
{
   if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
       typeset http_body f value key
   else
       local http_body f value key
   fi

    http_body=$(echo "$1" | tail -n +7) # just skip headers -n +7
    IFS='&'
    
    for f in $http_body; do
        
        value=${f##*=}
        key=${f%%=*}
        
        if [ "$key" = PASSKEY ]; then
            continue
        fi

        case "$key" in

            tempinf)
                   setTemperatureHttpLivedata LIVEDATA_INTEMP "$value" 
                  
                ;;

            tempf)
                    setTemperatureHttpLivedata LIVEDATA_OUTTEMP "$value"
                ;;

            humidityin)

                LIVEDATA_INHUMI=$value
                ;;

            humidity)
                
                    LIVEDATA_OUTHUMI=$value
                ;;

            baromrelin)
                
                setPressureHttpLivedata LIVEDATA_RELBARO "$value"
                ;;

            baromabsin)

                setPressureHttpLivedata LIVEDATA_ABSBARO "$value"
                    ;;

            temp?f)
            
                channel=${key##temp}
                channel=${channel%f}
                setTemperatureHttpLivedata LIVEDATA_TEMP"$channel" "$value" 
                ;;

            humidity?)

                channel=${key##humidity}
                eval LIVEDATA_HUMI"$channel"="$value"
                ;;
            
            winddir)

                    setWindDirHttpLivedata LIVEDATA_WINDDIRECTION "$value"
                ;;

            windspeedmph)

                setWindHttpLivedata LIVEDATA_WINDSPEED "$value"
                ;;

            windgustmph)

                setWindHttpLivedata LIVEDATA_WINDGUSTSPEED "$value"
                ;;

            maxdailygust)

                setWindHttpLivedata LIVEDATA_WINDDAILYMAX "$value"
                ;;
        
            rainratein)

                setRainHttpLivedata LIVEDATA_RAINRATE "$value"
                ;;

            eventrainin)

                setRainHttpLivedata LIVEDATA_RAINEVENT "$value"
                ;;

                hourlyrainin)

                setRainHttpLivedata LIVEDATA_RAINHOUR "$value"
                ;;

                dailyrainin)

                setRainHttpLivedata LIVEDATA_RAINDAY "$value"
                ;;

            weeklyrainin)

                setRainHttpLivedata LIVEDATA_RAINWEEK "$value"
                ;;

            monthlyrainin)
                
                setRainHttpLivedata LIVEDATA_RAINMONTH "$value"
                ;;

            yearlyrainin)

                setRainHttpLivedata LIVEDATA_RAINYEAR "$value"
                ;;

            soilmoisture?)

                channel=${key##soilmoisture}
                eval LIVEDATA_SOILMOISTURE"$channel"="$value"
            ;;

            pm25_ch?)

                channel=${key##pm25_ch}
                eval LIVEDATA_PM25_CH"$channel"="$value"
                ;;

            pm25_avg_24h_ch?)

                channel=${key##pm25_avg_24h_ch}
                eval LIVEDATA_PM25_24HAVG"$channel"="$value"
                ;;

            leak_ch?)

                channel=${key##leak_ch}
                eval "LIVEDATA_LEAK_CH$channel=$value"
                ;;

            solarradiation)
            
                   LIVEDATA_UV=$value
                ;;

            uv)
                    LIVEDATA_UVI=$value
                ;;


            wh65batt)

                getBatteryLowOrNormal "$value"
                LIVEDATA_WH65_BATTERY=$value
                LIVEDATA_WH65_BATTERY_STATE=$SBATTERY_STATE
                ;;

            batt?)

                channel=${key##batt}
                getBatteryLowOrNormal "$value"
                eval "LIVEDATA_TEMP${channel}_BATTERY=$value"
                eval "LIVEDATA_TEMP${channel}_BATTERY_STATE=$SBATTERY_STATE"
                ;;

            pm25batt?)
            
                channel=${key##pm25batt}
                getBatteryLevelState "$value"
                eval "LIVEDATA_PM25_CH${channel}_BATTERY=$value"
                eval "LIVEDATA_PM25_CH${channel}_BATTERY_STATE=$SBATTERY_STATE"
                ;;

            soilbatt?)

                channel=${key##soilbatt}
                getFloatAsIntDecmial "$value"
                getBatteryVoltageLevelState "$FLOAT_AS_INT"
                
                eval "LIVEDATA_SOILMOISTURE_CH${channel}_BATTERY_RAW=$FLOAT_AS_INT"  
                eval "LIVEDATA_SOILMOISTURE_CH${channel}_BATTERY=$value"
                eval "LIVEDATA_SOILMOISTURE_CH${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""  
                ;;

            leakbatt?)
                
                channel=${key##leakbatt}
                getBatteryLevelState "$value"
                eval "LIVEDATA_LEAK_CH${channel}_BATTERY=$value"
                eval "LIVEDATA_LEAK_CH${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
                ;;

            stationtype)

                LIVEDATA_SYSTEM_VERSION=$value
                ;;

            dateutc)
            
                IFS=+
                #shellcheck disable=SC2086
                set -- $value
                
                LIVEDATA_SYSTEM_UTC="$1 $2"
                ;;

            freq)

                IFS="M"
                #shellcheck disable=SC2086
                set -- $value
                LIVEDATA_SYSTEM_FREQUENCY=$1" MHz"
                ;;
                
        esac
    done

    printLivedata

    if [ -n "$KSH_VERSION" ]; then
       unset http_body f key value
    fi

}

parseWundergroundHttpRequest()
{

   if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
       typeset http_body f value key
   else
       local http_body f value key
   fi

      #https://www.w3.org/Protocols/HTTP/1.0/spec.html#Request

    http_body=$(echo "$1" | head -n 1)
    http_body=${http_body##GET*ID=} # remove method GET and directory prefix, assume qs always starts with ID=
    http_body=${http_body%% HTTP*} # remove HTTP/1.0 at end
    http_body="ID="$http_body

    IFS='&'
    for f in $http_body; do
    
        value=${f##*=}
        key=${f%%=*}
    
        if [ "$key" = PASSWORD ] || [  "$key" = ID ]; then
            continue
        fi
            #password is url encoded, for example space=%20 https://stackoverflow.com/questions/6250698/how-to-decode-url-encoded-string-in-shell
        #TEST echo "$key=$value"

    #https://support.weather.com/s/article/PWS-Upload-Protocol?language=en_US
        case "$key" in

            tempf)
                
                setTemperatureHttpLivedata LIVEDATA_OUTTEMP "$value"
                ;;

            dewptf)
               setTemperatureHttpLivedata LIVEDATA_DEWPOINT "$value"
               ;;
            
            windchillf)
              setTemperatureHttpLivedata LIVEDATA_WINDCHILL "$value"
              ;;
            
            humidity)
                if [ "$value" != $WUNDERGROUND_UNDEFINED_VALUE ]; then
                  LIVEDATA_OUTHUMI=$value
                fi
                ;;

            indoortempf)

                setTemperatureHttpLivedata LIVEDATA_INTEMP "$value"
                ;;
            
            indoorhumidity)

                LIVEDATA_INHUMI=$value
                ;;
            
            baromin)
                
                setPressureHttpLivedata LIVEDATA_RELBARO "$value"
                ;;

            rainin)
                #or pr hour?
                setRainHttpLivedata LIVEDATA_RAINRATE "$value"
                ;;

            dailyrainin)

                setRainHttpLivedata LIVEDATA_RAINDAY "$value"
                ;;

            weeklyrainin)

                setRainHttpLivedata LIVEDATA_RAINWEEK "$value"
                ;;

            monthlyrainin)

                setRainHttpLivedata LIVEDATA_RAINMONTH "$value"
                ;;

            yearlyrainin)

                setRainHttpLivedata LIVEDATA_RAINYEAR "$value"
                ;;

            winddir)

                setWindDirHttpLivedata LIVEDATA_WINDDIRECTION "$value"

                ;;

            windspeedmph)

                setWindHttpLivedata LIVEDATA_WINDSPEED "$value"
                ;;

            windgustmph)

                setWindHttpLivedata LIVEDATA_WINDGUSTSPEED "$value"
                ;;

            solarradiation)
                
                 if [ "$value" != $WUNDERGROUND_UNDEFINED_VALUE ]; then
                   LIVEDATA_UV=$value
                fi
                ;;

            UV)
               
                 if [ "$value" != $WUNDERGROUND_UNDEFINED_VALUE ]; then
                     LIVEDATA_UVI=$value
                 fi
                ;;

            AqPM2\.5)
                #shellcheck disable=SC2034
                LIVEDATA_PM25_CH1="$value"
                ;;

            soilmoisture)
                #shellcheck disable=SC2034
                LIVEDATA_SOILMOISTURE1="$value"
                ;;

            soilmoisture?)

                channel=${key##soilmoisture}
                eval LIVEDATA_SOILMOISTURE"$channel"="$value"
                ;;

            softwaretype)

               LIVEDATA_SYSTEM_VERSION=$value
               ;;

        esac
    done

    printLivedata

    if [ -n "$KSH_VERSION" ]; then
       unset http_body f key value
    fi

}

httpServer()
#$1 - port number 
{
    EXITCODE_HTTPSERVER=0

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
      #shellcheck disable=SC3044
      typeset http_message
    else
      local http_message
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo Listening on port "$1"

    if [ $NC_VERSION -eq $NC_NMAP ]; then 
        http_message=$( nc -l -i 0.1 "$1" 2>/dev/null) # - idle timeout to exit early, not waiting for server to close/FIN
        if [ $? -eq 2 ]; then
          EXITCODE_HTTPSERVER=0 # 2 exit from nc when idle timeout expires (Ncat: Idle timeout expired (100 ms). QUITTING.)
        else
          EXITCODE_HTTPSERVER=$?
        fi
    elif [ $NC_VERSION -eq $NC_OPENBSD ]; then
        http_message=$( nc -l -w 1 "$1" 2>/dev/null) # - -w to exit on idle for 1s
        EXITCODE_HTTPSERVER=$?
    elif [ $NC_VERSION -eq $NC_TOYBOX ]; then 
        http_message=$( nc -p "$1" -W 1 -l  2>/dev/null) # - -W to exit on idle for 1s
        EXITCODE_HTTPSERVER=$?
    else
        echo >&2 Error unsupported listen for nc version "$NC_VERSION"
        EXITCODE_HTTPSERVER=$ERROR_LISTEN_UNSUPPORTED_NC
    fi

    if [ -z "$http_message" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Empty http message from nc
        return $ERROR_HTTP_MESSSAGE_EMPTY
    fi

    if [ -n "$OPTION_SHOW_HTTP_REQUEST" ]; then
        if  [ "$OPTION_SHOW_HTTP_REQUEST" -eq 1  ] ; then
        echo >&2 "$http_message"
        fi
    fi
    
    case "$http_message" in
        
        POST*)  parseEcowittHttpRequest "$http_message"
                
                #https://stackoverflow.com/a/69836872/2076536
                ;;
        
        GET*)   parseWundergroundHttpRequest "$http_message"
                #cd /tmp/gw/wunderground; watch -n 16 'for f in *; do read v < "$f"; printf "%-30s %s\n" "$f" "$v"; done'
                ;;
    esac

    if [ -n "$KSH_VERSION" ]; then
      unset http_message
    fi

    return $EXITCODE_HTTPSERVER
}

cleanup()
{
   
   if [ -n "$LOG_LIVEDATA" ]; then
        #2>/dev/null exec 1>&6 6>&- #copy backup fd 6 to stdout 1 and close 6 (may get "Bad file descriptor if 6 is not redirected")
        rm "$DIR_LIVEDATA"/* #dont use "*" otherwise pathname/globbing expansion doesnt work
   fi

    exit
}

initTrap()
{
    trap cleanup INT TERM #ctrl-c pressed by user, or TERM sent default by kill when script in background doing livedata logging 
}

#read -r -u 0 -t 0 STDIN

#if [ -n "$STDIN" ]; then
#  echo STDIN "$STDIN"
:
#maybe parse packet if gw used as filter echo hex dump | gw

#fi

initUnit()
{
    if [ -z "$UNIT_TEMPERATURE_MODE" ]; then 
        setTemperatureMode $UNIT_TEMPERATURE_CELCIUS # default
    else
       setTemperatureMode "$UNIT_TEMPERATURE_MODE"
    fi

   if [ -z "$UNIT_PRESSURE_MODE" ]; then
        setPressureMode $UNIT_PRESSURE_HPA # default
   else
      setPressureMode "$UNIT_PRESSURE_MODE"
   fi

   if [ -z "$UNIT_RAIN_MODE" ]; then 
        setRainMode $UNIT_RAIN_MM #default
   else
      setRainMode "$UNIT_RAIN_MODE"
   fi
   
   if [ -z "$UNIT_WIND_MODE" ]; then 
     setWindMode $UNIT_WIND_MPS #default
   else
      setWindMode "$UNIT_RAIN_MODE"
   fi
}

parseUnitOptions()
#format: temp=farenheit|celius,pressure=inhg|hpa
{
    IFS=,
    for f in $1; do
        IFS='='
        set -- $f
        case "$1" in
            temperature|t) case "$2" in 

                             celcius|c)    setTemperatureMode $UNIT_TEMPERATURE_CELCIUS 
                                            ;;
                             farenheit|f)   setTemperatureMode $UNIT_TEMPERATURE_FARENHEIT 
                                            ;;
                             *)             echo >&2 Warning: Unknown temperature mode "$2", use "celcius|c,farenheit|f" 
                                            ;;
                            esac
                            ;;

            pressure|p)     case "$2" in
                                inhg|i)     setPressureMode $UNIT_PRESSURE_INHG 
                                            ;;
                                hpa|h)      setPressureMode $UNIT_PRESSURE_HPA 
                                            ;;
                                *)          echo >&2 Warning: Unknown pressure mode "$2", use "inhg|i,hpa|h" 
                                            ;;
                            esac
                            ;;
                    
                    *)      echo >&2 Warning: Unknown mode "$1", use "temperature|t,pressure|p" 
                            ;;
        esac
    done
}

initShell
initcoptCommands
initConfigDir
initTrap
if ! initnc; then
    echo >&2 Error nc/ncat not found
    exit "$ERROR_DEPENDENCY_NC"
fi
#initLivedataFieldDescriptionRenaming
initTimezones

initUnit

#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
#useful CLI info: https://clig.dev/#arguments-and-flags

while [ $# -gt 0 ]; do

    EXITCODE_MAIN=0

    KEY="$1"

    case $KEY in

       -A | --livedata-language)

           if [ -n "$2" ] && [ -s "$2" ]; then
              . "$2"
           fi

           shift 2

           ;;

       -L  | --log-livedata)
          LOG_LIVEDATA=1

           #FD_STDOUT_DUP=6 # used for backup of stdout when doing exec redirection to /dev/null 
           # exec 6>&1 #backup stdout fd
           # exec >/dev/null #redirect stdout to /dev/null

            #exec 1>&"$FD_STDOUT_DUP" "$FD_STDOUT_DUP">&-

          if ! argEmptyOrOption "$2"; then
            LOG_LIVEDATA_INTERVAL="$2"
            shift 2
          else
            LOG_LIVEDATA_INTERVAL=5
            shift
          fi
          
          #[ "$DEBUG" -eq 1 ] && 
          echo >&2 Logging livedata to "$DIR_LIVEDATA"

          ;;

      
        -W | --show-ws)
            
            printWeatherServices
            shift
            ;;

        -c | --command)

            toLowercase "$2"
            COMMAND=$LOWERCASE

            shift 1 # remove -c

            processCommand "$@"
            EXITCODE_MAIN=$?

            for param in "$@"; do #remove params to command (until new - option)

                case "$param" in

                -*)
                    break
                    ;;

                *)
                    [ $DEBUG -eq 1 ] && echo >&2 Shift param "$@" "$param"
                    shift
                    ;;
                esac

            done

            unset COMMAND param
            ;;
        
        -u | --unit)
               
               if argEmptyOrOption "$2"; then
                 echo >&2 "Warning: no arguments specified for unit, for example temp=farenheit|celcius"
                 shift # ignore
               else
                 parseUnitOptions "$2"
                 shift 2 
               fi
              ;;

        -d | --debug)

            DEBUG=1
            #DEBUG_OPTIONS_nc="-v"
            shift
            ;;

        -dB | --show-buffer)
            DEBUG_SHOW_OD_BUFFER=1 # show hex buffers of transmitted/received data
            shift
            ;;

        -dC | --show-command) #echo command printf/nc/od pipeline
             OPTION_SHOW_COMMAND=1
             shift 
             ;;

        -dH | --show-http) #show http request when listening 
              OPTION_SHOW_HTTP_REQUEST=1
              shift
              ;;

        -f | --firmware)
            HTTP_UA_NAME="gw $(uname -srv)"
            HTTP_FIRMWARE="http://download.ecowitt.net/down/filewave?v=FirwaveReadme.txt"
            [ $DEBUG -eq 1 ] && printf >&2 "%s\n%s" "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
            curl --silent --show-error --user-agent "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
            shift 2
            ;;

        -g | --gw)

            C_host="$2"
            #sendPacket "$CMD_READ_MAC" >/dev/null
            sendPacket "$CMD_READ_VERSION" >/dev/null
            sendPacket "$CMD_READ_SYSTEM" >/dev/null # find sensor type WH65/WH24 - &> redirect stderr+stdout - read_system not available on EasyWeather
            sendPacket "$CMD_READ_SENSOR_ID_NEW" >/dev/null

            shift 2
            ;;

        -l | --listen)
            #WSL2
            #open TCP 8080 in windows firewall -> add rule to open
            #add portproxy from hostos to WSL2 distro/ubuntu
            #netsh interface portproxy add v4tov4 listenport=8080 listenaddress=192.168.3.3 connectaddress=172.22.134.109 connectport=8080
            # iex "netsh interface portproxy add v4tov4 listenport=8080 listenaddress=(Get-NetIPAddress -InterfaceAlias Wi-Fi -AddressFamily IPv4).IPAddress connectaddress=$(wsl -e hostname -I) connectport=8080"
            # iex = invoke-expression cmdlet
            #https://github.com/microsoft/WSL/issues/4150#issuecomment-504209723
            
            # Wunderground
            #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
            # Ecowitt
            #PASSKEY=976D09F15C.....................7&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro

            if argEmptyOrOption "$2"; then
                >&2 echo No port specified for listen
                EXITCODE_MAIN=$ERROR_LISTEN_NOPORT
                shift 
                continue #process next option
            elif ! isNumber "$2"; then
               >&2 echo Not a valid port number
               EXITCODE_MAIN=$ERROR_LISTEN_INVALID_PORTNUMBER
               shift; continue
            fi

            setUVMode $UNIT_UV_WATTM2

            if [ -z "$LOG_LIVEDATA" ]; then
               httpServer "$2"
               EXITCODE_MAIN=$?
            else
               while true; do
                  if ! httpServer "$2"; then
                    EXITCODE_MAIN=$?
                    break
                  fi
                done
            fi 

            shift 2

        ;;
   
        -s | --scan)

            if argEmptyOrOption "$2"; then
                discovery
                shift 1
            else
                discovery "$2"
                shift 2
            fi

            ;;

        -t | --timezones)
            printTimezones
            ;;

        -w | --wifi)

            newPacketBody $CMD_WRITE_SSID
            #ssid packet has two byte length
            # TEST wsview android app, wireshark: ffff | 11 |001b| 08536b6f676c756e640d6c756775626572313934322d2e | a9
            #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/ConfigrouterFragment.java - SaveData
            writeString "$2" # ssid
            writeString "$3" # password
            sendPacket

            shift 3
            ;;

        -E | --ansi-escape-disable)
           
           TERM_ANSI_ESCAPE=0
           shift
           ;;


        *)        # unknown option
            shift # past argument
            ;;
    esac

done

#typeset +f - list all function names/ksh93
#set # list all variables

[ "$DEBUG" -eq 1 ] && echo >&2 Exit code $EXITCODE_MAIN

exit $EXITCODE_MAIN
