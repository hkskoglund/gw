#!/bin/sh
# Shell/terminal utility for viewing weather data and sensor configuration of the GW-1000 or compatible devices
# Supports binary and http Ecowitt/Wunderground protocol
# Only for firmware v1.6.5 or later - for intepretation of battery levels/sensor id new command

GWDIR=${GWDIR:="."}

. $GWDIR/lib/constants.sh
. $GWDIR/lib/sensortype.sh
. $GWDIR/lib/error.sh
. $GWDIR/lib/util.sh
. $GWDIR/lib/command.sh
. $GWDIR/lib/appendBuffer.sh
. $GWDIR/lib/buffer.sh
. $GWDIR/lib/binary.sh
. $GWDIR/lib/http.sh
. $GWDIR/lib/packet.sh
. $GWDIR/lib/converters.sh
. $GWDIR/lib/timezone.sh
. $GWDIR/lib/mode.sh
. $GWDIR/lib/fullwidth-number.sh
. $GWDIR/lib/limits.sh
. $GWDIR/lib/livedata-header.sh
. $GWDIR/lib/wind.sh
. $GWDIR/view/livedata.sh

initShell() {
    #shellcheck disable=SC3010,SC2050
    eval "if 2>/dev/null 1>/dev/null type '[['  && 2>/dev/null [[ a =~ a ]] ; then
        SHELL_SUPPORT_TILDE_REGEX=1
    else
        SHELL_SUPPORT_TILDE_REGEX=0
    fi"

    #shellcheck disable=SC3044
    if type typeset >/dev/null; then
        export SHELL_SUPPORT_TYPESET=1 # allows function in subprocess/ui-view to access it
    else
        export SHELL_SUPPORT_TYPESET=0
    fi

    if [ -n "$ZSH_VERSION" ]; then
    #https://zsh.sourceforge.io/FAQ/zshfaq03.html
       setopt shwordsplit  #zsh compability for "1 2 3" -> split in 1 2 3
    fi

    if [ -n "$BASH_VERSION" ]; then
        #shellcheck disable=SC3045
        type_res=$(type -t printf) # otherwise language translation
    else
        type_res=$(type printf)
    fi

    case "$type_res" in 
        
        *builtin) #mksh does not have printf bulitin -> printf calls clone a new process -> reduced performance -> prefer echo over printf unless formatting is absolutely required
            
            SHELL_SUPPORT_BULTIN_PRINTF=1 
              #storing value in variable from printf
            #shellcheck disable=SC3045
            if printf -v SHELL_SUPPORT_BULTIN_PRINTF_VOPT "%s" "-v" 1>/dev/null 2>/dev/null && [ "$SHELL_SUPPORT_BULTIN_PRINTF_VOPT" = '-v' ]; then
                SHELL_SUPPORT_BULTIN_PRINTF_VOPT=1
            else
                SHELL_SUPPORT_BULTIN_PRINTF_VOPT=0
            fi
        ;;
        
        *is*)
            #shellcheck disable=SC2034
            SHELL_SUPPORT_BULTIN_PRINTF=0
            ;;
    esac

     test_printf_sformat #only zsh bultin printf works with unicode when using %-30s format -> workaround \r\t\t\t\t positioning instead which works with every shell printf
     
   #shellcheck disable=SC2034,SC3019
  # I=$(( 10 ** 1 )) 2>/dev/null;
  #dash shell exit with: arithmetic expression: expecting primary: " 10 ** 1 "
    
    if [ -n "$BASH_VERSION" ] || [ -n "$ZSH_VERSION" ] || [ "$KSH_VERSION" = "Version AJM 93u+ 2012-08-01" ]; then
      SHELL_SUPPORT_MATH_POWER=1
      [ -z "$BASH_VERSION" ] && SHELL_SUPPORT_FLOATINGPOINT=1 || SHELL_SUPPORT_FLOATINGPOINT=0 #set 0 for bash
    else
      SHELL_SUPPORT_MATH_POWER=0 #probably
      SHELL_SUPPORT_FLOATINGPOINT=0 #probably
    fi
    
    #https://stackoverflow.com/questions/602912/how-do-you-echo-a-4-digit-unicode-character-in-bash/602924#602924

    SHELL_SUPPORT_UNICODE=1 # assume shell supports unicode
   
     [ "$DEBUG" -eq 1 ] && >&2 echo Shell support unicode "$SHELL_SUPPORT_UNICODE"

    #TEST unciode: i=$(( 0x2500 )); while [ "$i" -le $(( 0x2600 )) ]; do printf -v hex "%x" "$i"; eval 'printf "%s \u$hex\n" "$hex"'; i=$(( i + 1 )); done
    
#https://www.gnu.org/software/gettext/manual/html_node/The-TERM-variable.html
#https://www.gnu.org/software/gettext/libtextstyle/manual/html_node/The-NO_005fCOLOR-variable.html
# TEST : msgcat --color=test
    [ "$DEBUG" -eq 1 ] && >&2 echo TERM "$TERM" NO_COLOR "$NO_COLOR"

    if [ -z "$NO_COLOR" ]; then
        case "$TERM" in
            *color)
                    # shellcheck source=./style/ansiesc.sh
                    . "$GWDIR/style/ansiesc.sh"
                    ;;
        esac
    fi
    
   if ! SHELL_DECIMAL_POINT=$(locale decimal_point) 2>/dev/null; then
      SHELL_DECIMAL_POINT="."
   fi
    
    unset type_res
   
}

initTerm()
{
    
    #https://stackoverflow.com/questions/1780483/lines-and-columns-environmental-variables-lost-in-a-script
    if [ -n "$COLUMNS" ] && [ -n "$LINES" ]; then
        TERM_COLUMNS=$COLUMNS
        TERM_LINES=$LINES
    elif type stty >/dev/null; then
      size=$(stty size)
      TERM_LINES=${size% *}
      TERM_COLUMNS=${size#* }
    elif type tput >/dev/null; then
       #shellcheck disable=SC2034
       {
       TERM_LINES=$(tput lines)
       TERM_COLUMNS=$(tput cols)
       }
    fi

    unset size

}

initnc() 
#different versions of nc use slightly different options
{
    EXITCODE_INITNC=0

    DEBUG_FUNC="initnc"
    DEBUG_INITNC=${DEBUG_INITNC:=$DEBUG}
   
   #if force nc version on command line NC_VERSION=? ./gw ...
    if [ -n "$NC_VERSION" ]; then
        
        #specifying override path to nc executable is possible: NC_CMD='/path/nc' ./gw ...
        if [ "$NC_VERSION" = $NC_NMAP ]; then
            [ -z "$NC_CMD" ] && NC_CMD=$(which ncat)
        elif [ "$NC_VERSION" = $NC_OPENBSD ]; then
            [ -z "$NC_CMD" ] && NC_CMD=$(which nc)
        elif [ "$NC_VERSION" = $NC_BUSYBOX ]; then
            [ -z "$NC_CMD" ] && NC_CMD="$(which busybox) nc"
        elif [ "$NC_VERSION" = $NC_TOYBOX ]; then
            [ -z "$NC_CMD" ] && NC_CMD="$(which toybox) nc"
        else
            EXITCODE_INITNC=$ERROR_DEPENDENCY_NC
            return $EXITCODE_INITNC
        fi
       
    else

        NC_CMD="$(which nc 2>/dev/null)"
        if [ -z "$NC_CMD" ]; then
            logErr $DEBUG_INITNC "$DEBUG_FUNC nc not found. Ubuntu: sudo update-alternatives --config nc"
            EXITCODE_INITNC=$ERROR_DEPENDENCY_NC
        else
            # ls -l $(readlink -f /usr/bin/nc)
            case "$(readlink -f "$NC_CMD" 2>&1)" in 
                
                */nc.openbsd|*/netcat) NC_VERSION=$NC_OPENBSD #nc.openbsd Ubuntu/netcat Fedora
                                        ;;
                
                */ncat) NC_VERSION=$NC_NMAP 
                        ;;
                    
                    *)  logErr $DEBUG_INITNC "$DEBUG_FUNC Warning: Failed to determine nc version, not nc openbsd/ncat, use NC_VERSION=, NM_CMD= to override, trying openbsd compability"
                        NC_VERSION=$NC_OPENBSD
                        ;;
            esac

        fi
    fi
        
    logErr $DEBUG_INITNC "$DEBUG_FUNC $NC_VERSION $NC_CMD"
    unset DEBUG_FUNC

    return $EXITCODE_INITNC
}

initTrap()
{
    :
   #some info here: https://unix.stackexchange.com/questions/57940/trap-int-term-exit-really-necessary
   # trap cleanup INT TERM #ctrl-c pressed by user, or TERM sent default by kill when script in background doing livedata logging 
}

cleanup()
{
    :
#   exit
}

initConfigDir() {

  #  DIR_CONFIG=$HOME"/.config/gw"                              # .config subdirectory used for configuration on gnome/linux
    
  #  [ -n "$EXTERNAL_STORAGE" ] && DIR_CONFIG=$EXTERNAL_STORAGE # testing in Android 11 adb shell
  #  DIR_LIVEDATA="$EXTERNAL_STORAGE/tmp/gw/livedata"
  #  [ ! -d "$DIR_CONFIG" ] || [ ! -d "$DIR_LIVEDATA" ]  && mkdir -p -v "$DIR_CONFIG" "$DIR_LIVEDATA"   1>&2
  #  [ "$DEBUG" -eq 1 ] &&  echo >&2 Directory config "$DIR_CONFIG" livedata "$DIR_LIVEDATA"

    #SHELLPID=$$
  :
}

copySystemToLivedata()
#copies system info to UI variables
{
    LIVEDATA_SYSTEM_FREQUENCY=$C_SYSTEM_FREQUENCY_STATE
    LIVEDATA_SYSTEM_SENSORTYPE=$C_SYSTEM_SENSORTYPE_STATE
    LIVEDATA_SYSTEM_UTC=$C_SYSTEM_UTC_STATE #local time 
    LIVEDATA_SYSTEM_TIMEZONE=$C_SYSTEM_TIMEZONE_INDEX_STATE
    LIVEDATA_SYSTEM_TIMEZONE_DST_BIT=$C_SYSTEM_TIMEZONE_DST_BIT
    LIVEDATA_SYSTEM_TIMEZONE_AUTO_BIT=$C_SYSTEM_TIMEZONE_AUTO_BIT
    LIVEDATA_SYSTEM_TIMEZONE_OFFSET_HOURS=$C_SYSTEM_TIMEZONE_OFFSET_HOURS
    LIVEDATA_SYSTEM_HOST=$C_HOST

}

copyVersionToLivedata()
{
    LIVEDATA_SYSTEM_VERSION="$C_VERSION"
}

parseSystemOption()
#format : t=wh65,tz=3,dst=1|on,auto=on|1'
{
    EXITCODE_PARSESYSTEMOPTIONS=0

    #copy current configuration
    systemtype=$C_SYSTEM_SENSORTYPE
    systemtzindex=$C_SYSTEM_TIMEZONE_INDEX
    systemdst=$C_SYSTEM_TIMEZONE_DST_BIT
    systemauto=$C_SYSTEM_TIMEZONE_AUTOOFF_BIT

    IFS=','
    #shellcheck disable=SC2086
    set -- $1
    
    for opt in "$@"; do
      IFS='='
      #shellcheck disable=SC2086
      set -- $opt
      case "$1" in 
        t|type) case "$2" in
                0|wh24)    systemtype=0
                        ;;
                1|wh65)     systemtype=1
                        ;;
                *)  echo >&2 "type=0 | wh24 or 1 | wh65"
                            EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
                            ;;
            esac
            ;;
        tz) if isNumber "$2" && [ "$2" -le "$SYSTEM_TIMEZONE_MAX_INDEX" ]; then
                systemtzindex=$2
            else
                echo >&2 "tz=0-$SYSTEM_TIMEZONE_MAX_INDEX"
                printTimezones
                EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
            fi
            ;;
        dst|d) case "$2" in
                0|off)  systemdst=0
                        ;;
                1|on)   systemdst=1
                        ;;
                *)      echo >&2 "dst=0 | off | 1 | on"
                        EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
                        ;;
                esac
                ;;
        auto|a) case "$2" in
                0|off)  systemauto=0
                        ;;
                1|on)   systemauto=1
                        ;;
                 *)     echo >&2 "auto=0 | off | 1 | on"
                        EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
                        ;;
                esac
                ;; 
            
        *) echo >&2 "Unknown key '$1', use type,tz,dst,auto"
           EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
        ;;
      esac
    done

    if ! sendSystemPacket "$systemtype" "$systemtzindex" "$systemdst" "$systemauto" "$C_HOST"; then
       EXITCODE_PARSESYSTEMOPTIONS=$?
       echo >&2 Error: Failed to send system packet
    fi

    unset IFS opt systemtype systemtzindex systemdst systemauto

    return $EXITCODE_PARSESYSTEMOPTIONS

}

processCustomizedOptions() {
    DEBUG_FUNC="processCustomizedOptions"

    EXITCODE_CUSTOMIZED=0

    #readarray -d ',' -t OPTION_CUSTOMIZED < <(echo -n "$1") # <<< HERE string appends 0x0a -> using process substitution

    [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC $1"

    # 1. parse , expressions server=localhost,port=8080,protocol=ecowitt,enabled=yes

     IFS=','
     for option in $1; do
        
        [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC: option $option"

        # 2. parse = expressions

        IFS='='
        #shellcheck disable=SC2086
        set -- $option
        key=$1
        value=$2

        [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC KEY $key len ${#key} VALUE $value len ${#value}"

        case "$key" in

            id)
                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_id from $C_WS_CUSTOMIZED_ID to $value"
                C_WS_CUSTOMIZED_ID=$value
                ;;

            password | pw)

                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_password from ${C_WS_CUSTOMIZED_PASSWORD} to $value"
                C_WS_CUSTOMIZED_PASSWORD=$value
                #observation: gw1000 client will not send wunderground http request unless password and id is specified
                ;;

            server | s)

                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_server from $C_WS_CUSTOMIZED_SERVER to $value"
                C_WS_CUSTOMIZED_SERVER=$value

                ;;

            port | p)

                if ! isNumber "$value"; then
                    echo >&2 "$DEBUG_FUNC Error: Not a number -  cannot set customized port to $value from $value"
                    EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                else
                    C_WS_CUSTOMIZED_PORT=$((value))
                    [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_port from $C_WS_CUSTOMIZED_PORT to $value"
                fi

                ;;

            http | h)

                case $value in

                    wunderground | w | 1)
                        value=1
                        ;;

                    ecowitt | e | 0)
                        value=0
                        ;;

                    *)  echo >&2 "$DEBUG_FUNC Error: Unknown value $value for http protocol, use wunderground|w|1 or ecowitt|e|0"
                        EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                esac

                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_TYPE from $C_WS_CUSTOMIZED_HTTP to $value"
                C_WS_CUSTOMIZED_HTTP=$value
                ;;

            enabled | e)

                case $value in

                    on | 1 | yes | y)
                       value=1
                        ;;

                    off | 0 | no | n)
                        value=0
                        ;;

                    *)  echo >&2 "$DEBUG_FUNC Error: Unknown value $value for enabled, use on|1|yes|y, off|0|no|n"
                        EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                esac

                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_enabled from $C_WS_CUSTOMIZED_ENABLED to $value"
                C_WS_CUSTOMIZED_ENABLED=$value

                ;;

            interval | i)

                if ! isNumber "$value"; then
                    echo >&2 "$DEBUG_FUNC Error: Not a number cannot set customized interval to $value"
                    EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                else
                    [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_interval from $C_WS_CUSTOMIZED_INTERVAL to $value"
                    C_WS_CUSTOMIZED_INTERVAL=$((value))

                fi

                ;;

            path_wunderground | p_w)

                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_path_wu from $C_WS_CUSTOMIZED_PATH_WU to $value"
                C_WS_CUSTOMIZED_PATH_WU=$value

                ;;

            path_ecowitt | p_e )

                [ $DEBUG -eq 1 ] && echo >&2 "$DEBUG_FUNC Update customized_ecowitt_path from $C_WS_CUSTOMIZED_PATH_ECOWITT to $value"
                C_WS_CUSTOMIZED_PATH_ECOWITT=$value

                ;;

            help|?|*)
                echo >&2 "$DEBUG_FUNC Error: Unknown key $key, use id, password|pw, server|s, port|p, http|h, enabled|e, interval|i, path_wunderground|p_w, path_ecowitt|p_e"
                EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                ;;
        esac

    done

    #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash

    if [ $EXITCODE_CUSTOMIZED -eq 0 ]; then

        [ $DEBUG -eq 1 ] && printCustomized >&2

        sendCustomized "$C_HOST"
    fi

    unset key value option

    return $EXITCODE_CUSTOMIZED
}

printCommands() {

    commands="reset reboot mac version"

    echo "Commands available -c:"
    
    for cmd in $commands; do
      echo "   $cmd"
    done | sort | uniq 

    unset cmd commands
}

processSensorOptions()
# process -c sensor command option; format: 31-38=disable,40-47=disable
{
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
       #shellcheck disable=SC3044
       {
        typeset f  sensortypeexpr cmdexpr sentReadSensorIdCommand
        case "$KSH_VERSION" in

          *MIRBSD?KSH*) typeset -iU sensorid sensorid_hex
                        ;;
                    *) typeset sensorid sensorid_hex
                    ;;
        esac
       }  
    fi

    [ "$DEBUG" -eq 1 ] && echo >&2 processSensorOptions "$*"

    sentReadSensorIdCommand=0

     IFS=,

     for f in $1; do #parse , expressions
       IFS='='
       #shellcheck disable=SC2086
       set -- $f #parse = expression -> set to $1 $2 ...
       sensortypeexpr=$1
       cmdexpr=$2

       unset sensorType_low sensorType_high 

        case $sensortypeexpr in
            *-*)    parseRangeExpression "$sensortypeexpr" 
                    sensorType_low=$VALUE_RANGE_LOW
                    sensorType_high=$VALUE_RANGE_HIGH
                    [ "$DEBUG" -eq 1 ] &&  >&2 echo "Sensor type low $sensorType_low sensor type high $sensorType_high"
                    ;;
            all)    sensorType_low=0
                    sensorType_high=$SENSORTYPE_MAX
                    ;;
            *)      sensorType_low=$sensortypeexpr # only a single sensortype
                    ;;
       esac

       #validation

       if [ -z "$sensorType_low" ]; then
          echo >&2 "Error: Empty sensor id low $sensorType_low"
          return "$ERROR_INVALID_SENSORID"
       fi
       
       if [ -n "$sensorType_low" ] && ! isNumber "$sensorType_low" || [ "$sensorType_low" -gt "$SENSORTYPE_MAX" ]; then
          echo >&2 "Error: Not a valid sensor type $sensorType_low, max sensortype $SENSORTYPE_MAX"
          return "$ERROR_INVALID_SENSORID"
       fi
       
       if [ -n "$sensorType_high" ]; then
          if  ! isNumber "$sensorType_high" || [ "$sensorType_high" -gt "$SENSORTYPE_MAX" ]; then
            echo >&2 "Error: Not a valid sensor id $sensorType_high, max sensortype $SENSORTYPE_MAX"
            return "$ERROR_INVALID_SENSORID"
          fi

          if [ "$sensorType_low" -gt "$sensorType_high" ]; then
            echo >&2 "Error: Sensor id low $sensorType_low is greather than sensorid high $sensorType_high"
            return "$ERROR_INVALID_SENSORID"
          fi

       fi

        if [ -n "$sensorType_low" ] && [ -z "$sensorType_high" ]; then #single sensortype
            sensorType_high=$sensorType_low
        fi

        if [ -n "$sensorType_low" ] && [ -n "$sensorType_high" ] && [ -z "$cmdexpr" ]; then #only range without command
            SPATTERNID=$SPATTERNID_RANGE
            SPATTERNID_RANGE_LOW=$sensorType_low
            SPATTERNID_RANGE_HIGH=$sensorType_high
            if [ $sentReadSensorIdCommand -eq 0 ]; then 
                sendPacket $CMD_READ_SENSOR_ID_NEW "$C_HOST" #only sent for first , expression
                sentReadSensorIdCommand=1
            else # yet another read (for example -c sensor 1-10,40-47) use in-memory buffer backup 
               IFS=" " parsePacket "$OD_BUFFER_BACKUP" 
            fi
            SENSORVIEW_HIDE_HEADER=1 #disabled header for next , expression
            continue
        fi

       sentReadSensorIdCommand=0 #reset for WRITE
       sensorid_hex=0
       
       case $cmdexpr in 

          disable|d|disabled)                   sensorid=$SENSORID_DISABLE
                                                 ;;

          search|s|enable|e|searching|enabled)  sensorid=$SENSORID_SEARCH
                                                 ;;

          '')                                   echo >&2 "Error: Empty command, use sensortype=disable|search|d|s"
                                                return "$ERROR_INVALID_SENSORID_COMMAND"
                                                ;;
          *) 
                                                if ! isHex "$cmdexpr"; then
                                                echo >&2 "Error: Invalid hex number for sensor id $cmdexpr"
                                                return "$ERROR_INVALID_SENSORID_COMMAND"
                                                else
                                                    sensorid_hex=1
                                                    sensorid=$(( 0x$cmdexpr ))
                                                fi
                                                ;;
       esac

        if [ "$sensorid_hex" -eq 1 ] && [ "$sensorType_low" -lt "$sensorType_high" ]; then
            echo >&2 "Error: Cannot set sensortype range to same sensorid $cmdexpr"
            return $ERROR_INVALID_SENSORID
        fi

       sendSensorId "$sensorType_low" "$sensorType_high" "$sensorid" "$C_HOST"
          
    done

    unset f sensorid sensortypeexpr cmdexpr sensorid_hex
}

parseRaindataOptions()
#parse options to -c rain command
{
    
    #copy read values
    rainday=$C_RAINDAILY
    rainweek=$C_RAINWEEK
    rainmonth=$C_RAINMONTH
    rainyear=$C_RAINYEAR

    rain_needsupdate=0

    IFS=,
    for rainexpr in $1; do
        IFS='='
        #shellcheck disable=SC2086
        set -- $rainexpr
            case "$1" in
                d|day)   if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainday" ]  &&  { rainday="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                         else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                w|week)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainweek" ]  &&  { rainweek="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                         else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                m|month) if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainmonth" ] &&  { rainmonth="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                         else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                y|year)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainyear" ] &&  { rainyear="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                        else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                *) >&2 echo "Warning: comma delimited list: day|d=, week|w=, month|m=, year|y=, d=10.0 sets daily rain to 10.0 mm"
                    ;;
            esac
    done

    if [ $rain_needsupdate -eq 1 ]; then
        if ! sendRaindata "$rainday" "$rainweek" "$rainmonth" "$rainyear" "$C_HOST"; then
           echo >&2 Failed to send raindata 
        fi
    else
        echo >&2 "Info: rain data does not need updating"
    fi

    unset rainexpr rainday rainweek rainmonth rainyear rain_needsupdate
    
}

processCalibrationOptions()
#it seems like gw-1000, fw 1.6.8, runs calibratation update each minute
#test term 1: while true; do ./gw -g 192.168.3.26 -c l | egrep -i "press|utc|host|version" ; sleep 1;  done
#test term 2: ./gw -g 192.168.3.26 -c cal a=2
#procedure for calibration: find absolute pressure at location, -c cal a=0,r=0, -c a=aoffset, -c r=roffset (absolute offset also affects relative pressure)
{
    #DEBUG_CALIBRATION_OPTIONS=1
    DEBUG_CALIBRATION_OPTIONS=${DEBUG_CALIBRATION_OPTIONS:=$DEBUG}
    DEBUG_FUNC='processCalibrationOptions'

    calibration_intemp=$C_CALIBRATION_INTEMPOFFSET_INT
    calibration_inhumi=$C_CALIBRATION_INHUMIDITYOFFSET
    calibration_outtemp=$C_CALIBRATION_OUTTEMPOFFSET_INT
    calibration_outhumi=$C_CALIBRATION_OUTHUMIDITYOFFSET
    calibration_absoffset=$C_CALIBRATION_ABSOFFSET_INT
    calibration_reloffset=$C_CALIBRATION_RELOFFSET_INT
    calibration_winddir=$C_CALIBRATION_WINDDIROFFSET

    IFS=,
    calibration_need_update=0

    for expr in $1; do
        IFS='='
        #shellcheck disable=SC2086
        set -- $expr
        key=$1
        value=$2
        
        [ $DEBUG_CALIBRATION_OPTIONS -eq 1 ] && echo >&2 "processCalibrationOptions, parsing expr: $expr k: $1, v: $2"

        case "$key" in
        
            it|intemp)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_INTEMPOFFSET_MAX ]; then
                            [ "$calibration_intemp" -ne "$VALUE_FLOAT_SCALE10" ] && { calibration_intemp=$VALUE_FLOAT_SCALE10; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_INTEMPOFFSET_MAX/$CALIBRATION_INTEMPOFFSET_MAX (scale 10)"
                        fi
                        ;;
            
            ih|inhumi) if isNumber "$2" &&  [ "$2" -ge -$CALIBRATION_INHUMIOFFSET_MAX ] && [ "$2" -le $CALIBRATION_INHUMIOFFSET_MAX ] ; then
                            [ "$calibration_inhumi" -ne "$2" ] && { calibration_inhumi=$2; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_INHUMIOFFSET_MAX/$CALIBRATION_INHUMIOFFSET_MAX"
                        fi
                        ;;

            ot|outtemp) if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_OUTTEMPOFFSET_MAX ]; then
                            [ "$calibration_outtemp" -ne "$VALUE_FLOAT_SCALE10" ] && { calibration_outtemp=$VALUE_FLOAT_SCALE10; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_OUTTEMPOFFSET_MAX/$CALIBRATION_OUTTEMPOFFSET_MAX (scale 10)"
                        fi
                        ;;
        
            oh|outhumi)  if isNumber "$2" &&  [ "$2" -ge -$CALIBRATION_OUTHUMIOFFSET_MAX ] && [ "$2" -le $CALIBRATION_OUTHUMIOFFSET_MAX ] ; then
                            [ "$calibration_outhumi" -ne "$2" ] && { calibration_outhumi=$2; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max " "-$CALIBRATION_OUTHUMIOFFSET_MAX/$CALIBRATION_OUTHUMIOFFSET_MAX"
                        fi
                        ;;

            a|absoffset|absolute|abs)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_ABSOFFSET_MAX ]; then
                             [ "$C_CALIBRATION_ABSOFFSET_INT" -ne "$VALUE_FLOAT_SCALE10" ] && { 
                                 calibration_absoffset=$VALUE_FLOAT_SCALE10; calibration_need_update=1;  }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_ABSOFFSET_MAX/$CALIBRATION_ABSOFFSET_MAX (scale 10)"
                        fi
                        ;;
            
            r|reloffset|relative|rel) if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_RELOFFSET_MAX ]; then

                              [ "$C_CALIBRATION_RELOFFSET_INT" -ne "$VALUE_FLOAT_SCALE10" ] && { calibration_reloffset=$VALUE_FLOAT_SCALE10; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_RELOFFSET_MAX/$CALIBRATION_RELOFFSET_MAX (scale 10)"
                        fi
                         ;;

            w|winddiroffset|winddir) if isNumber "$2" &&  [ "$2" -ge -$CALIBRATION_WINDDIROFFSET_MAX ] && [ "$2" -le $CALIBRATION_WINDDIROFFSET_MAX ] ; then
                               [ "$calibration_winddir" -ne "$2" ] && { calibration_winddir=$2; calibration_need_update=1; }
                            else
                                echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_WINDDIROFFSET_MAX/$CALIBRATION_WINDDIROFFSET_MAX"
                            fi
                        ;;

            reset)  calibration_intemp=0 # maybe convenient shorthand, instead of multiple a=0,r=0,....
                    calibration_inhumi=0
                    calibration_outtemp=0
                    calibration_outhumi=0
                    calibration_absoffset=0
                    calibration_reloffset=0
                    calibration_winddir=0

                    calibration_need_update=1
                    [ "$DEBUG_CALIBRATION_OPTIONS" -eq 1 ] && echo >&2 "$DEBUG_FUNC Reset calibration"
                    ;;

            *) echo >&2 "Error: Unknown key $1, use it | intemp, ih | inhumi, ot | outtemp, oh | outhumi, a | absoffset, r | reloffset, w | winddiroffset"
                ;;
        esac

    done

    if [ $calibration_need_update -eq 1 ]; then
       if ! sendCalibration "$calibration_intemp" "$calibration_inhumi" "$calibration_absoffset" "$calibration_reloffset" "$calibration_outtemp" "$calibration_outhumi" "$calibration_winddir" "$C_HOST" ; then
          echo >&2 "Error: Failed to send calibration to device $?"
       fi
    fi


    unset expr calibration_intemp calibration_inhumi calibration_outtemp calibration_outhumi calibration_absoffset calibration_reloffset calibration_winddir DEBUG_CALIBRATION_OPTIONS IFS
}

copyConfigurationToLivedata()
#copies low-level configuration variables to UI-level variables
{
    copyVersionToLivedata
    copySystemToLivedata
}

printOrLogLivedata()
{
    if [ $LIVEDATA_SYSTEM_PROTOCOL = $LIVEDATA_PROTOCOL_ECOWITT_BINARY ]; then
         copyConfigurationToLivedata
    fi

    if [ -z "$LOG_CMD" ]; then
       if [ $LIVEDATA_VIEW -eq $LIVEDATA_VIEW_NORMAL ]; then
       #https://stackoverflow.com/questions/10411616/grep-regex-not-containing-string
            #set | grep ^LIVEDATA | grep -v _HEADER
            printLivedata
       else
          echo >&2 Not implemented liveview $LIVEDATA_VIEW
       fi
    else
      eval "$LOG_CMD" # would allow executing of anything inside 
    # case "$LOG_CMD" in
    #   csv) "$GW_VIEW_CSV_FILE"
    #       ;;
    #    *) echo >&2 Error Valid log formats are: csv
     #esac
    fi
}

processUnitOptions()
#format: temp=farenheit|celius,pressure=inhg|hpa,wind=mph|mps|kmh,rain=mm|inch,light=lux|watt
{
    IFS=,
    for f in $1; do
        IFS='='
        #shellcheck disable=SC2086
        set -- $f
        case "$1" in
            temperature|t) case "$2" in 

                                celcius|c)    setTemperatureMode $UNIT_TEMPERATURE_CELCIUS 
                                                ;;
                                farenheit|f)   setTemperatureMode $UNIT_TEMPERATURE_FARENHEIT 
                                                ;;
                                *)             echo >&2 Warning: Unknown temperature mode "$2", use "celcius|c, farenheit|f" 
                                                ;;
                                esac
                                ;;

            pressure|p)     case "$2" in
                                inhg|i)     setPressureMode $UNIT_PRESSURE_INHG 
                                            ;;
                                hpa|h)      setPressureMode $UNIT_PRESSURE_HPA 
                                            ;;
                                *)          echo >&2 Warning: Unknown pressure mode "$2", use "inhg|i, hpa|h" 
                                            ;;
                            esac
                            ;;

             wind|w)     case "$2" in
                                mph|h)     setWindMode $UNIT_WIND_MPH 
                                            ;;
                                mps|s)      setWindMode $UNIT_WIND_MPS 
                                            ;;
                                kmh|k)      setWindMode $UNIT_WIND_KMH
                                            ;;
                                *)          echo >&2 Warning: Unknown wind mode "$2", use "mph|h, mps|s, kmh|k" 
                                            ;;
                            esac
                            ;;

            rain|r)     case "$2" in
                                mm)         setRainMode $UNIT_RAIN_MM
                                            ;;
                                inch)         setRainMode $UNIT_RAIN_IN
                                            ;;
                                *)          echo >&2 Warning: Unknown rain mode "$2", use "mm|inch" 
                                            ;;
                        esac
                        ;;
                    
            light|l)    case "$2" in
                            lux)    setLightMode $UNIT_LIGHT_LUX
                                    ;;
                            watt)   setLightMode $UNIT_LIGHT_WATTM2
                                    ;;
                                *)  echo >&2 Warning: Unknown light mode "$2", use "lux|watt"
                                    ;;
                        esac
                        ;;

                    *)      echo >&2 Warning: Unknown mode "$1", use "temperature|t, pressure|p, wind|w, rain|r, light|l" 
                            ;;
        esac
    done

    unset f
}

processDebugOptions()
#allows setting multiple options; for examplel -d buffer,command
{
    IFS=,
    for opt in $1; do 

       [ "$DEBUG" -eq 1 ] && echo  >&2 "Processing debug option $opt"
    
        case "$opt" in
        
            ""|--*|-*)  DEBUG=1
                        ;;
            t|trace)    DEBUG_OPTION_TRACEPACKET=1 # trace tx/rx packets in hex format during sendpacketnc
                        ;;
            a|append)   DEBUG_OPTION_APPEND=1 # print append format/args - default livedata view/table layout
                        ;;
            b|buffer)   DEBUG_OPTION_OD_BUFFER=1 # show hex buffers of transmitted/received data
                        ;;
            c|command)  DEBUG_OPTION_COMMAND=1 #echo command printf/nc/od pipeline
                        ;;
            h|http)     DEBUG_OPTION_HTTP=1 #show http request when listening 
                        ;;
            s|sensor)   DEBUG_OPTION_TESTSENSOR=1 # inject test sensor data
                        . $GWDIR/lib/testsensor.sh
                        ;;
            #STYLING
            w|beufort|wind) IFS=" " 
                        printf >&2 "\nBeufort scale styling\n\n"
                        for f in $(seq -s ' ' 0 12); do 
                                eval >&2 printf \""%2d \$STYLE_BEUFORT_$f%s\$STYLE_RESET %4d\\\n"\"  \""$f"\" \"\$BEUFORT_"${f}"_DESCRIPTION\" \"\$BEUFORT_"${f}"\"
                        done
                        unset f
                        ;;
                pm25) IFS=" "
                        printf >&2 "\nPM25 Air Quality Index styling\n\n"
                        for pm25 in $(( PM25_AQI_GOOD_LIMIT -1)) $((  PM25_AQI_MODERATE_LIMIT - 1)) $((  PM25_AQI_UNHEALTHY_SENSITIVE_LIMIT - 1)) $((  PM25_AQI_UNHEALTHY_LIMIT - 1)) $((  PM25_AQI_VERY_UNHEALTHY_LIMIT - 1)) $((  PM25_AQI_VERY_UNHEALTHY_LIMIT + 1)) ; do
                            setAQI $pm25
                            setStyleAQI $pm25
                            printf >&2 "$STYLE_AQI%s$STYLE_RESET %s\n" "$VALUE_PM25_AQI" "$(( pm25 + 1))"
                        done
                        unset pm25
                        ;;

            ri|rainintensity) IFS=" "
                        printf >&2 "\nRainintensity styling\n\n"
                        for ri in $(( RAININTENSITY_LIGHT_LIMIT -1)) $(( RAININTENSITY_LIGHT_LIMIT + 1)) $((RAININTENSITY_MODERATE_LIMIT + 1)) $((RAININTENSITY_HEAVY_LIMIT + 1)); do
                            setRainIntensity $ri
                            setStyleRainIntensity $ri
                            printf >&2 "$STYLE_RAININTENSITY%s$STYLE_RESET %d\n" "$VALUE_RAININTENSITY" "$(( ri + 1))"
                        done
                        unset ri
                        ;;
            uvi) IFS=" " 
                      printf >&2 "\nUVI styling\n\n"
                      for uvi in $(seq -s ' ' 0 11); do 
                          setStyleUVI "$uvi"
                          printf >&2 "$STYLE_UVI%2d$STYLE_RESET\n" "$uvi"
                      done
                      unset uvi
                      ;;
                    *)  echo >&2 "Error: Unknown debug option $opt, use append | a, buffer | b, command | c, http | h, sensor | s, t | trace"
                        echo >&2  "Styling: beufort | wind, pm25, rainintensity | ri, uvi"
                        ;;
        esac
    done
    unset opt 
}

processOptionsLiveview()
{
     #default is show all information gathered, these options allows to filter output/turn off display of sensors

    IFS=,

    for hide_liveview in $1; do 

        case "$hide_liveview" in

            uvi)
                LIVEVIEW_HIDE_UVI=1
                ;;

            pm25aqi)
                #shellcheck disable=SC2034
                LIVEVIEW_HIDE_PM25AQI=1 #hides PM 2.5 AQI  styling/description
                ;;

            b|beufort)
                LIVEVIEW_HIDE_BEUFORT=1 # hides beufort styling and description
                ;;

            status) #battery/signal status unicode icons
                LIVEVIEW_HIDE_STATUSLINE=1
                ;;

            c | compass)
                LIVEVIEW_HIDE_COMPASS=1
                ;;

            sh | sensor-header)
                SENSORVIEW_HIDE_HEADER=1
                ;;

            h | headers)
                LIVEVIEW_HIDE_HEADERS=1
                ;;

            # b | battery)
            #    HIDE_BATTERY_LIVEDATA=1
                #  ;;
                
            s | system)
                LIVEVIEW_HIDE_SYSTEM=1
                ;;

            r | rain)
                LIVEVIEW_HIDE_RAIN=1
                ;;

            l | light)
                LIVEVIEW_HIDE_LIGHT=1
                ;;
                
            t | temperature | temp)
                LIVEVIEW_HIDE_TEMP=1
                ;;

            w | wind)
                LIVEVIEW_HIDE_WIND=1
                ;;

            sm | soilmoisture | soilm)
                LIVEVIEW_HIDE_SOILMOISTURE=1
                ;;

            st | soiltemperature | soilt)
                LIVEVIEW_HIDE_SOILTEMPERATURE=1
                ;;

            leak)
                LIVEVIEW_HIDE_LEAK=1
                ;;

            tusr | tempusr)
                LIVEVIEW_HIDE_TEMPUSR=1
                ;;

            pm25)
                LIVEVIEW_HIDE_PM25=1
                ;;

            co2)
                LIVEVIEW_HIDE_CO2=1
                ;;

            leafw | leafwetness)
                LIVEVIEW_HIDE_LEAFWETNESS=1
                ;;

            lightning)
                LIVEVIEW_HIDE_LIGHTNING=1
                ;;

            *) echo >&2 "Warning: Unknown hide_liveview option $hide_liveview; use sensor-header | sh, headers | h, rain | r, wind | w,temperature | t,light | l, system | s, soilmoisture | sm, soiltemperature | st, leak, co2, pm25, leafwetness | leafw, lightning, tempusr | tusr, compass | c, status, beufort | b, pm25aqi, uvi"
                ;;
            esac
    done

    unset hide_liveview
}

processCommand()
# process -c command
# EXITCODE_PROCESSCOMMAND
 {
   EXITCODE_PROCESSCOMMAND=0

   [ "$DEBUG" -eq 1 ] && >&2 echo ARGS to processCommand "$@" length "$#" COMMAND "$COMMAND"

   if [ "$#" -ge 1 ]; then
      shift # remove {command} (to -c option) -> all args to {command} starts at $1
   fi

    case $COMMAND in

        "")
            printCommands
            ;;

         w-s | wifi-server) # method 1 in spec. part 3
            #open tcp 49123 in windows firewall for private network, set GW1000-WIFI???? network as private-network 
            #inside wsl2: setup tcp portproxy (allow external tcp 49123 -> wsl tcp 49123)
            #    iex "netsh interface portproxy add v4tov4 listenaddress=(Get-NetIPAddress -InterfaceAlias Wi-Fi -AddressFamily IPv4).IPAddress connectaddress=$(wsl -e hostname -I) connectport=49123 listenport=49123"
            #windows: netsh wlan connect GW1000-WIFI????

            if [ -z "$1" ]; then
                echo >&2 Error: Empty SSID not allowed
                shift
                EXITCODE_PROCESSCOMMAND=$ERROR_SSID_EMPTY
           else
                newWIFIpacket "$1" "$2"
                createPacketTX "$CMD_WRITE_SSID"
                od_buffer=$(printf %b "$PACKET_TX_ESCAPE" | timeout "$TIMEOUT_WIFICONFIG_SERVER" nc -l "$PORT_WIFICONFIG_SERVER_TCP" | od -A n -t u1 -w$MAX_16BIT_UINT) 
                if parsePacket "$od_buffer"; then
                    [ "$VALUE_PACKET_WRITE_RESULT" -eq 1 ] && EXITCODE_PROCESSCOMMAND=$ERROR_WIFICONFIG_SERVER_FAILED
                else
                   echo >&2 "Error: No connection received for ${TIMEOUT_WIFICONFIG_SERVER}s on $PORT_WIFICONFIG_SERVER_TCP"
                   EXITCODE_PROCESSCOMMAND=$EXITCODE_PARSEPACKET
                fi
                shift && [ -n "$2" ] && shift
            fi
            ;;

        w-c | wifi-client | ssid)

           if [ -z "$2" ]; then
                echo >&2 Error: Empty SSID not allowed
                shift
                EXITCODE_PROCESSCOMMAND=$ERROR_SSID_EMPTY
           else
                newWIFIpacket "$1" "$2"
                if ! sendPacket && [ "$EXITCODE_SENDPACKET" -ne $ERROR_OD_BUFFER_EMPTY ]; then
                    #sometimes OK response from gw is not received -> empty buffer
                    echo >&2 Error: Failed to send wifi configuration to "$C_HOST", error code "$EXITCODE_SENDPACKET"
                    EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
                fi
                shift && [ -n "$2" ] && shift
            fi
            ;;

        "$CMDOPT_RESET")

            if sendPacket $CMD_BROADCAST "$C_HOST" >/dev/null; then

                printf "%s" "Reset $C_BROADCAST_MAC $C_BROADCAST_SSID (Y/N)? "
                read -r REPLY

                case $REPLY in
                    Y)
                        sendPacket $CMD_WRITE_RESET "$C_HOST" # 3 blink in red LED
                        ;;
                esac

            else
               echo >&2 Error: Failed to receive broadcast with MAC and SSID
               EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
            fi

            ;;

        reboot)
            echo "REBOOTING..."
            sendPacket $CMD_REBOOT "$C_HOST"
            ;;

        mac)

            sendPacket $CMD_READ_MAC "$C_HOST"
            ;;

        version|ver)

            sendPacket $CMD_READ_VERSION "$C_HOST"
            ;;

        system | sys)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_SYSTEM "$C_HOST"
            else
                C_NOPRINT=1
                sendPacket $CMD_READ_SYSTEM "$C_HOST"
                unset C_NOPRINT
                parseSystemOption "$1"
                EXITCODE_PROCESSCOMMAND=$EXITCODE_PARSESYSTEMOPTIONS
            fi
            ;;

        ecowitt | e)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_ECOWITT_INTERVAL "$C_HOST"
            else
                sendEcowittInterval "$1" "$C_HOST"
                EXITCODE_PROCESSCOMMAND=$?
            fi
            
            ;;

        wunderground | wu)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WUNDERGROUND "$C_HOST"
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error: {id} {password} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WUNDERGROUND" "$1" "$2"
                fi
            fi

            ;;

        wow)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WOW
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error: {id} {password} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WOW" "$1" "$2"
                fi
            fi
            ;;

        weathercloud | wc)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WEATHERCLOUD "$C_HOST"
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error: {id} {key} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WEATHERCLOUD" "$1" "$2"
                fi
            fi
            ;;

        customized | c | cust)

            if argEmptyOrOption "$1"; then
                if ! sendPacket $CMD_READ_PATH  "$C_HOST" >/dev/null || ! sendPacket $CMD_READ_CUSTOMIZED  "$C_HOST"; then
                  >&2 echo Failed to get customized settings
                fi
            else
                
                if sendPacket $CMD_READ_CUSTOMIZED  "$C_HOST" >/dev/null && sendPacket $CMD_READ_PATH "$C_HOST" >/dev/null; then
                    if ! processCustomizedOptions "$1"; then
                        EXITCODE_PROCESSCOMMAND=$EXITCODE_CUSTOMIZED
                        #echo >&2 "Error: Failed to update customized settings"
                    fi
                else
                  >&2 echo "Cannot update customized, failed to read customized settings from device"
                fi
            fi

            ;;

       # path | p) # deprecate?

       #    sendPacket $CMD_READ_PATH
       #    ;;

        broadcast | b)
            sendPacket $CMD_BROADCAST "$C_HOST"
            ;;

        rain | r)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_RAINDATA "$C_HOST"
            else
                if sendPacket $CMD_READ_RAINDATA "$C_HOST" >/dev/null ; then #refresh
                    parseRaindataOptions "$1"
                    EXITCODE_PROCESSCOMMAND=$?

                else
                  EXITCODE_PROCESSCOMMAND=$?
                  echo >&2 Error: Failed to get raindata from "$C_HOST"
                fi
            fi

            ;;

        livedata | l)

            
            sendPacket "$CMD_READ_SENSOR_ID_NEW" "$C_HOST" >/dev/null   #get battery and signal info as well
            
            if [ -z "$LOG_CMD" ]; then

                sendPacket $CMD_LIVEDATA "$C_HOST"
                EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
            else
              
                while true; do
                  sendPacket $CMD_LIVEDATA "$C_HOST"
                  sleep "$LOG_INTERVAL"
                done
            fi

            ;;

        sensor_id)

            sendPacket $CMD_READ_SENSOR_ID "$C_HOST"
            ;;

        sensor_id_new | sensor | s) # for new SENSOR_TYPE types

            if ! argEmptyOrOption "$1"; then
             #filter for senorid; -c sensor connected|-c s co

                case "$1" in 
                    connected|c)
                                    SPATTERNID=$SPATTERNID_CONNECTED #matches connected sensors
                                    sendPacket $CMD_READ_SENSOR_ID_NEW "$C_HOST"
                                    ;;
                    disconnected)
                                    SPATTERNID=$SPATTERNID_DISCONNECTED
                                    sendPacket $CMD_READ_SENSOR_ID_NEW "$C_HOST"
                                    ;;
                    searching|s)
                                    SPATTERNID=$SPATTERNID_SEARCHING
                                    sendPacket $CMD_READ_SENSOR_ID_NEW "$C_HOST"
                                    ;;
                    disabled|d)
                                    SPATTERNID=$SPATTERNID_DISABLED
                                    sendPacket $CMD_READ_SENSOR_ID_NEW "$C_HOST"
                                    ;;
                    
                    *) 
                                    processSensorOptions "$1"
                    ;;
                esac

            else
                sendPacket $CMD_READ_SENSOR_ID_NEW "$C_HOST"
            fi

            ;;

        calibration | calibrate | cal)
   
            if sendPacket $CMD_READ_CALIBRATION "$C_HOST" >/dev/null; then 

                case "$1" in
                    ""|--*|-*) printCalibration
                    ;;
                    
                    *) processCalibrationOptions "$1"
                    ;;
                esac
            fi
            EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
            ;;

        *)

            echo >&2 "Error: Unknown command $COMMAND $*"
            return "$ERROR_COMMAND_UNKNOWN"
            ;;
    esac

    [ -z "$EXITCODE_PROCESSCOMMAND" ] && EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET

    return "$EXITCODE_PROCESSCOMMAND"
}

#read -r -u 0 -t 0 STDIN

#if [ -n "$STDIN" ]; then
#  echo STDIN "$STDIN"
:
#maybe parse packet if gw used as filter echo hex dump | gw

#fi

initShell
initTerm
initConfigDir
initTrap
if ! initnc; then
    exit $?
fi

initTimezones
initUnit
initWinddirectionCompass

#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
#useful CLI info: https://clig.dev/#arguments-and-flags

# parse options
while [ $# -gt 0 ]; do

    EXITCODE_MAIN=0

    KEY="$1"

    case $KEY in

       -b | --backup)   if [ -z "$C_HOST" ]; then
                             echo >&2 Error: No host
                            EXITCODE_MAIN=$ERROR_NO_HOST_SPECIFIED
                            shift
                        else
                            FILENAME_BACKUP='backup.hex'
                            IFS=' '
                            #[ $DEBUG -eq 1 ] &&
                            echo >&2 "$(date) Backup started to $FILENAME_BACKUP"
                            for cmd in $CMD_READ_ECOWITT_INTERVAL $CMD_READ_WUNDERGROUND ; do
                                getCommandName "$cmd"
                                if sendPacket $cmd "$C_HOST" "$FILENAME_BACKUP"; then
                                     # [ $DEBUG -eq 1 ] &&
                                     echo >&2 "OK $COMMAND_NAME"
                                else
                                   echo >&2 "FAILED $COMMAND_NAME, error code: $?"
                                fi
                               
                            done
                            #[ $DEBUG -eq 1 ] &&
                            echo >&2 "$(date) Backup stopped"

                            unset cmd FILENAME_BACKUP
                            shift
                        fi
                            
                    ;;

      -r | --restore)   # check for -g host
                        if argEmptyOrOption "$2"; then
                            echo >&2 Error: Please provide backup filename to restore
                            shift
                            EXITCODE_MAIN=$ERROR_INVALID_FILENAME
                        elif [ -z "$C_HOST" ]; then
                            echo >&2 Error: No host
                            EXITCODE_MAIN=$ERROR_NO_HOST_SPECIFIED
                            shift
                        else
                            FILENAME_RESTORE="$2"
                            printf "%s" "Overwrite current configuration for host $C_HOST (Y) ? "
                            read -r RESTORE_OVERWRITE_CURRENT
                            if [ "$RESTORE_OVERWRITE_CURRENT" = "Y" ]; then
                                restoreBackup "$FILENAME_RESTORE" "$C_HOST"
                            fi 
                            shift
                        fi
                        
                        ;;

       -v | --view) IFS=,
                    for liveview in $2; do
                       case "$liveview" in
                         
                           t | terse) LIVEDATA_VIEW=$LIVEDATA_VIEW_TERSE
                                    ;;
                            *) >&2 echo "Warning: Unknown livedata view $liveview, use terse|t"
                            ;;
                        esac
                    done
                    [ -n "$2" ] && shift
                    shift
                    unset liveview
                    ;;

       -A | --lang)

           if [ -n "$2" ] && [ -s "$2" ]; then
              #shellcheck disable=SC1090
              . "$2"
               initUnit # update UNIT_HOUR
               initWinddirectionCompass
           else
              echo >&2 Warning: language file not found "$2"
           fi

           shift 2
           ;;

       -H | --hide-liveview)

            processOptionsLiveview "$2"
            
            [ -n "$2" ] && shift
            shift

            ;;

       -n | --log-interval)

            if ! argEmptyOrOption "$2"; then
                LOG_INTERVAL="$2"
                shift 2
            else
                shift
            fi
          
            [ "$DEBUG" -eq 1 ] &&  echo >&2 Logging each "$LOG_INTERVAL" seconds
            ;;

       -L | --log)
          
           if ! argEmptyOrOption "$2"; then
               LOG_CMD="$2"
              shift 2
            else
              shift
            fi
          ;;
      
        -W | --show-ws)
            
            printWeatherServices "$C_HOST"
            shift
            ;;

        -c | --command)

            toLowercase "$2"
            COMMAND=$LOWERCASE

            shift 1 # remove -c

            processCommand "$@"
            EXITCODE_MAIN=$?

            for param in "$@"; do #remove params to command (until new - option)

                case "$param" in

                -*)
                    break
                    ;;

                *)
                    [ $DEBUG -eq 1 ] && echo >&2 Shift param "$@" "$param"
                    shift
                    ;;
                esac

            done

            unset COMMAND param
            ;;
        
        -u | --unit)
               
               if argEmptyOrOption "$2"; then
                 echo >&2 "Warning: no arguments specified for unit, for example temp=farenheit|celcius"
                 shift # ignore
               else
                 processUnitOptions "$2"
                 shift 2 
               fi
              ;;

        -d | --debug)

              processDebugOptions "$2"
              case "$2"  in
                    ""|--*|-*)  shift       # -d only
                                ;;
                            *)  shift 2     # -d options
                                ;;
              esac
              
            ;;

        -f | --firmware)
            HTTP_UA="gw"
            [ -n "$BASH_VERSION" ] && HTTP_UA="$HTTP_UA bash $BASH_VERSION"
            [ -n "$ZSH_VERSION" ] && HTTP_UA="$HTTP_UA zsh $ZSH_VERSION"
            [ -n "$KSH_VERSION" ] && HTTP_UA="$HTTP_UA ksh $KSH_VERSION"
            HTTP_UA="$HTTP_UA nc $NC_VERSION $(uname -srv)"
            HTTP_REQ_HOST="download.ecowitt.net"
            HTTP_REQ_PATH="/down/filewave?v=FirwaveReadme.txt"
            #HTTP_FIRMWARE_URL="http://$HTTP_REQ_HOST$HTTP_REQ_PATH"
            #curl --silent --show-error --user-agent "$HTTP_UA" "$HTTP_FIRMWARE_URL"
            { printf "GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\nConnection:close\r\n\r\n"  "$HTTP_REQ_PATH" "$HTTP_REQ_HOST" "$HTTP_UA"; sleep 2; } | "$NC_CMD" "$HTTP_REQ_HOST" 80
            shift 
            ;;

        -g | --gw)

            C_HOST="$2"
            #sendPacket "$CMD_READ_MAC"  "$C_HOST">/dev/null
            sendPacket "$CMD_READ_VERSION" "$C_HOST" >/dev/null 
            sendPacket "$CMD_READ_SYSTEM" "$C_HOST" >/dev/null  # find sensor type WH65/WH24 - &> redirect stderr+stdout - read_system not available on EasyWeather
            #sendPacket "$CMD_READ_SENSOR_ID_NEW" "$C_HOST" >/dev/null

            shift 2
            ;;

        -l | --listen)
            #WSL2
            #open TCP 8080 in windows firewall -> add rule to open
            #add portproxy from hostos to WSL2 distro/ubuntu
            #netsh interface portproxy add v4tov4 listenport=8080 listenaddress=192.168.3.3 connectaddress=172.22.134.109 connectport=8080
            # iex "netsh interface portproxy add v4tov4 listenport=8080 listenaddress=(Get-NetIPAddress -InterfaceAlias Wi-Fi -AddressFamily IPv4).IPAddress connectaddress=$(wsl -e hostname -I) connectport=8080"
            # iex = invoke-expression cmdlet
            #https://github.com/microsoft/WSL/issues/4150#issuecomment-504209723
            
            # Wunderground
            #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
            # Ecowitt
            #PASSKEY=976D09F15C.....................7&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro

            if argEmptyOrOption "$2"; then
                >&2 echo No port specified for listen
                EXITCODE_MAIN=$ERROR_LISTEN_NOPORT
                shift 
                continue #process next option
            elif ! isNumber "$2"; then
               >&2 echo Not a valid port number
               EXITCODE_MAIN=$ERROR_LISTEN_INVALID_PORTNUMBER
               shift; continue
            fi

            if [ -z "$LOG_CMD" ]; then
               httpServer "$2"
               EXITCODE_MAIN=$?
            else
               while true; do
                  if ! httpServer "$2"; then
                    [ $DEBUG -eq 1 ] && >&2 echo Failed http server listen $EXITCODE_HTTPSERVER
                    #EXITCODE_MAIN=$EXITCODE_HTTPSERVER
                    #break
                  fi
                done
            fi 

            shift 2
            ;;
   
        -s | --scan)

            if argEmptyOrOption "$2"; then
                discovery
                shift 1
            else
                discovery "$2"
                shift 2
            fi
            
            EXITCODE_MAIN=$EXITCODE_DISCOVERY

            ;;

        *)        # unknown option
            shift # past argument
            ;;
    esac

done

#typeset +f - list all function names/ksh93
#set # list all variables

[ "$DEBUG" -eq 1 ] && echo >&2 Exit code $EXITCODE_MAIN

cleanup

exit $EXITCODE_MAIN
