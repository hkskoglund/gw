#!/bin/sh
# Shell/terminal utility for viewing weather data and sensor configuration of the GW-1000 or compatible devices
# Only for firmware v1.6.5 or later - for intepretation of battery levels/sensor id new command

#Documentation:

#Protocol
# https://osswww.ecowitt.net/uploads/20210716/WN1900%20GW1000,1100%20WH2680,2650%20telenet%20v1.6.0%20.pdf (https://www.ecowitt.com/shop/forum/forumDetails/255)
#Shell
# mirbsd ksh http://www.mirbsd.org/htman/i386/man1/mksh.htm
#Netcat
#https://en.wikipedia.org/wiki/Netcat
#choosing which nc on fedora (openbsd/nmap)
#sudo alternatives --config nc
#ubuntu
# sudo update-alternatives --config nc
# sudo update-alternatives --query nc
#more sensor info for Fine Offset clones:
#https://www.wxforum.net/index.php?topic=40730.0

#testing in android shell
#adb push gw /sdcard && adb shell "sh  /sdcard/gw -h 192.168.3.80 -c livedata"

#set -x # enable for tracing in strace -f -c dash .c './gw -h 192.168.3.80 -c livedata'
#for s in bash dash ksh zsh; do strace -f -c $s -c './gw -h 192.168.3.80 -c livedata' 2>strace-log-$s; done
#not much to gain in time by avoiding subshell, but number of system calls is less. Try not to overoptimize.

#watch not compatible -> wrong formatting of \r\t\t\t sequences
#clear; while true; do  ../gw -A ../lang/gw-nbno.sh  -g 192.168.3.16 -Hb -c livedata; sleep 60; printf "\e[H"; done

export DEBUG="${DEBUG:=0}" # 1 will enable additional debug information, -d option to enable
[ $DEBUG -eq 1 ] && ls -l /bin/sh
DEBUG_OPTION_APPEND=0
DEBUG_OPTION_COMMAND=0
DEBUG_OPTION_HTTP=0
DEBUG_OPTION_TESTSENSOR=0
DEBUG_OPTION_TRACEPACKET=0

HTTP_WUNDERGROUND=1
HTTP_ECOWITT=0

MAX_16BIT_UINT=$(((2 << 16) - 1))
TIMEOUT_WIFICONFIG_SERVER=${TIMEOUT_WIFICONFIG_SERVER:=10} # timeout in seconds for wifi-server configuration of GW1000

GWDIR=${GWDIR:="."}
GW_VIEW_CSV_FILE=${GW_VIEW_CSV_FILE:="$GWDIR/view/csv.sh"}

GW_STYLE_LIMITS_FILE=${GW_STYLE_LIMITS_FILE:="$GWDIR/style/limits.sh"}
GW_STYLE_FILE=${GW_STYLE_FILE:="$GWDIR/style/ansiesc.sh"}

#shellcheck source=./style/limits.sh
. "$GW_STYLE_LIMITS_FILE"

#https://unicode-table.com/en/emoji/travel-and-places/sky-and-weather/
UNICODE_RAINRATE=${UNICODE_RAINRATE:=💧}
UNICODE_RAINEVENT=${UNICODE_RAINEVENT:=⛆}
UNICODE_RAINDAY=${UNICODE_RAINDAY:=⛆}
UNICODE_RAINHOUR=${UNICODE_RAINHOUR:=☔}

UNICODE_BATTERY=${UNICODE_BATTERY:=🔋}
UNICODE_BATTERY_LOW=${UNICODE_BATTERY_LOW:=🪫}
UNICODE_PLUG=${UNICODE_PLUG:=🔌}

UNICODE_SIGNAL=${UNICODE_SIGNAL:=📶}
UNICODE_SIGNAL_LOW=${UNICODE_SIGNAL_LOW:=🛑}

UNICODE_WIND=${UNICODE_WIND:=💨} #https://emojipedia.org/dashing-away/

#https://www.compart.com/en/unicode/block/U+2580
UNICODE_SIGNAL_LEVEL0=${UNICODE_SIGNAL_LEVEL0:="$UNICODE_SIGNAL_LOW"}
UNICODE_SIGNAL_LEVEL1=${UNICODE_SIGNAL_LEVEL1:="${UNICODE_SIGNAL}  25%"} # 1/4 packets received, seems to be a counter thats incremented/decremented after a each sensor periode
UNICODE_SIGNAL_LEVEL2=${UNICODE_SIGNAL_LEVEL2:="${UNICODE_SIGNAL}  50%"}
UNICODE_SIGNAL_LEVEL3=${UNICODE_SIGNAL_LEVEL3:="${UNICODE_SIGNAL}  75%"}
#UNICODE_SIGNAL_LEVEL4=${UNICODE_SIGNAL_LEVEL4:=▁▂▃▄}
UNICODE_SIGNAL_LEVEL4=${UNICODE_SIGNAL_LEVEL4:="${UNICODE_SIGNAL} 100%"} # 4/4 packets

#https://www.compart.com/en/unicode/block/U+2190
UNICODE_WIND_DIRECTION_S=${UNICODE_WIND_DIRECTION_S:=↑}
#UNICODE_WIND_DIRECTION_S=${UNICODE_WIND_DIRECTION_S:=▲}
UNICODE_WIND_DIRECTION_N=${UNICODE_WIND_DIRECTION_N:=↓}
#UNICODE_WIND_DIRECTION_N=${UNICODE_WIND_DIRECTION_N:=▼}
UNICODE_WIND_DIRECTION_E=${UNICODE_WIND_DIRECTION_E:=←}
#UNICODE_WIND_DIRECTION_E=${UNICODE_WIND_DIRECTION_E:=◀}
UNICODE_WIND_DIRECTION_W=${UNICODE_WIND_DIRECTION_W:=→}
#UNICODE_WIND_DIRECTION_W=${UNICODE_WIND_DIRECTION_W:=▶}
UNICODE_WIND_DIRECTION_NW=${UNICODE_WIND_DIRECTION_NW:=↘}
#UNICODE_WIND_DIRECTION_NW=${UNICODE_WIND_DIRECTION_NW:=◢}
UNICODE_WIND_DIRECTION_NE=${UNICODE_WIND_DIRECTION_NE:=↙}
#UNICODE_WIND_DIRECTION_NE=${UNICODE_WIND_DIRECTION_NE:=◣}
UNICODE_WIND_DIRECTION_SW=${UNICODE_WIND_DIRECTION_SW:=↗}
#UNICODE_WIND_DIRECTION_SW=${UNICODE_WIND_DIRECTION_SW:=◥}
UNICODE_WIND_DIRECTION_SE=${UNICODE_WIND_DIRECTION_SE:=↖}
#UNICODE_WIND_DIRECTION_SE=${UNICODE_WIND_DIRECTION_SE:=◤}

WIND_DIRECTION_N=${WIND_DIRECTION_N:="N"}
WIND_DIRECTION_E=${WIND_DIRECTION_E:="E"}
WIND_DIRECTION_S=${WIND_DIRECTION_S:="S"}
WIND_DIRECTION_W=${WIND_DIRECTION_W:="W"}

WIND_N=1
WIND_NNE=2
WIND_NE=3
WIND_ENE=4
WIND_E=5
WIND_ESE=6
WIND_SE=7
WIND_SSE=8
WIND_S=9
WIND_SSW=10
WIND_SW=11
WIND_WSW=12
WIND_W=13
WIND_WNW=14
WIND_NW=15
WIND_NNW=16

. $GWDIR/lib/beufort.sh

#ERROR_CONNECTION=1
#ERROR_NO_NMCLI=2
ERROR_NC_UDP_SCAN_UNAVAILABLE=3
ERROR_RAINDATA_NOTSPECIFIED=4
ERROR_SYSTEMPARAM_NOTSPECIFIED=5
ERROR_DEPENDENCY_NC=6
ERROR_PRX_PREAMBLE=7
ERROR_OD_BUFFER_EMPTY=8
ERROR_CONVERT=9
ERROR_HTTP_MESSSAGE_EMPTY=10
ERROR_NO_HOST_SPECIFIED=11
ERROR_INVALID_SENSORID=12
ERROR_INVALID_SENSORID_COMMAND=13
ERROR_LISTEN_INVALID_PORTNUMBER=14
ERROR_LISTEN_NOPORT=15
ERROR_LISTEN_UNSUPPORTED_NC=16
ERROR_COMMAND_UNKNOWN=17
ERROR_INVALID_SUBNET=18
ERROR_SSID_EMPTY=19
ERROR_PARSEPACKET_UNSUPPORTED_COMMAND=20
ERROR_WIFICONFIG_SERVER_FAILED=21 # fail response code 1 from GW
ERROR_CUSTOMIZED=22 #if customized settings is wrong

#HTTP_RESPONSE_200_OK="HTTP/1.1 200 OK"
#CRLF='\r\n'

LIVEDATA_VIEW_NORMAL=0
LIVEDATA_VIEW_TERSE=3
LIVEDATA_VIEW=${LIVIEDATA_VIEW:=$LIVEDATA_VIEW_NORMAL} #current live view

HIDE_RAIN_LIVEDATA_AUTO=${HIDE_RAIN_LIVEDATA_AUTO:=0} # auto hide_liveview when 0 today (0=off)
HIDE_LIGHT_LIVEDATA_AUTO=${HIDE_LIGHT_LIVEDATA_AUTO:=0} # auto hide_liveview when 0/dark

UNIT_TEMPERATURE_CELCIUS=0
UNIT_TEMPERATURE_FARENHEIT=1

UNIT_PRESSURE_HPA=0
UNIT_PRESSURE_INHG=1

UNIT_RAIN_MM=0
UNIT_RAIN_IN=1

UNIT_WIND_MPS=0
UNIT_WIND_MPH=1
UNIT_WIND_KMH=2

UNIT_UV_MICROWM2=0 # used by Ecowitt protocol
UNIT_UV_WATTM2=1

BATTERY_NORMAL=0
BATTERY_LOW=1
BATTERY_VOLTAGE_LOW=12 # scale x 10 <= 1.2V is low

NC_NMAP="nmap"
NC_OPENBSD="openbsd"
NC_TOYBOX="toybox"
NC_BUSYBOX="busybox"

PORT_GW_TCP=45000
PORT_WIFICONFIG_SERVER_TCP=49123 # method 1: in wifi configuration part 3 in spec.
PORT_GW_UDP=46000
PORT_CLIENT_UDP=59387

LOG_INTERVAL=${LOG_INTERVAL:=60} # default 60 seconds

SPATTERNID_CONNECTED=connected
SPATTERNID_DISCONNECTED=disconnected
SPATTERNID_SEARCHING=searching
SPATTERNID_DISABLED=disabled
SPATTERNID_RANGE=range

LIVEDATA_PROTOCOL_ECOWITT_BINARY="eb"
LIVEDATA_PROTOCOL_ECOWITT_BINARY_LONG="Ecowitt binary"
LIVEDATA_PROTOCOL_ECOWITT_HTTP="e"
LIVEDATA_PROTOCOL_ECOWITT_HTTP_LONG="Ecowitt"
LIVEDATA_PROTOCOL_WUNDERGROUND_HTTP="wu"
LIVEDATA_PROTOCOL_WUNDERGROUND_HTTP_LONG="Wunderground"

CMD_READ_VERSION=$((0x50)) #zsh - wont compare int with hex 16#50 in [ ] expression unless converted to decimal, works in [[ ]] expression
CMD_REBOOT=$((0x40))
CMD_READ_MAC=$((0x26))
CMD_WRITE_SSID=$((0x11))
CMD_BROADCAST=$((0x12))
CMD_WRITE_RESET=$((0x41))

#weather services
CMD_READ_ECOWITT_INTERVAL=$((0x1e))
CMD_WRITE_ECOWITT_INTERVAL=$((0x1f))
CMD_READ_WUNDERGROUND=$((0x20))
CMD_WRITE_WUNDERGROUND=$((0x21))
CMD_READ_WOW=$((0x22))
CMD_WRITE_WOW=$((0x23))
CMD_READ_WEATHERCLOUD=$((0x24))
CMD_WRITE_WEATHERCLOUD=$((0x25))

#customized server for ecowitt/wunderground http requests
CMD_READ_CUSTOMIZED=$((0x2a))
CMD_WRITE_CUSTOMIZED=$((0x2b))
CMD_READ_PATH=$((0x51))
CMD_WRITE_PATH=$((0x52))
CMD_READ_RAINDATA=$((0x34))
CMD_WRITE_RAINDATA=$((0x35))
CMD_LIVEDATA=$((0x27))

#sensors
CMD_READ_SENSOR_ID=$((0x3a))
CMD_WRITE_SENSOR_ID=$((0x3b))
CMD_READ_SENSOR_ID_NEW=$((0x3c)) # for new sensors
CMD_READ_SYSTEM=$((0x30))
CMD_WRITE_SYSTEM=$((0x31))
CMD_READ_CALIBRATION=$((0x38))
CMD_WRITE_CALIBRATION=$((0x39))

#livedata field number from specification

LDF_INTEMP=$((0x01))        #Indoor Temperature (℃) 2
LDF_OUTTEMP=$((0x02))       #Outdoor Temperature (℃) 2
#shellcheck disable=SC2034
{
LDF_DEWPOINT=$((0x03))      #Dew point (℃) 2
LDF_WINDCHILL=$((0x04))     #Wind chill (℃) 2
LDF_HEATINDEX=$((0x05))     #Heat index (℃) 2
}
LDF_INHUMI=$((0x06))        #Indoor Humidity (%) 1
LDF_OUTHUMI=$((0x07))       #Outdoor Humidity (%) 1
LDF_ABSBARO=$((0x08))       #Absolutely Barometric (hpa) 2
LDF_RELBARO=$((0x09))       #Relative Barometric (hpa) 2
LDF_WINDDIRECTION=$((0x0A)) #Wind Direction (360°) 2
LDF_WINDSPEED=$((0x0B))     #Wind Speed (m/s) 2
LDF_WINDGUSTSPPED=$((0x0C)) #Gust Speed (m/s) 2
LDF_RAINEVENT=$((0x0D))     #Rain Event (mm) 2
LDF_RAINRATE=$((0x0E))      #Rain Rate (mm/h) 2
#shellcheck disable=SC2034
LDF_RAINHOUR=$((0x0F))      #Rain hour (mm) 2
LDF_RAINDAY=$((0x10))       #Rain Day (mm) 2
LDF_RAINWEEK=$((0x11))      #Rain Week (mm) 2
LDF_RAINMONTH=$((0x12))     #Rain Month (mm) 4
LDF_RAINYEAR=$((0x13))      #Rain Year (mm) 4
#shellcheck disable=SC2034
LDF_RAINTOTALS=$((0x14))    #Rain Totals (mm) 4
LDF_LIGHT=$((0x15))         #Light (lux) 4
LDF_UV=$((0x16))            #UV (uW/m2) 2
LDF_UVI=$((0x17))           #UVI (0-15 index) 1
#shellcheck disable=SC2034
LDF_TIME=$((0x18))          #Date and time 6
LDF_DAYLWINDMAX=$((0X19))   #Day max wind(m/s) 2

#shellcheck disable=SC2034
{
    LDF_TEMP1=$((0x1A)) #Temperature 1(℃) 2
    LDF_TEMP2=$((0x1B)) #Temperature 2(℃) 2
    LDF_TEMP3=$((0x1C)) #Temperature 3(℃) 2
    LDF_TEMP4=$((0x1D)) #Temperature 4(℃) 2
    LDF_TEMP5=$((0x1E)) #Temperature 5(℃) 2
    LDF_TEMP6=$((0x1F)) #Temperature 6(℃) 2
    LDF_TEMP7=$((0x20)) #Temperature 7(℃) 2
    LDF_TEMP8=$((0x21)) #Temperature 8(℃) 2
    LDF_HUMI1=$((0x22)) #Humidity 1, 0-100% 1
    LDF_HUMI2=$((0x23)) #Humidity 2, 0-100% 1
    LDF_HUMI3=$((0x24)) #Humidity 3, 0-100% 1
    LDF_HUMI4=$((0x25)) #Humidity 4, 0-100% 1
    LDF_HUMI5=$((0x26)) #Humidity 5, 0-100% 1
    LDF_HUMI6=$((0x27)) #Humidity 6, 0-100% 1
    LDF_HUMI7=$((0x28)) #Humidity 7, 0-100% 1
    LDF_HUMI8=$((0x29)) #Humidity 8, 0-100% 1
}
LDF_PM25_CH1=$((0x2A))      #PM2.5 Air Quality Sensor(μg/m3) 2
LDF_SOILTEMP1=$((0x2B))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE1=$((0x2C)) #Soil Moisture(%) 1
LDF_SOILTEMP2=$((0x2D))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE2=$((0x2E)) #Soil Moisture(%) 1
LDF_SOILTEMP3=$((0x2F))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE3=$((0x30)) #Soil Moisture(%) 1
LDF_SOILTEMP4=$((0x31))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE4=$((0x32)) #Soil Moisture(%) 1
LDF_SOILTEMP5=$((0x33))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE5=$((0x34)) #Soil Moisture(%) 1
LDF_SOILTEMP6=$((0x35))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE6=$((0x36)) #Soil Moisture(%) 1
LDF_SOILTEMP7=$((0x37))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE7=$((0x38)) #Soil Moisture(%) 1
LDF_SOILTEMP8=$((0x39))     #Soil Temperature(℃) 2
LDF_SOILMOISTURE8=$((0x3A)) #Soil Moisture(%) 1
#shellcheck disable=SC2034
LDF_LOWBATT=$((0x4C))       #All sensor lowbatt 16 char 16
LDF_PM25_24HAVG1=$((0x4D))  # pm25_ch1 2
#shellcheck disable=SC2034
LDF_PM25_24HAVG2=$((0x4E)) # pm25_ch2 2
#shellcheck disable=SC2034
LDF_PM25_24HAVG3=$((0x4F)) # pm25_ch3 2
LDF_PM25_24HAVG4=$((0x50)) # pm25_ch4 2
LDF_PM25_CH2=$((0x51))     #PM2.5 Air Quality Sensor(μg/m3) 2
#shellcheck disable=SC2034
LDF_PM25_CH3=$((0x52)) #PM2.5 Air Quality Sensor(μg/m3) 2
LDF_PM25_CH4=$((0x53)) #PM2.5 Air Quality Sensor(μg/m3) 2
LDF_LEAK_CH1=$((0x58)) # Leak_ch1 1
#shellcheck disable=SC2034
LDF_LEAK_CH2=$((0x59)) # Leak_ch2 1
#shellcheck disable=SC2034
LDF_LEAK_CH3=$((0x5A))        # Leak_ch3 1
LDF_LEAK_CH4=$((0x5B))        # Leak_ch4 1
LDF_LIGHTNING=$((0x60))       # lightning distance （1~40KM） 1
LDF_LIGHTNING_TIME=$((0x61))  # lightning happened time(UTC) 4
LDF_LIGHTNING_POWER=$((0x62)) # lightning counter for the ay 4
#shellcheck disable=SC2034
{
    LDF_TF_USR1=$((0x63)) #Temperature(℃) 4
    LDF_TF_USR2=$((0x64)) #Temperature(℃) 4
    LDF_TF_USR3=$((0x65)) #Temperature(℃) 4
    LDF_TF_USR4=$((0x66)) #Temperature(℃) 4
    LDF_TF_USR5=$((0x67)) #Temperature(℃) 4
    LDF_TF_USR6=$((0x68)) #Temperature(℃) 4
    LDF_TF_USR7=$((0x69)) #Temperature(℃) 4
    LDF_TF_USR8=$((0x6A)) #Temperature(℃) 4
}
LDF_SENSOR_CO2=$((0x70)) #16
#shellcheck disable=SC2034
LDF_PM25_AQI=$((0x71))   #only for amb
# LDF_PM25_AQI length(n*2)(1byte) 1-aqi_pm25 2-aqi_pm25_24h ... ... n-aqi
#aqi_pm25 AQI derived from PM25 int
#aqi_pm25_24h AQI derived from PM25, 24 hour running average int
#aqi_pm25_in AQI derived from PM25 IN int
#aqi_pm25_in_24h AQI derived from PM25 IN, 24 hour running average int
#aqi_pm25_aqin AQI derived from PM25, AQIN sensor int
#aqi_pm25_24h_aqin AQI derived from PM25, 24 hour running average, AQIN sensor int
#.... n
#shellcheck disable=SC2034
{
    LDF_LEAF_WETNESS_CH1=$((0x72)) # 1
    LDF_LEAF_WETNESS_CH2=$((0x73)) # 1
    LDF_LEAF_WETNESS_CH3=$((0x74)) # 1
    LDF_LEAF_WETNESS_CH4=$((0x75)) # 1
    LDF_LEAF_WETNESS_CH5=$((0x76)) # 1
    LDF_LEAF_WETNESS_CH6=$((0x77)) # 1
    LDF_LEAF_WETNESS_CH7=$((0x78)) # 1
    LDF_LEAF_WETNESS_CH8=$((0x79)) # 1
}

CALIBRATION_INTEMPOFFSET_MAX=100
CALIBRATION_INHUMIOFFSET_MAX=10
CALIBRATION_ABSOFFSET_MAX=800
CALIBRATION_RELOFFSET_MAX=800
CALIBRATION_OUTTEMPOFFSET_MAX=100
CALIBRATION_OUTHUMIOFFSET_MAX=10
CALIBRATION_WINDDIROFFSET_MAX=180

CALIBRATION_RAIN_MAX=99999

UNIT_UNICODE_CELCIUS="℃"
UNIT_UNICODE_FARENHEIT="℉"
UNIT_UNICODE_WIND_MPS="m/s"
UNIT_UNICODE_PRESSURE_HPA="hPa"
UNIT_UNICODE_RAIN_MM="mm"

SYSTEM_FREQUENCY_RFM433M=0 # 433MHz
SYSTEM_FREQUENCY_RFM868M=1 # 868Mhz
SYSTEM_FREQUENCY_RFM915M=2 # 915MHz
SYSTEM_FREQUENCY_RFM920M=4 # 920Mhz

SYSTEM_SENSOR_TYPE_WH24=0
SYSTEM_SENSOR_TYPE_WH65=1

#https://www.wxforum.net/index.php?topic=40730.0
case $KSH_VERSION in

    *MIRBSD?KSH*)
        #shellcheck disable=SC3044
        typeset -iU SENSORID_SEARCH  SENSORID_DISABLE VALUE_UINT32BE  VALUE_UINT16BE VALUE_UINT8 SID VALUE_UINT_2SCOMPLEMENT # unsigned 32-bit 
        SENSORID_SEARCH=$(( 0xffffffff ))
        SENSORID_DISABLE=$(( 0xfffffffe ))
        # mksh - sets 0xffffffff to -1!? if typeset -i SENSORID_SEARCH=0xffffffff - its using 32-bit signed integer by default unless typeset -iU is used
        ;;

    *)
        SENSORID_SEARCH=$((0xffffffff))
        SENSORID_DISABLE=$((0xfffffffe))
        #ksh typeset option -iu for usigned int https://docstore.mik.ua/orelly/unix3/korn/appb_07.htm
        ;;
esac

SENSORTYPE_WH31TEMP_MAXCH=8
SENSORTYPE_WH51SOILMOISTURE_MAXCH=8
SENSORTYPE_WH43PM25_MAXCH=4
SENSORTYPE_WH55LEAK_MAXCH=4
SENSORTYPE_WH34SOILTEMP_MAXCH=8
SENSORTYPE_WH35LEAFWETNESS_MAXCH=8
SENSORTYPE_TF_USR_MAXCH=8

#index into "sensor id new" data
SENSORTYPE_WH68=1
SENSORTYPE_WH80=2
SENSORTYPE_WH40=3
SENSORTYPE_WH32=5
SENSORTYPE_WH31TEMP=6 # temp. sensors start at 6
SENSORTYPE_WH51SOILMOISTURE=14
SENSORTYPE_WH43PM25=22
SENSORTYPE_WH57LIGHTNING=26
SENSORTYPE_WH55LEAK=27
SENSORTYPE_WH34SOILTEMP=31
SENSORTYPE_WH35LEAFWETNESS=40
SENSORTYPE_MAX=47 

SENSORIDSTATE_CONNECTED=${SENSORIDSTATE_CONNECTED:="connected"}
SENSORIDSTATE_DISCONNECTED=${SENSORIDSTATE_DISCONNECTED:="disconnected"} #sensortype specified, but signal still 0
SENSORIDSTATE_SEARCHING=${SENSORIDSTATE_SEARCHING:="searching"}
SENSORIDSTATE_DISABLED=${SENSORIDSTATE_DISABLED:="disabled"}
SENSORID_HEADER=${SENSORID_HEADER:="Sensor ID B S Type Name State Battery Signal"}


#default livedata headers, may be overridden by -A language file or environment variables on cmd line
export LIVEDATA_INTEMP_HEADER="${LIVEDATA_INTEMP_HEADER:="Indoor temperature"}"
export LIVEDATA_OUTTEMP_HEADER="${LIVEDATA_OUTTEMP_HEADER:="Outdoor temperature"}"
export LIVEDATA_INHUMI_HEADER="${LIVEDATA_INHUMI_HEADER:="Indoor humidity"}"
export LIVEDATA_OUTHUMI_HEADER="${LIVEDATA_OUTHUMI_HEADER:="Outdoor humidity"}"

export LIVEDATA_ABSBARO_HEADER="${LIVEDATA_ABSBARO_HEADER:="Absolute pressure"}"
export LIVEDATA_RELBARO_HEADER="${LIVEDATA_RELBARO_HEADER:="Relative pressure"}"

export LIVEDATA_WINDCHILL_HEADER="${LIVEDATA_WINDCHILL_HEADER:="Windchill"}"
export LIVEDATA_DEWPOINT_HEADER="${LIVEDATA_DEWPOINT_HEADER:="Dewpoint"}"

export LIVEDATA_WINDDAILYMAX_HEADER="${LIVEDATA_WINDDAILYMAX_HEADER:="Wind max."}"
export LIVEDATA_WINDDIRECTION_HEADER="${LIVEDATA_WINDDIRECTION_HEADER:="Wind direction"}"
export LIVEDATA_WINDDIRECTION_COMPASS_HEADER="${LIVEDATA_WINDDIRECTION_COMPASS_HEADER:="Wind compass direction"}"
export LIVEDATA_WINDGUSTSPEED_HEADER="${LIVEDATA_WINDGUSTSPEED_HEADER:="Wind gust"}"
export LIVEDATA_WINDSPEED_HEADER="${LIVEDATA_WINDSPEED_HEADER:="Wind"}"

export LIVEDATA_LIGHT_HEADER="${LIVEDATA_LIGHT_HEADER:="Light"}"
export LIVEDATA_UV_HEADER="${LIVEDATA_UV_HEADER:="Solar UV radiation"}"
export LIVEDATA_UVI_HEADER="${LIVEDATA_UVI_HEADER:="Solar UV index"}"

export LIVEDATA_RAINRATE_HEADER="${LIVEDATA_RAINRATE_HEADER:="Rain rate"}"
export LIVEDATA_RAINEVENT_HEADER="${LIVEDATA_RAINEVENT_HEADER:="Rain event"}"
export LIVEDATA_RAINHOUR_HEADER="${LIVEDATA_RAINHOUR_HEADER:="Rain hour"}"
export LIVEDATA_RAINDAY_HEADER="${LIVEDATA_RAINDAY_HEADER:="Rain day"}"
export LIVEDATA_RAINWEEK_HEADER="${LIVEDATA_RAINWEEK_HEADER:="Rain week"}"
export LIVEDATA_RAINMONTH_HEADER="${LIVEDATA_RAINMONTH_HEADER:="Rain month"}"
export LIVEDATA_RAINYEAR_HEADER="${LIVEDATA_RAINYEAR_HEADER:="Rain year"}"
export LIVEDATA_RAINTOTAL_HEADER="${LIVEDATA_RAINTOTAL_HEADER:="Rain total"}"

export LIVEDATA_LEAK_YES="${LIVEDATA_LEAK_YES:="YES"}"
export  LIVEDATA_LEAK_NO="${LIVEDATA_LEAK_NO:="NO "}"

export LIVEDATA_SOILMOISTURE_HEADER="${LIVEDATA_SOILMOISTURE_HEADER:="ＳＯＩＬＭＯＩＳＴＵＲＥ"}"
        export LIVEDATA_SOILTEMP_HEADER="${LIVEDATA_SOILTEMP_HEADER:="ＳＯＩＬＴＥＭＰＥＲＡＴＵＲＥ"}"
                export LIVEDATA_PM25_HEADER="${LIVEDATA_PM25_HEADER:="ＰＭ２.５ ＡＩＲ ＱＵＡＬＩＴＹ"}"
  export LIVEDATA_LEAFWETNESS_HEADER="${LIVEDATA_LEAFWETNESS_HEADER:="ＬＥＡＦＷＥＴＮＥＳＳ"}"
          export LIVEDATA_TEMPUSR_HEADER="${LIVEDATA_TEMPUSR_HEADER:="ＴＥＭＰＵＳＲ"}"
          export LIVEDATA_WH45CO2_HEADER="${LIVEDATA_WH45CO2_HEADER:="ＣＯ２"}"
      export LIVEDATA_LIGHTNING_HEADER="${LIVEDATA_LIGHTNING_HEADER:="ＬＩＧＨＴＮＩＮＧ"}"
                export LIVEDATA_LEAK_HEADER="${LIVEDATA_LEAK_HEADER:="ＬＥＡＫ"}"
                export LIVEDATA_RAIN_HEADER="${LIVEDATA_RAIN_HEADER:="ＲＡＩＮ"}"
              export LIVEDATA_SOLAR_HEADER="${LIVEDATA_SOLAR_HEADER:="ＳＯＬＡＲ"}"
                export LIVEDATA_WIND_HEADER="${LIVEDATA_WIND_HEADER:="ＷＩＮＤ"}"
        export LIVEDATA_PRESSURE_HEADER="${LIVEDATA_PRESSURE_HEADER:="ＰＲＥＳＳＵＲＥ"}"
                export LIVEDATA_TEMP_HEADER="${LIVEDATA_TEMP_HEADER:="ＴＥＭＰＥＲＡＴＵＲＥ"}"
                    export LIVEDATA_HEADER="${LIVEDATA_HEADER:="ＴＥＭＰＥＲＡＴＵＲＥ"}"
                    export LIVEDATA_SYSTEM_HEADER="${LIVEDATA_SYSTEM_HEADER:="ＳＹＳＴＥＭ"}"
                    export LIVEDATA_SENSOR_HEADER="${LIVEDATA_SENSOR_HEADER:="ＳＥＮＳＯＲ"}"

export LIVEDATA_LIGHTNING_DISTANCE_HEADER="${LIVEDATA_LIGHTNING_DISTANCE_HEADER:="Lightning distance (last)"}"
export LIVEDATA_LIGHTNING_TIME_UTC_HEADER="${LIVEDATA_LIGHTNING_TIME_UTC_HEADER:="Lightning time utc (last)"}"
export LIVEDATA_LIGHTNING_POWER_HEADER="${LIVEDATA_LIGHTNING_POWER_HEADER:="Lightning count today"}"

export LIVEDATA_WH45CO2_TEMPF_HEADER="${LIVEDATA_WH45CO2_TEMPF_HEADER:="Temperature"}"
export LIVEDATA_WH45CO2_HUMI_HEADER="${LIVEDATA_WH45CO2_HUMI_HEADER:="Humidity"}"
export LIVEDATA_WH45CO2_PM10_HEADER="${LIVEDATA_WH45CO2_PM10_HEADER:="PM10"}"
export LIVEDATA_WH45CO2_PM10_24HAVG_HEADER="${LIVEDATA_WH45CO2_PM10_24HAVG_HEADER:="PM10 24h avg."}"
export LIVEDATA_WH45CO2_PM25_HEADER="${LIVEDATA_WH45CO2_PM25_HEADER:="PM25"}"
export LIVEDATA_WH45CO2_PM25_24HAVG_HEADER="${LIVEDATA_WH45CO2_PM25_24HAVG_HEADER:="PM25 24h avg."}"
export LIVEDATA_WH45CO2_CO2_HEADER="${LIVEDATA_WH45CO2_CO2_HEADER:="CO2"}"
export LIVEDATA_WH45CO2_CO2_24HAVG_HEADER="${LIVEDATA_WH45CO2_CO2_24HAVG_HEADER:="CO2 24h avg."}"
export LIVEDATA_WH45CO2_BATTERY_HEADER="${LIVEDATA_WH45CO2_BATTERY_HEADER:="CO2 battery"}"

export LIVEDATA_WH65_BATTERY_HEADER="${LIVEDATA_WH65_BATTERY_HEADER:="WH65 Weather station"}"
export LIVEDATA_WH68_BATTERY_HEADER="${LIVEDATA_WH68_BATTERY_HEADER:="WH68 Weather station"}"
export LIVEDATA_WH80_BATTERY_HEADER="${LIVEDATA_WH80_BATTERY_HEADER:="WH80 Weather station"}"

export LIVEDATA_WH32_TEMPERATURE_BATTERY_HEADER="${LIVEDATA_WH32_TEMPERATURE_BATTERY_HEADER:="Temperature out battery"}"
export LIVEDATA_WH40_RAINFALL_BATTERY_HEADER="${LIVEDATA_WH40_RAINFALL_BATTERY_HEADER:="Rainfall battery"}"
export LIVEDATA_WH57_LIGHTNING_BATTERY_HEADER="${LIVEDATA_WH57_LIGHTNING_BATTERY_HEADER="Lightning battery"}" 

export    LIVEDATA_SYSTEM_SENSOR_CONNECTED_HEADER="${LIVEDATA_SYSTEM_SENSOR_CONNECTED_HEADER:="System sensors connected"}"
export    LIVEDATA_SYSTEM_SENSOR_DISCONNECTED_HEADER="${LIVEDATA_SYSTEM_SENSOR_DISCONNECTED_HEADER:="System sensors disconnected"}"
export    LIVEDATA_SYSTEM_SENSOR_SEARCHING_HEADER="${LIVEDATA_SYSTEM_SENSOR_SEARCHING_HEADER:="System sensors searching"}"
export    LIVEDATA_SYSTEM_SENSOR_DISABLED_HEADER="${LIVEDATA_SYSTEM_SENSOR_DISABLED_HEADER:="System sensors disabled"}"

export LIVEDATA_SYSTEM_PROTOCOL_HEADER="${LIVEDATA_SYSTEM_PROTOCOL_HEADER:="System protocol"}"
export LIVEDATA_SYSTEM_TIMEZONE_AUTO_HEADER="${LIVEDATA_SYSTEM_TIMEZONE_AUTO_HEADER:="System timezone AUTO"}"
export LIVEDATA_SYSTEM_TIMEZONE_DST_HEADER="${LIVEDATA_SYSTEM_TIMEZONE_DST_HEADER:="System timezone DST"}"
export LIVEDATA_SYSTEM_TIMEZONE_HEADER="${LIVEDATA_SYSTEM_TIMEZONE_HEADER:="System timezone (manual)"}"

export LIVEDATA_STATE_ON="${LIVEDATA_STATE_ON:="on"}"
export LIVEDATA_STATE_OFF="${LIVEDATA_STATE_OFF:="off"}"

N=1
while [ "$N" -le "$SENSORTYPE_WH31TEMP_MAXCH" ]; do 
    eval export LIVEDATA_TEMP_HEADER$N=\"\$\{LIVEDATA_TEMP_HEADER$N:=\"Temperature $N\"\}\"
    eval export LIVEDATA_TEMP_BATTERY_HEADER$N=\"\$\{LIVEDATA_TEMP_BATTERY_HEADER$N:=\"Temperature $N battery\"\}\"
    eval export LIVEDATA_HUMIDITY_HEADER$N=\"\$\{LIVEDATA_HUMIDITY_HEADER$N:=\"Humidity $N\"\}\"
    N=$(( N + 1 ))
done

N=1
while [ "$N" -le "$SENSORTYPE_WH55LEAK_MAXCH" ]; do 
    eval export LIVEDATA_LEAK_HEADER$N=\"\$\{LIVEDATA_LEAK_HEADER$N:="Leak $N"\}\"
    eval export LIVEDATA_LEAK_BATTERY_HEADER$N=\"\$\{LIVEDATA_LEAK_BATTERY_HEADER$N:="Leak $N battery"\}\"
    N=$(( N + 1 ))
done


N=1
while [ "$N" -le "$SENSORTYPE_WH43PM25_MAXCH" ]; do 
    eval export LIVEDATA_PM25_HEADER$N=\"\$\{LIVEDATA_PM25_HEADER$N:="PM 2.5 $N"\}\"
    eval export LIVEDATA_PM25_24HAVG_HEADER$N=\"\$\{LIVEDATA_PM25_24HAVG_HEADER$N:="PM 2.5 24h avg. $N"\}\"
    eval export LIVEDATA_PM25_BATTERY_HEADER$N=\"\$\{LIVEDATA_PM25_BATTERY_HEADER$N:="PM 2.5 $N battery"\}\"
    N=$(( N + 1 ))
done

N=1
while [ "$N" -le "$SENSORTYPE_WH51SOILMOISTURE_MAXCH" ]; do 
    eval export LIVEDATA_SOILMOISTURE_HEADER$N=\"\$\{LIVEDATA_SOILMOISTURE_HEADER$N:="Soilmoisture $N"\}\"
    eval export LIVEDATA_SOILMOISTURE_BATTERY_HEADER$N=\"\$\{LIVEDATA_SOILMOISTURE_BATTERY_HEADER$N:="Soilmoisture $N battery"\}\"
    N=$(( N + 1 ))
done

N=1
while [ "$N" -le "$SENSORTYPE_WH34SOILTEMP_MAXCH" ]; do 
    eval export LIVEDATA_SOILTEMP_HEADER$N=\"\$\{LIVEDATA_SOILTEMP_HEADER$N:="Soiltemperature $N"\}\"
    eval export LIVEDATA_SOILTEMP_BATTERY_HEADER$N=\"\$\{LIVEDATA_SOILTEMP_BATTERY_HEADER$N:="Soiltemperatur $N battery"\}\"
    N=$(( N + 1 ))
done

N=1
while [ "$N" -le "$SENSORTYPE_WH35LEAFWETNESS_MAXCH" ]; do 
    eval export LIVEDATA_LEAFWETNESS_HEADER$N=\"\$\{LIVEDATA_LEAFWETNESS_HEADER$N:="Leafwetness $N"\}\"
    eval export LIVEDATA_LEAFWETNESS_BATTERY_HEADER$N=\"\$\{LIVEDATA_LEAFWETNESS_BATTERY_HEADER$N:="Leafwetness $N battery"\}\"
    N=$(( N + 1 ))
done

N=1
while [ "$N" -le "$SENSORTYPE_TF_USR_MAXCH" ]; do 
    eval export LIVEDATA_TF_USR_HEADER$N=\"\$\{LIVEDATA_TF_USR_HEADER$N:="Temperature USR $N"\}\"
    eval export LIVEDATA_TF_USR_BATTERY_HEADER$N=\"\$\{LIVEDATA_TF_USR_BATTERY_HEADER$N:="Temperature USR $N battery"\}\"
    N=$(( N + 1 ))
done

export LIVEDATA_SYSTEM_VERSION_HEADER="${LIVEDATA_SYSTEM_VERSION_HEADER:="System version"}"
export LIVEDATA_SYSTEM_UTC_HEADER="${LIVEDATA_SYSTEM_UTC_HEADER:="System utc"}"
export LIVEDATA_SYSTEM_FREQUENCY_HEADER="${LIVEDATA_SYSTEM_FREQUENCY_HEADER:="System frequency"}"
export LIVEDATA_SYSTEM_MODEL_HEADER="${LIVEDATA_SYSTEM_MODEL_HEADER:="System model"}"
export LIVEDATA_SYSTEM_SENSORTYPE_HEADER="${LIVEDATA_SYSTEM_SENSORTYPE_HEADER:="System type"}"

VALUE_PM25_AQI_DELIMITER='-'
#shellcheck disable=SC2034
VALUE_LEAK_DELIMITER='-'
VALUE_UVI_DELIMITER='-'
VALUE_COMPASS_DELIMITER='-'
VALUE_BEUFORT_DELIMITER='-'
VALUE_RAININTENSITY_DELIMITER='-'

#is sent in http get request when data from sensors are not available, for example after reboot
WUNDERGROUND_UNDEFINED_VALUE="-9999"

#list all capabilities to terminal: infocmp/infocmp -L https://en.wikipedia.org/wiki/Terminal_capabilities
# it capability = tab size = 8 for xterm-256
# watch -c command only supports 3-bit colors in wsl2/ubuntu, other ansi escapes codes are filtered

. $GWDIR/lib/pm25.sh
. $GWDIR/lib/rainintensity.sh
. $GWDIR/lib/uvi.sh

setBatteryLowNormal()
{
     getBatteryLowOrNormal "$2" 
    eval "LIVEDATA_${1}_BATTERY=$2"
    eval "LIVEDATA_${1}_BATTERY_STATE='$SBATTERY_STATE'"
}

setBatteryVoltageLevel()
{
    getBatteryVoltageLevelState "$2"
    eval "LIVEDATA_${1}_BATTERY_RAW=$2"
    eval "LIVEDATA_${1}_BATTERY=$VALUE_BATTERY_VOLTAGE"
    eval "LIVEDATA_${1}_BATTERY_STATE='$SBATTERY_STATE'"
}

setBatteryLevel()
{
    getBatteryLevelState "$2"
    eval "LIVEDATA_${1}_BATTERY=$2"
    eval "LIVEDATA_${1}_BATTERY_STATE='$SBATTERY_STATE'"
}

getSensorBatteryState()
{
   
    #specification FOS_ENG-022-A, page 28
    unset SBATTERY_STATE

     case "$1" in
        0) setBatteryLowNormal "WH65" "$2" # WH65
            ;;
        1) setBatteryVoltageLevel "WH68" "$2"
            ;;
        2) setBatteryVoltageLevel "WH80" "$2"
            ;;
        3) setBatteryLowNormal "WH40_RAINFALL" "$2"
            ;;
        5) setBatteryLowNormal "WH32_TEMPERATURE" "$2"
            ;;
        6|7|8|9|10|11|12|13)
           channel=$(($1 - 5))
           setBatteryLowNormal "TEMP$channel" "$2"
           ;;
        14|15|16|17|18|19|20|21)
           channel=$(( $1 - 13))
           setBatteryVoltageLevel "SOILMOISTURE$channel" "$2"
          ;;
        22|23|24|25)
          channel=$(( $1 - 21 ))
          setBatteryLevel "PM25$channel" "$2"
          ;;
        26)
          setBatteryLevel "WH57_LIGHTNING" "$2"
          ;;
        27|28|29|30)
          channel=$(( $1 - 26 ))
          setBatteryLevel "LEAK$channel" "$2"
          ;;
        31|32|33|34|35|36|37|38)
           channel=$(( $1 - 30))
           setBatteryVoltageLevel "SOILTEMP$channel" "$2"
           ;;
        39)
           setBatteryLevel "WH45CO2" "$2"
           #battery info also available from sensor read livedata
          ;;
        40|41|42|43|44|45|46|47)
           channel=$(( $1 - 39))
           setBatteryVoltageLevel "LEAFWETNESS$channel" "$2"
           ;;
    esac

    unset channel
}

getSensorNameShort()
{
    case "$1" in
        0) if [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH24 ]; then
             SENSORNAME_WH='WH24'
             SENSORNAME_SHORT='Weather Station'
            else
              SENSORNAME_WH='WH65'
              SENSORNAME_SHORT="Weather Station"
            fi
            ;;
        1) SENSORNAME_WH='WH68'
           SENSORNAME_SHORT="Weather Station"
            ;;
        2) SENSORNAME_WH="WH80"
           SENSORNAME_SHORT='Weather Station'
            ;;
        3) SENSORNAME_WH="WH40"
           SENSORNAME_SHORT="Rainfall"
            ;;
        5) SENSORNAME_WH='WH32'
           SENSORNAME_SHORT='Temperatue out'
            ;;
        6|7|8|9|10|11|12|13)
           SENSORNAME_WH='WH31'
           SENSORNAME_SHORT="Temperature$(($1 - 5))"
           ;;
        14|15|16|17|18|19|20|21)
          SENSORNAME_WH='WH51'
          SENSORNAME_SHORT="Soilmoisture$(($1 - 13))"
          ;;
        22|23|24|25)
          SENSORNAME_WH='WH43'
          SENSORNAME_SHORT="PM2.5 AQ $(($1 - 21))"
          ;;
        26)
          SENSORNAME_SHORT="Lightning"
          SENSORNAME_WH='WH57'
          ;;
        27|28|29|30)
          SENSORNAME_WH='WH55'
          SENSORNAME_SHORT="Leak$(($1 - 26))"
          ;;
        31|32|33|34|35|36|37|38)

          SENSORNAME_WH='WH34'
          SENSORNAME_SHORT="Soiltemperature$(($1 - 30))"
          ;;
        39)
          SENSORNAME_WH='WH45'
          SENSORNAME_SHORT="CO2 PM2.5 PM10 AQ"
          ;;
        40|41|42|43|44|45|46|47)
            SENSORNAME_WH='WH35'
            SENSORNAME_SHORT="Leafwetness$(($1 - 39))"
           ;;
         *)
         echo >&2 "Warning: Unknown sensortype $1"
          SENSORNAME_WH='WH??' 
          SENSORNAME_SHORT='?'
    esac
}

getCommandName() { #$1 -decimal command
    case "$1" in
        "$CMD_READ_VERSION")            COMMAND_NAME='read version' ;;
        "$CMD_READ_VERSION")            COMMAND_NAME='read version' ;;
        "$CMD_REBOOT")                  COMMAND_NAME='reboot' ;;
        "$CMD_READ_MAC")                COMMAND_NAME='read mac' ;;
        "$CMD_WRITE_SSID")              COMMAND_NAME='write ssid' ;;
        "$CMD_BROADCAST")               COMMAND_NAME='broadcast' ;;
        "$CMD_WRITE_RESET")             COMMAND_NAME='write reset' ;;
        "$CMD_READ_ECOWITT_INTERVAL")   COMMAND_NAME='read ecowitt interval' ;;
        "$CMD_WRITE_ECOWITT_INTERVAL")  COMMAND_NAME='write ecowitt interval' ;;
        "$CMD_READ_WUNDERGROUND")       COMMAND_NAME='read wunderground' ;;
        "$CMD_WRITE_WUNDERGROUND")      COMMAND_NAME='write wunderground' ;;
        "$CMD_READ_WOW")                COMMAND_NAME='read wow' ;;
        "$CMD_WRITE_WOW")               COMMAND_NAME='write wow' ;;
        "$CMD_READ_WEATHERCLOUD")       COMMAND_NAME='read weathercloud' ;;
        "$CMD_WRITE_WEATHERCLOUD")      COMMAND_NAME='write weathercloud' ;;
        "$CMD_READ_CUSTOMIZED")         COMMAND_NAME='read customized' ;;
        "$CMD_WRITE_CUSTOMIZED")        COMMAND_NAME='write customized' ;;
        "$CMD_READ_PATH")               COMMAND_NAME='read path' ;;
        "$CMD_WRITE_PATH")              COMMAND_NAME='write path' ;;
        "$CMD_READ_RAINDATA")           COMMAND_NAME='read raindata' ;;
        "$CMD_WRITE_RAINDATA")          COMMAND_NAME='write raindata' ;;
        "$CMD_LIVEDATA")                COMMAND_NAME='livedata' ;;
        "$CMD_READ_SENSOR_ID")          COMMAND_NAME='read sensor id' ;;
        "$CMD_WRITE_SENSOR_ID")         COMMAND_NAME='write sensor id' ;;
        "$CMD_READ_SENSOR_ID_NEW")      COMMAND_NAME='read sensor id new' ;;
        "$CMD_READ_SYSTEM")             COMMAND_NAME='read system' ;;
        "$CMD_WRITE_SYSTEM")            COMMAND_NAME='write system' ;;
        "$CMD_READ_CALIBRATION")        COMMAND_NAME='read calibration' ;;
        "$CMD_WRITE_CALIBRATION")       COMMAND_NAME='write calibration' ;;
    esac
    
    if [ -z "$COMMAND_NAME" ]; then
        COMMAND_NAME="{cmdname missing} $1"
        return 1
    fi
}

newBuffer() {
    eval "$1=\"$2\""
}

writeUInt32BE() {
    PACKET_TX_BODY="$PACKET_TX_BODY $(($1 >> 24)) $((($1 & 0xff0000) >> 16))  $((($1 & 0xff00) >> 8))  $(($1 & 0xff)) "
}

writeUInt16BE() {
    [ "$DEBUG" -eq 1 ] && >&2 echo writeUInt16BE "$1" 
    PACKET_TX_BODY="$PACKET_TX_BODY $(($1 >> 8)) $(($1 & 0xff)) "
}

writeUInt8() {
    PACKET_TX_BODY="$PACKET_TX_BODY $1 "
}

readSlice() { #$1 - number of bytes n to read
    #read bytes available in $B1,...,$Bn

    n=1
    while [ "$n" -le "$1" ]; do
        readUInt8
        eval "B$n=$VALUE_UINT8"
        if [ "$n" -le 6 ]; then # auto convert to hex for printing of MAC/broadcast command
        #shellcheck disable=SC2027
           eval "convertUInt8ToHex \"\$B$n\"; B"$n"HEX=\$VALUE_UINT8_HEX"
        fi
        n=$((n + 1))
    done

    unset n
}

readUInt8() {
    unset VALUE_UINT8

    if [ ${#OD_BUFFER} -ge 4 ]; then # 4 = max 3 spaces and 1 digit

        for BYTE in $OD_BUFFER; do
            VALUE_UINT8=$((BYTE))
            OD_BUFFER=${OD_BUFFER#*"$BYTE"} #  # - remove shortest prefix pattern
            break
        done
    else
        return "$ERROR_OD_BUFFER_EMPTY"
    fi
    unset BYTE
}

readInt8() {
#8-bit=sign bit
    readUInt8
    VALUE_INT8=$((-1 * (VALUE_UINT8 >> 7) * 0x80 + (VALUE_UINT8 & 0x7f)))
}

readUInt16BE() {
    unset VALUE_UINT16BE

    readUInt8
    msb=$VALUE_UINT8
    readUInt8
    VALUE_UINT16BE=$(((msb << 8) | VALUE_UINT8))
    unset msb
}

readUInt32BE() {
    unset VALUE_UINT32BE

    if [ ${#OD_BUFFER} -ge 19 ]; then
        readUInt8
        msb=$VALUE_UINT8

        readUInt8
        lsb=$VALUE_UINT8
       
        readUInt8
        msb2=$VALUE_UINT8
       
        readUInt8
        lsb2=$VALUE_UINT8

        VALUE_UINT32BE=$(((msb << 24) | (lsb << 16) | (msb2 << 8) | lsb2))
    else
        return "$ERROR_OD_BUFFER_EMPTY"
    fi

    unset msb lsb msb2 lsb2
}

readInt16BE() { #2's complement big endian
    #msb is the sign bit
    #VALUE_INT16BE_HEX=$hexstr
    #Converting from two's complement representation https://en.wikipedia.org/wiki/Two%27s_complement

    readUInt16BE

    VALUE_INT16BE=$((-1 * (VALUE_UINT16BE >> 15) * 32768 + (VALUE_UINT16BE & 32767)))
}

readInt32BE() { #2's complement big endian
    #msb is the sign bit
    #DEBUG_READWRITE_INT=1
    DEBUG_READWRITE_INT=${DEBUG_READWRITE_INT:=$DEBUG}

    readUInt32BE
    VALUE_INT32BE=$((-1 * (VALUE_UINT32BE >> 31) * 0x80000000 + (VALUE_UINT32BE & 0x7fffffff)))
    [ $DEBUG_READWRITE_INT -eq 1 ] && echo >&2 "readInt32BE unsigned 32-bit $VALUE_UINT32BE to signed 32-bit $VALUE_INT32BE"

}

convertFloat8To2sComplement()
{
    convertFloatTo2sComplement "$1" 8
}

convertFloat16To2sComplement()
{
    convertFloatTo2sComplement "$1" 16
}

convertFloat32To2sComplement()
{
    convertFloatTo2sComplement "$1" 32
}

convertFloatTo2sComplement()
#convert N-bit signed float to 2's complement, big endian: most significant bits to the left
#$1 - number, $2 - N bits
{
    DEBUG_CONVERT=1
    DEBUG_CONVERT=${DEBUG_CONVERT:=$DEBUG}

    case "$1" in
        -*) number=${1#-} # remove sign from negative number
            VALUE_UINT_2SCOMPLEMENT=$(( (2 << $2) - number))  # 2 << 31 = 2**32, 2scomplement + number = 2^N
            ;;
        
        *)  VALUE_UINT_2SCOMPLEMENT=$1 
            ;;
    esac

   [ $DEBUG_CONVERT -eq 1 ] &&  echo >&2 "convertFloatTo2sComplement convert $1 to unsigned $2-bit $VALUE_UINT_2SCOMPLEMENT"

}

writeInt32BE()
{
    convertFloat32To2sComplement "$1"
    writeUInt32BE "$VALUE_UINT_2SCOMPLEMENT"
}

writeInt16BE()
{
    
    convertFloat16To2sComplement "$1"
    writeUInt16BE "$VALUE_UINT_2SCOMPLEMENT"
}

writeInt8()
{
    convertFloat8To2sComplement "$1"
    writeUInt8 "$VALUE_UINT_2SCOMPLEMENT"
}

writeString()
{
  # PACKET_TX_BODY="${#1} $(printf "%s" "$1" | od -A n -t u1)"

    str=$1
    len=${#str}

    [ "$DEBUG" -eq 1 ] && >&2 echo  "writeString $1 len $len"

    PACKET_TX_BODY="$PACKET_TX_BODY $len"
    unset APPEND_FORMAT_WRITE_STRING APPEND_STRING

    n=1
    while [ -n "$str" ]; do
        suffix=${str#?}
        eval C$n='${str%%"$suffix"}'
        APPEND_FORMAT_WRITE_STRING=$APPEND_FORMAT_WRITE_STRING'%d ' # wait with printf-processing until entire sting is built
        APPEND_STRING=$APPEND_STRING'\"$'"C$n " # \'$var or \"$var - char to ascii conversion in printf bulitin/command argument
        str=$suffix
        n=$(( n + 1 ))
    done

    if [ "$SHELL_SUPPORT_BULTIN_PRINTF_VOPT" -eq  1 ] && [ -n "$APPEND_FORMAT_WRITE_STRING" ]; then
        eval printf -v decstr \""$APPEND_FORMAT_WRITE_STRING"\" "$APPEND_STRING"
        #shellcheck disable=SC2154
        PACKET_TX_BODY="$PACKET_TX_BODY $decstr"
    elif [ -n "$APPEND_FORMAT_WRITE_STRING" ]; then
        PACKET_TX_BODY="$PACKET_TX_BODY $(eval printf \""$APPEND_FORMAT_WRITE_STRING"\" "$APPEND_STRING")" #ok, run in subshell
    fi

    #cleanup variables
    unset APPEND_FORMAT_WRITE_STRING APPEND_STRING
    n=1
    while [ "$n" -le "$len" ]; do
        unset C$n 
        n=$(( n + 1 ))
    done

    resetAppendBuffer

    unset len str decstr n

    [ "$DEBUG" -eq 1 ] && >&2 echo  "writeString $PACKET_TX_BODY"

}

readString() { #https://bugs.launchpad.net/ubuntu/+source/dash/+bug/1499473
    #\x formatted printf not supported in dash -> must use \nnn-octal
   
    readUInt8
    len_uint8=$VALUE_UINT8
    [ $DEBUG -eq 1 ] && echo >&2 "String length $len_uint8"

    unset VALUE_STRING_ESCAPE
    unset VALUE_STRING

    n=1
    while [ "$n" -le "$len_uint8" ]; do

        readUInt8

        convertHexToOctal "$VALUE_UINT8"
        VALUE_STRING_ESCAPE="$VALUE_STRING_ESCAPE\\0$VALUE_OCTAL"

        n=$((n + 1))

    done

    if [ "$SHELL_SUPPORT_BULTIN_PRINTF_VOPT" -eq 1 ]; then
        #shellcheck disable=SC3045
         printf -v VALUE_STRING "%b" "$VALUE_STRING_ESCAPE"
    else
       VALUE_STRING=$(printf "%b" "$VALUE_STRING_ESCAPE") # convert to string
    fi
   
    unset len_uint8 n
}

printBuffer()
#$1 decimal buffer - print as hex buffer
 {
    unset APPEND_STRING

    for BYTE in $1; do
        convertUInt8ToHex "$BYTE"
        APPEND_STRING=$APPEND_STRING" $VALUE_UINT8_HEX"
    done
    
    echo "$APPEND_STRING"

    unset BYTE APPEND_STRING

}

convertWindDirectionToCompassDirection() { #$1 - direction in degrees
    #http://snowfence.umn.edu/Components/winddirectionanddegrees.htm
    unset VALUE_COMPASS_DIRECTION

    if [ "$1" -le 11 ] || [ "$1" -gt 349 ]; then
        VALUE_COMPASS=$WIND_N
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_N
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_N
    elif [ "$1" -gt 11 ] && [ "$1" -lt 34 ]; then
        VALUE_COMPASS=$WIND_NNE
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_NNE
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_NE
    elif [ "$1" -ge 34 ] && [ "$1" -le 56 ]; then
        VALUE_COMPASS=$WIND_NE
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_NE
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_NE
    elif [ "$1" -gt 56 ] && [ "$1" -le 79 ]; then
        VALUE_COMPASS=$WIND_ENE
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_ENE
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_NE
    elif [ "$1" -gt 79 ] && [ "$1" -le 101 ]; then
        VALUE_COMPASS=$WIND_E
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_E
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_E
    elif [ "$1" -gt 101 ] && [ "$1" -le 124 ]; then
        VALUE_COMPASS=$WIND_ESE
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_ESE
         UNICODE_WIND=$UNICODE_WIND_DIRECTION_SE
    elif [ "$1" -gt 124 ] && [ "$1" -le 146 ]; then
       VALUE_COMPASS=$WIND_SE
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_SE
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_SE
    elif [ "$1" -gt 146 ] && [ "$1" -le 169 ]; then
        VALUE_COMPASS=$WIND_SSE
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_SSE
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_SE
    elif [ "$1" -gt 169 ] && [ "$1" -le 191 ]; then
        VALUE_COMPASS=$WIND_S
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_S
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_S
    elif [ "$1" -gt 191 ] && [ "$1" -le 214 ]; then
        VALUE_COMPASS=$WIND_SSW
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_SSW
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_SW
    elif [ "$1" -gt 214 ] && [ "$1" -le 236 ]; then
        VALUE_COMPASS=$WIND_SW
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_SW
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_SW
    elif [ "$1" -gt 236 ] && [ "$1" -le 259 ]; then
        VALUE_COMPASS=$WIND_WSW
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_WSW
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_SW
    elif [ "$1" -gt 259 ] && [ "$1" -le 281 ]; then
        VALUE_COMPASS=$WIND_W
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_W
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_W
    elif [ "$1" -gt 281 ] && [ "$1" -le 304 ]; then
        VALUE_COMPASS=$WIND_WNW
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_WNW
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_NW
    elif [ "$1" -gt 304 ] && [ "$1" -le 326 ]; then
        VALUE_COMPASS=$WIND_NW
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_NW
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_NW
    elif [ "$1" -gt 326 ] && [ "$1" -le 349 ]; then
        VALUE_COMPASS=$WIND_NNW
        VALUE_COMPASS_DIRECTION=$WIND_DIRECTION_NNW
        UNICODE_WIND=$UNICODE_WIND_DIRECTION_NW
    fi
}

appendBatteryState()
{
   if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
        SBATTERY_STATE=$SBATTERY_STATE$UNICODE_BATTERY
   else
        SBATTERY_STATE=$SBATTERY_STATE"+"
   fi 
}

appendLowBatteryState()
{
    if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
    #https://emojipedia.org/low-battery/ "Coming to major platforms in late 2021 and throughout 2022".
         SBATTERY_STATE=$SBATTERY_STATE$UNICODE_BATTERY_LOW 
    else
        SBATTERY_STATE=$SBATTERY_STATE"LOW"
    fi
}

getBatteryVoltageLevelState()
#$1 - volatage scaled *10
{
     if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
  #      typeset -i  i
    :
    else
   #     local       i
    :
    fi

   unset SBATTERY_STATE

   if [ "$1" -le 12 ]; then
      appendLowBatteryState
   else
    # i=13
    # while [ "$i" -le "$1" ]; do
       appendBatteryState # not really linear, but approximate 
    #   i=$(( i + 1 ))
    # done
   fi
   convertScale10ToFloat "$1"
   VALUE_BATTERY_VOLTAGE="$VALUE_SCALE10_FLOAT"
   SBATTERY_STATE=$SBATTERY_STATE" ${VALUE_BATTERY_VOLTAGE}V"

   if [ -n "$KSH_VERSION" ]; then
        unset  i
    fi
}

getBatteryLevelState() { # $1 - battery level 0-6, 6 = dc, <=1 low
    
    unset SBATTERY_STATE
   
    #set -- 0     #debug  set $1 to 0
    if [ "$1" -eq 6 ]; then
      if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
       #https://emojipedia.org/electric-plug/
        SBATTERY_STATE=$UNICODE_PLUG
      else
        SBATTERY_STATE="dc" # for example PM 2.5 indoor
      fi
    else
       # l=1
       # while [ "$l" -le 5 ] ; do
       #     if [ "$l" -le "$1" ]; then
       #         appendBatteryState
       #     else
       #         appendLowBatteryState
       #     fi
       #     l=$((l + 1))
       # done
       if [ "$1" -le 1 ]; then
          appendLowBatteryState
       else
          appendBatteryState
       fi

       SBATTERY_STATE=$SBATTERY_STATE" $1"
    fi

    unset  l
}

getBatteryLowOrNormal() {
    
    unset SBATTERY_STATE

    if [ "$1" -eq $BATTERY_NORMAL ]; then
       appendBatteryState
    elif [ "$1" -eq $BATTERY_LOW ]; then
        appendLowBatteryState
    fi
}

toLowercase() {
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
        #shellcheck disable=SC3044
        typeset -l lowcasestr # -l option -> lowercase on assignment/or ignored
    fi

    if [ -n "$BASH_VERSION" ]; then
        eval 'LOWERCASE=${1,,}' #eval prevents ksh from stopping parsing on syntax error
    elif [ -n "$ZSH_VERSION" ]; then
        #shellcheck disable=SC3057
        LOWERCASE=${1:l}
    elif [ -n "$KSH_VERSION" ]; then
        # Android 11 runds mir bsd korn shell http://www.mirbsd.org/mksh.htm
        lowcasestr=$1
        LOWERCASE=$lowcasestr
    else
        LOWERCASE=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    fi

    if [ -n "$KSH_VERSION" ]; then
       unset lowcasestr
    fi

}


printSystem() 
{
    printf "%-32.32s%10u\t%s\n\
%-32.32s%10u\t%s\n\
%-32.32s%10u\t%s\n\
%-32.32s%10u\t%.24s\n\
%-32.32s%10u\t%s\n\
%-32.32s%10u\t%s\n"\
            "$LIVEDATA_SYSTEM_FREQUENCY_HEADER" "$C_SYSTEM_FREQUENCY" "$C_SYSTEM_FREQUENCY_STATE"\
            "$LIVEDATA_SYSTEM_SENSORTYPE_HEADER"    "$C_SYSTEM_SENSORTYPE" "$C_SYSTEM_SENSORTYPE_STATE"\
            "$LIVEDATA_SYSTEM_UTC_HEADER" "$C_SYSTEM_UTC" "$C_SYSTEM_UTC_STATE"\
            "$LIVEDATA_SYSTEM_TIMEZONE_HEADER"  "$C_SYSTEM_TIMEZONE_INDEX" "$C_SYSTEM_TIMEZONE_INDEX_STATE"\
            "$LIVEDATA_SYSTEM_TIMEZONE_AUTO_HEADER" "$C_SYSTEM_TIMEZONE_AUTO_BIT" "$C_SYSTEM_TIMEZONE_AUTO_STATE"\
            "$LIVEDATA_SYSTEM_TIMEZONE_DST_HEADER" "$C_SYSTEM_TIMEZONE_DST_BIT" "$C_SYSTEM_TIMEZONE_DST_STATUS_STATE"
}

parseSystem() {
    readUInt8

    C_SYSTEM_FREQUENCY=$VALUE_UINT8
    if [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM433M ]; then
        C_SYSTEM_FREQUENCY_STATE="433"
    elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM868M ]; then
        C_SYSTEM_FREQUENCY_STATE="868"
    elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM915M ]; then
        C_SYSTEM_FREQUENCY_STATE="915"
    elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM920M ]; then
        C_SYSTEM_FREQUENCY_STATE="920"
    fi

    readUInt8

    C_SYSTEM_SENSORTYPE=$VALUE_UINT8
    if [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH24 ]; then
        #       SENSOR_TYPE[WH24_TYPE]="WH24:Outdoor Weather Sensor:16.0:" # overwrite default WH65_TYPE=0
        C_SYSTEM_SENSORTYPE_STATE="WH24"
    elif [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH65 ]; then
        C_SYSTEM_SENSORTYPE_STATE="WH65"
    fi

    readUInt32BE

    C_SYSTEM_UTC=$VALUE_UINT32BE
    C_SYSTEM_UTC_STATE="$(date -u -d @"$VALUE_UINT32BE" +'%F %T')"

    readUInt8

    C_SYSTEM_TIMEZONE_INDEX=$VALUE_UINT8

    eval "C_SYSTEM_TIMEZONE_INDEX_STATE=\$SYSTEM_TIMEZONE_$C_SYSTEM_TIMEZONE_INDEX" # set from SYSTEM_TIMEZONE "array" variable with index

    C_SYSTEM_TIMEZONE_OFFSET_HOURS=${C_SYSTEM_TIMEZONE_INDEX_STATE%%\)*} # remove )... 
    C_SYSTEM_TIMEZONE_OFFSET_HOURS=${C_SYSTEM_TIMEZONE_OFFSET_HOURS#\(UTC} # remove (UTC

    readUInt8

    C_SYSTEM_TIMEZONE_DST_STATUS=$VALUE_UINT8

    C_SYSTEM_TIMEZONE_DST_BIT=$((C_SYSTEM_TIMEZONE_DST_STATUS & 0x01))

    C_SYSTEM_TIMEZONE_AUTOOFF_BIT=$(((C_SYSTEM_TIMEZONE_DST_STATUS & 0x2) >> 1)) # bit 2 1= off, 0=on ?

    if [ $C_SYSTEM_TIMEZONE_AUTOOFF_BIT = 0 ]; then #invert
       C_SYSTEM_TIMEZONE_AUTO_BIT=1;
    else
        C_SYSTEM_TIMEZONE_AUTO_BIT=0
    fi

     [ -z "$C_NOPRINT" ] && printSystem

}

copySystemToLivedata()
#copies system info to UI variables
{
    LIVEDATA_SYSTEM_FREQUENCY=$C_SYSTEM_FREQUENCY_STATE
    LIVEDATA_SYSTEM_SENSORTYPE=$C_SYSTEM_SENSORTYPE_STATE
    LIVEDATA_SYSTEM_UTC=$C_SYSTEM_UTC_STATE #local time 
    LIVEDATA_SYSTEM_TIMEZONE=$C_SYSTEM_TIMEZONE_INDEX_STATE
    LIVEDATA_SYSTEM_TIMEZONE_DST_BIT=$C_SYSTEM_TIMEZONE_DST_BIT
    LIVEDATA_SYSTEM_TIMEZONE_AUTO_BIT=$C_SYSTEM_TIMEZONE_AUTO_BIT
    LIVEDATA_SYSTEM_TIMEZONE_OFFSET_HOURS=$C_SYSTEM_TIMEZONE_OFFSET_HOURS

}

printEcowittInterval() {

    if [ "$C_WS_ECOWITT_INTERVAL" -eq 1 ]; then
        echo "ecowitt interval              $C_WS_ECOWITT_INTERVAL minute"
    elif [ "$C_WS_ECOWITT_INTERVAL" -gt 1 ]; then
        echo "ecowitt interval              $C_WS_ECOWITT_INTERVAL minutes"
    fi
}

parseEcowittInterval() {

    readUInt8
    C_WS_ECOWITT_INTERVAL=$VALUE_UINT8
    printEcowittInterval
}

printKeyValue() {
    printf "%-25s %s\n" "$1" "$2"
}

copyVersionToLivedata()
{
    LIVEDATA_SYSTEM_VERSION="$C_VERSION"
}

parseVersion() {
    readString
    C_VERSION="$VALUE_STRING"
    echo "$C_VERSION"
}

parseMAC() {
    
    readSlice 6
   
    C_MAC="$B1HEX:$B2HEX:$B3HEX:$B4HEX:$B5HEX:$B6HEX"
    echo "$C_MAC"
}

parseResult() {
    
    readUInt8
    write_result=$VALUE_UINT8
    VALUE_PACKET_WRITE_RESULT=$write_result

    if [ "$write_result" -eq 0 ]; then
    :
     #   echo >&2 "$COMMAND_NAME OK"
    elif [ "$write_result" -eq 1 ]; then
        echo >&2 "$COMMAND_NAME FAIL"
    fi

    unset write_result

}

isWriteCommand() {
    [ "$1" -eq $CMD_WRITE_ECOWITT_INTERVAL ] ||
        [ "$1" -eq $CMD_WRITE_RESET ] ||
        [ "$1" -eq $CMD_WRITE_CUSTOMIZED ] ||
        [ "$1" -eq $CMD_WRITE_PATH ] ||
        [ "$1" -eq $CMD_REBOOT ] ||
        [ "$1" -eq $CMD_WRITE_SSID ] ||
        [ "$1" -eq $CMD_WRITE_RAINDATA ] ||
        [ "$1" -eq $CMD_WRITE_WUNDERGROUND ] ||
        [ "$1" -eq $CMD_WRITE_WOW ] ||
        [ "$1" -eq $CMD_WRITE_WEATHERCLOUD ] ||
        [ "$1" -eq $CMD_WRITE_SENSOR_ID ] ||
        [ "$1" -eq $CMD_WRITE_CALIBRATION ] ||
        [ "$1" -eq $CMD_WRITE_SYSTEM ]
}

printBroadcast() {
   # if [ "$SHELL_SUPPORT_BULTIN_PRINTF" -eq 1 ]; then
   #    printf "%-25s %s\n%-25s %s\n%-25s %s\n%-25s %s\n%-25s %s\n" "broadcast mac" "$C_BROADCAST_MAC"\
   #    "broadcast ip" "$C_BROADCAST_IP" "broadcast port" "$C_BROADCAST_PORT" "broadcast ssid" "$C_BROADCAST_SSID" "broadcast version" "$C_BROADCAST_VERSION"
   # else
      echo "$C_BROADCAST_MAC $C_BROADCAST_IP $C_BROADCAST_PORT $C_BROADCAST_SSID $C_BROADCAST_VERSION"
    #fi
}

parseBroadcast() {

    readSlice 12
    #this is the station MAC/ip on local network.
    #Observation: when device is reset its annoncing hotspot accesspoint/AP with first byte of MAC changed

    C_BROADCAST_MAC="$B1HEX:$B2HEX:$B3HEX:$B4HEX:$B5HEX:$B6HEX"
    C_BROADCAST_IP="$B7.$B8.$B9.$B10"
    C_BROADCAST_PORT="$(( (B11 << 8) | B12 ))"

    readString
    #https://stackoverflow.com/questions/1469849/how-to-split-one-string-into-multiple-strings-separated-by-at-least-one-space-in
    #shellcheck disable=SC2086
    set -- $VALUE_STRING # -- assign words to positional parameters
    C_BROADCAST_SSID=$1
    C_BROADCAST_VERSION=$2

    printBroadcast
}


setWindMode()
{
    UNIT_WIND_MODE=$1

    if [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPH ]; then 
          UNIT_WIND="mph"
       
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPS ]; then
         UNIT_WIND=$UNIT_UNICODE_WIND_MPS
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_KMH ]; then
         UNIT_WIND="km/$UNIT_HOUR"
    fi
    
    [ "$DEBUG" -eq 1 ] && >&2 echo Unit wind : "$UNIT_WIND"

}

setUVMode()
{
    UNIT_UV_MODE=$1

    if [ "$UNIT_UV_MODE" -eq $UNIT_UV_MICROWM2 ]; then
        UNIT_UV="W/m2?" # documentation for livedata protocol: ITEM_UV uW/m2?
    elif [ "$UNIT_UV_MODE" -eq $UNIT_UV_WATTM2 ]; then
        if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
            UNIT_UV="W/㎡"   
        else
            UNIT_UV="W/m2"
        fi
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo Unit UV : $UNIT_UV

}

setTemperatureMode()
#$1 - mode
{
    UNIT_TEMPERATURE_MODE=$1

    if [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_CELCIUS ]; then 
        if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
            UNIT_TEMP=$UNIT_UNICODE_CELCIUS
        else
            UNIT_TEMP="C"
        fi
       
    elif [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_FARENHEIT ]; then
        if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
            UNIT_TEMP=$UNIT_UNICODE_FARENHEIT
        else
            UNIT_TEMP="F"
        fi
    fi
    
    [ "$DEBUG" -eq 1 ] && >&2 echo Unit temperature : $UNIT_TEMP

}

setPressureMode()
{
    UNIT_PRESSURE_MODE=$1

    if  [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
        UNIT_PRESSURE=$UNIT_UNICODE_PRESSURE_HPA
    elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
        UNIT_PRESSURE="inHg"
    fi

    [ "$DEBUG" -eq 1 ] && >&2 echo Unit pressure : $UNIT_PRESSURE

}

setRainMode()
{
    UNIT_RAIN_MODE=$1

    if  [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
        UNIT_RAIN=$UNIT_UNICODE_RAIN_MM
    elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
        UNIT_RAIN="in"
    fi

    UNIT_HOUR=${UNIT_HOUR:="h"}
    UNIT_RAINRATE=$UNIT_RAIN"/$UNIT_HOUR"

    [ "$DEBUG" -eq 1 ] && >&2 echo Unit rain rainrate : $UNIT_RAIN "$UNIT_RAINRATE"
    
}



setLivedataValueStyleLtGt()
#$1 - raw value, $2 low limit, 3$ high limit, $4 sgi low, $5 sgi high
{
    if [ -n "$2" ] && [ "$1" -lt "$2" ]; then
        STYLE_LIVE_VALUE=$4
    elif [ -n "$3" ] && [ "$1" -gt "$3" ]; then
        STYLE_LIVE_VALUE=$5
    fi
}

setLivedataValueStyleGt()
#$1 - raw v. $2 limit $3 style
{
    if [ "$1" -gt "$2" ]; then
        if [ -z "$3" ]; then
            STYLE_LIVE_VALUE=$STYLE_LIMIT_LIVEDATA
        else
            STYLE_LIVE_VALUE=$3
        fi
    fi
}

setLivedataValueStyleLt()
#$1 - raw v. $2 limit $3 style
{
    if [ "$1" -lt "$2" ]; then
        if [ -z "$3" ]; then
            STYLE_LIVE_VALUE=$STYLE_LIMIT_LIVEDATA
        else
            STYLE_LIVE_VALUE=$3
        fi
    fi
}

appendFormat()
{
    #APPEND_FORMAT="$APPEND_FORMAT$1"
    appendVar APPEND_FORMAT "$1"
}

appendArgs()
{
   # APPEND_ARGS="$APPEND_ARGS $1" #keep space between arguments
   appendVar APPEND_ARGS " $1"
}

appendVar()
#generic append to any variable
{
    #echo  "$1=\"\$$1$2\"" 
    eval "$1=\"\$$1$2\""
}

appendBuffer()
{
    #appendFormat "$1"
    appendVar APPEND_FORMAT "$1"
    #appendArgs "$2"
    appendVar APPEND_ARGS " $2"
}

printAppendBuffer()
{
    #special characters like 'æøå' gives wrong adjustment in %s 

    if [ "$DEBUG" -eq 1 ] || [ "$DEBUG_OPTION_APPEND" -eq 1 ]; then 
        printf >&2 "%s\n" "APPEND_FORMAT/APPEND_ARGS printf '$APPEND_FORMAT' $APPEND_ARGS"
    fi

    eval printf \""$APPEND_FORMAT"\" "$APPEND_ARGS"

    resetAppendBuffer
}

printLivedataBatteryLowNormal()
#$1 - battery 0/1, $2 - battery state, $3 header, $4 terse header
{
    if [ -n "$1" ]; then

     setSGIBatteryLowNormal "$1"
     printLivedataLine "$3" "$2" "%-7s" "" "%5s" "$4"
    fi
}

printLivedataBatteryVoltage()
#$1 - batteryvoltage raw scaled 10, $2 - battery state, $3 header, $4 terse header
{
    if [ -n "$1" ]; then
        setSGIBatteryVoltage "$1"
        printLivedataLine "$3" "$2" "%-7s" "" "%5s" "$4" 
    fi
}

setSGIBatteryLowNormal()
{
    if [ "$1" -eq "$BATTERY_LOW" ]; then
        STYLE_LIVE_VALUE=$STYLE_BATTERY_LOW
    fi
}

setSGIBatteryVoltage()
{
    if [ "$1" -le "$BATTERY_VOLTAGE_LOW" ]; then
        STYLE_LIVE_VALUE=$STYLE_BATTERY_LOW
    fi
}

newLivedataCompass()
#$1 unicode direction, $2 - wind direction 
{
    #set -- "$1" "$WIND_ESE"

    style_needle=$STYLE_COMPASS_WIND$1$STYLE_RESET
    
    if [ -z "$KSH_VERSION" ]; then
       LIVEVIEW_COMPASS_N_FMT="╭─$STYLE_COMPASS_NORTH$WIND_DIRECTION_N$STYLE_RESET─╮" #styling must be in the format of printf
    else
        LIVEVIEW_COMPASS_N_FMT="╭─$STYLE_COMPASS_NORTH$WIND_DIRECTION_N$STYLE_RESET\u2500╮" #ksh Version AJM 93u+ 2012-08-01 insert \x80 instead of unicode 2500 ?! bug?
    fi
       
    LIVEVIEW_COMPASS_WE_FMT="$WIND_DIRECTION_W $style_needle $WIND_DIRECTION_E"

    if [ -z "$KSH_VERSION" ]; then
        LIVEVIEW_COMPASS_S_FMT="╰─$WIND_DIRECTION_S─╯"
    else
        LIVEVIEW_COMPASS_S_FMT="╰─$WIND_DIRECTION_S\u2500╯"
    fi

    unset style_needle
}

setRainValueFormat()
{
     if [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
      VALUE_RAIN_FMT="%6.1f"
    elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
      VALUE_RAIN_FMT="%6.2f"
    fi
}

printLivedataRainLine()
{
    #echo "printLivedataRainLine $*"

    [ "$DEBUG" -eq 1 ] && echo >&2 printLivedataRainLine raw value : "$1" limit: "$2"

    if [ "$1" -gt "$2" ] && [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
        setLivedataValueStyleGt "$1" "$2" "$8"
        printLivedataLine "$3" "$4" "$VALUE_RAIN_FMT" "$5" "%5s" "$6" "%6.1f" "$1" "$7"
    else
        printLivedataLine "$3" "$4" "$VALUE_RAIN_FMT"  "$5" "%5s" "$6" "%6.1f"
    fi
}

printWHBatterySignal()
#$1 - WH?? $2 battery $3 signal
{
    if [ -n "$2" ]; then
        if [ "$1" = "WH65" ] && [ "$C_SYSTEM_SENSORTYPE_STATE" = "WH24" ]; then
            appendFormat " WH24 %s"
        else
            appendFormat " $1 %s"
        fi

        appendArgs "'$2' "
    fi
        
    if [ -n "$3" ]; then
        appendBuffer "%s" "'$3'"
    fi
}

setLivedataProtocolStyle()
{
    case "$1" in

      "$LIVEDATA_PROTOCOL_ECOWITT_HTTP"|"$LIVEDATA_PROTOCOL_ECOWITT_BINARY")
            VALUE_STYLE_PROTOCOL=$STYLE_PROTOCOL_ECOWITT_HTTP
            ;;
      "$LIVEDATA_PROTOCOL_WUNDERGROUND_HTTP")
            VALUE_STYLE_PROTOCOL=$STYLE_PROTOCOL_WUNDERGROUND_HTTP
            ;;
    esac
}

printLivedataSystem()
{
    setLivedataProtocolStyle "$LIVEDATA_SYSTEM_PROTOCOL"

    appendBuffer "%s %s $VALUE_STYLE_PROTOCOL%s$STYLE_RESET" "'$LIVEDATA_SYSTEM_VERSION' '$LIVEDATA_SYSTEM_FREQUENCY' '$LIVEDATA_SYSTEM_PROTOCOL'"
    
    if [ -n "$LIVEDATA_SENSOR_COUNT_CONNECTED" ]; then
       appendBuffer " %s/$STYLE_SENSOR_SEARCH%s$STYLE_RESET/$STYLE_SENSOR_DISABLE%s$STYLE_RESET" "'$LIVEDATA_SENSOR_COUNT_CONNECTED' '$LIVEDATA_SENSOR_COUNT_SEARCHING' '$LIVEDATA_SENSOR_COUNT_DISABLED' "
    fi
   
    printWHBatterySignal "WH65" "$LIVEDATA_WH65_BATTERY_STATE" "$LIVEDATA_WH65_SIGNAL_STATE"
    #set in getSensorBatteryState
    #shellcheck disable=SC2153
    printWHBatterySignal "WH68" "$LIVEDATA_WH68_BATTERY_STATE" "$LIVEDATA_WH68_SIGNAL_STATE" #maybe multiple weather stations allowed?
    #shellcheck disable=SC2153
    printWHBatterySignal "WH80" "$LIVEDATA_WH80_BATTERY_STATE" "$LIVEDATA_WH80_SIGNAL_STATE"

    appendBuffer " %s" "'$LIVEDATA_SYSTEM_UTC'"

    $LIVEDATA_SYSTEM_TIMEZONE


    if [ "$LIVEDATA_SYSTEM_TIMEZONE_AUTO" = "$LIVEDATA_SYSTEM_TIMEZONE_AUTO_OFF" ]; then
      appendBuffer " %s" "'$LIVEDATA_SYSTEM_TIMEZONE_OFFSET_HOURS'"
      
      if [ "$LIVEDATA_SYSTEM_TIMEZONE_DST_BIT" -eq 1 ]; then
        appendFormat " DST"
      fi
    fi

    #appendFormat "\n\n"
}

setRainIntensityStatus()
{
    if [ "$1" -eq 0 ]; then
      unset VALUE_RAININTENSITY_STATUS
    elif [ "$1" -gt 0 ] &&  [ "$1" -lt $RAININTENSITY_LIGHT_LIMIT ]; then
      VALUE_RAININTENSITY_STATUS=$UNICODE_RAINRATE
    elif [ "$1" -ge $RAININTENSITY_LIGHT_LIMIT ] && [ "$1" -lt $RAININTENSITY_MODERATE_LIMIT ]; then
      VALUE_RAININTENSITY_STATUS=$UNICODE_RAINRATE$UNICODE_RAINRATE
    elif [ "$1" -ge  $RAININTENSITY_MODERATE_LIMIT ] && [ "$1" -lt $RAININTENSITY_HEAVY_LIMIT ]; then
      VALUE_RAININTENSITY_STATUS=$UNICODE_RAINRATE$UNICODE_RAINRATE$UNICODE_RAINRATE
    elif [ "$1" -gt $RAININTENSITY_HEAVY_LIMIT ]; then
      VALUE_RAININTENSITY_STATUS=$UNICODE_RAINRATE$UNICODE_RAINRATE$UNICODE_RAINRATE$UNICODE_RAINRATE
    fi
}

printLivedataHeader()
{
    [ -n "$LIVEVIEW_HIDE_HEADERS" ] && return

    #unset STYLE_LIVEVIEW_NORMAL_HEADER
    [ -z "$1" ] && set -- "\n$STYLE_LIVEVIEW_NORMAL_HEADER%s$STYLE_RESET\n\n" "$2"  #use default when "" used as $1

     appendBuffer "$STYLE_LIVEVIEW_NORMAL_HEADER%64s$STYLE_RESET\r$1" "' ' '$2'"
}

printLivedataLine()
#allows to intercept/disable printing during debugging
{
    #echo "$*"
    if [ -n "$DEBUG_LIVEDATA_LINE" ]; then
        :
    else
        printLivedataLineFinal "$@"
    fi

}

printLivedataLineFinal()
#$1 -header variable name, $2 value, $3 - value format, $4 unit, $5 unit format,$6 terse header, $7 terse format, $8 status value $9 status  $10 status fmt $11 signal value $12 signal state
# optimized to just use one printf call builtin/external -> builds up entire format and argument strings for entire livedata view
{
    if [ "$DEBUG" -eq 1 ] || [ "$DEBUG_LIVEDATA_LINE" ]; then
        echo >&2 "printLivedataLine $* length $#"
    fi

    # \r\t horizontal/absolute positioning is compatible with unicode in string
    if [ -n "$LIVEVIEW_HIDE_HEADERS" ] && [ "$LIVEVIEW_HIDE_HEADERS" -eq 1 ]; then 
        header_fmt="%s\r\t\t\t\t" 
    else
       header_fmt=" %s\r\t\t\t\t"
    fi
    # unit_fmt="\r\t\t\t\t\t%s" 
    unit_fmt="%s"
    #status_fmt="\r\t\t\t\t\t\t%s"
    status_fmt=${10}
    status_fmt=${status_fmt:="\t%s"}
    signal_fmt="\t%s"
    space=' ' #do not use space for unitless values

    #TEST UTF-8: for f in $(seq -s' ' 255); do eval printf "\\\x$(printf "%x" "$f")"; done

    if [ $LIVEDATA_VIEW -eq $LIVEDATA_VIEW_NORMAL ]; then 
       
        status_line="$9"
        case $status_line in # only use UNICODE battery icon/skip detailed battery levels
             $UNICODE_BATTERY*) status_line=$UNICODE_BATTERY
                                ;;
             $UNICODE_BATTERY_LOW*) status_line=$UNICODE_BATTERY_LOW 
                                ;;
        esac

        signal_line="${12}"
        case $signal_line in 
             $UNICODE_SIGNAL*) signal_line=$UNICODE_SIGNAL
                             ;;
        esac

        status_line="$status_line$signal_line" #merge for compact format
        unset signal_line

        [ -n "$LIVEVIEW_HIDE_STATUSLINE" ] && unset status_line
  
        if [ "$DEBUG" -eq 1 ] || [ "$DEBUG_OPTION_APPEND" -eq 1 ]; then 
            appendFormat " $header_fmt %s %s %s %s\n"
        fi
        
        if [ -n "$STYLE_LIVE_VALUE" ]; then
            [ -z "$4" ] && unset space # skip space if unit empty
            appendFormat "$header_fmt $STYLE_LIVE_VALUE$3$space$unit_fmt$STYLE_RESET $status_fmt $signal_fmt\n"
        else
            appendFormat "$header_fmt $3 $unit_fmt $status_fmt $signal_fmt\n"
        fi

        unset STYLE_LIVE_VALUE

        if [ "$DEBUG" -eq 1 ] || [ "$DEBUG_OPTION_APPEND" -eq 1 ]; then 
            appendArgs "'$header_fmt' '$3' '$unit_fmt' '$status_fmt' '$signal_fmt'"
        fi
    
       appendArgs "'$1' '$2' '$4' '$status_line' '$signal_line'"
    fi
   
    unset header_fmt ch status_fmt unit_fmt status_line signal_fmt signal_line

}

printLivedata() 
{
    #debugging: call printLivedataFinal directly for problematic line and set DEBUG_LIVEDATA_LINE=1
    #DEBUG_LIVEDATA_LINE=1

    #resetAppendBuffer
    
   printLivedataHeader "" "$LIVEDATA_HEADER"
 
     if [ -n "$LIVEDATA_INTEMP" ]; then
         
         setLivedataValueStyleLtGt "$LIVEDATA_INTEMP_RAW" "$LIVEDATA_INTEMP_LIMIT_LOW" "$LIVEDATA_INTEMP_LIMIT_HIGH" "$STYLE_LIVEDATA_INTEMP_LIMIT_LOW" "$STYLE_LIVEDATA_INTEMP_LIMIT_HIGH"
         printLivedataLine "$LIVEDATA_INTEMP_HEADER"  "$LIVEDATA_INTEMP" "%6.1f" "$UNIT_TEMP" "%s" 'in' "%s" 
     fi

    
     if [ -n "$LIVEDATA_OUTTEMP" ]; then
         setLivedataValueStyleLtGt "$LIVEDATA_OUTTEMP_RAW" "$LIVEDATA_OUTTEMP_LIMIT_LOW" "$LIVEDATA_OUTTEMP_LIMIT_HIGH" "$STYLE_LIMIT_LIVEDATA_OUTTEMP" "$STYLE_LIVEDATA_OUTTEMP_LIMIT_HIGH"
         #WH32 battery and state may be set by injectWH32 testdata or if available
         #shellcheck disable=SC2153
         printLivedataLine "$LIVEDATA_OUTTEMP_HEADER" "$LIVEDATA_OUTTEMP" "%6.1f" "$UNIT_TEMP" "%s" 'out' '' "$LIVEDATA_WH32_BATTERY"  "$LIVEDATA_WH32_BATTERY_STATE" "" "$LIVEDATA_WH32_SIGNAL" "$LIVEDATA_WH32_SIGNAL_STATE"
     fi
 
     if [ -n "$LIVEDATA_WINDCHILL" ]; then
         setLivedataValueStyleLtGt "$LIVEDATA_WINDCHILL_RAW" "$LIVEDATA_OUTTEMP_LIMIT_LOW" "$LIVEDATA_OUTTEMP_LIMIT_HIGH" "$STYLE_LIMIT_LIVEDATA_OUTTEMP" "$STYLE_LIVEDATA_OUTTEMP_LIMIT_HIGH"
         printLivedataLine "$LIVEDATA_WINDCHILL_HEADER" "$LIVEDATA_WINDCHILL" "%6.1f" "$UNIT_TEMP" "%2s" 'wchill' 
     fi
         if [ -n "$LIVEDATA_DEWPOINT" ]; then
         printLivedataLine "$LIVEDATA_DEWPOINT_HEADER" "$LIVEDATA_DEWPOINT" "%6.1f" "$UNIT_TEMP" "%2s"  'dewp'
     fi
     
     [ -n "$LIVEDATA_INHUMI" ]   && printLivedataLine "$LIVEDATA_INHUMI_HEADER" "$LIVEDATA_INHUMI"  "%6u" "$UNIT_HUMIDITY" "%s" 'ihum'   "%4u"
     [ -n "$LIVEDATA_OUTHUMI" ]  && printLivedataLine "$LIVEDATA_OUTHUMI_HEADER" "$LIVEDATA_OUTHUMI" "%6u" "$UNIT_HUMIDITY" "%s" 'ohum'  "%4u"
     if [ -n "$LIVEDATA_RELBARO" ]; then
            
            printLivedataHeader "" "$LIVEDATA_PRESSURE_HEADER"
             setLivedataValueStyleLt "$LIVEDATA_RELBARO_RAW" "$LIVEDATA_RELBARO_LIMIT_LOW"
         
         if [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
             printLivedataLine "$LIVEDATA_RELBARO_HEADER" "$LIVEDATA_RELBARO" "%6.1f" "$UNIT_PRESSURE" "%4s" 'rbaro'
             [ -n "$LIVEDATA_ABSBARO" ] && {
                 setLivedataValueStyleLt "$LIVEDATA_ABSBARO_RAW" "$LIVEDATA_ABSBARO_LIMIT_LOW"
                 printLivedataLine "$LIVEDATA_ABSBARO_HEADER" "$LIVEDATA_ABSBARO" "%6.1f" "$UNIT_PRESSURE" "%4s" 'abaro'; }
         elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
             printLivedataLine "$LIVEDATA_RELBARO_HEADER" "$LIVEDATA_RELBARO" "%6.2f" "$UNIT_PRESSURE" "%4s" 'rbaro'
             [ -n "$LIVEDATA_ABSBARO" ] && printLivedataLine "$LIVEDATA_ABSBARO_HEADER" "$LIVEDATA_ABSBARO" "%6.2f" "$UNIT_PRESSURE" "%4s" 'abaro'
         fi
     fi
 
    if [ -z "$LIVEVIEW_HIDE_WIND" ]; then
      
       [ -n "$LIVEDATA_WINDSPEED" ] && printLivedataHeader "" "$LIVEDATA_WIND_HEADER"

       [ -z "$LIVEVIEW_HIDE_COMPASS" ] && [ -n "$LIVEDATA_WINDSPEED" ] && [ -n "$LIVEDATA_WINDGUSTSPEED" ] && [ -n "$LIVEDATA_WINDDIRECTION" ] && newLivedataCompass "$UNICODE_WIND" "$VALUE_COMPASS"
         
        if [ -n "$LIVEDATA_WINDSPEED" ]; then
            if [ -z "$LIVEVIEW_HIDE_BEUFORT" ]; then
                setStyleBeufort "$LIVEDATA_WINDSPEED_RAW"
                STYLE_LIVE_VALUE=$STYLE_BEUFORT
            fi
            printLivedataLine "$LIVEDATA_WINDSPEED_HEADER" "$LIVEDATA_WINDSPEED" "%6.1f" "$UNIT_WIND"  "%4s" 'wspd' "%6.1f" '' '' "\t%s$LIVEVIEW_COMPASS_N_FMT" 
           
        fi

        if [ -n "$LIVEDATA_WINDGUSTSPEED" ]; then
           if [ -z "$LIVEVIEW_HIDE_BEUFORT" ]; then
                setBeufort "$LIVEDATA_WINDGUSTSPEED_RAW"
                setStyleBeufort "$LIVEDATA_WINDGUSTSPEED_RAW"
                STYLE_LIVE_VALUE=$STYLE_BEUFORT
           else
             unset VALUE_BEUFORT_DELIMITER
            fi
            printLivedataLine  "$LIVEDATA_WINDGUSTSPEED_HEADER $VALUE_BEUFORT_DELIMITER $VALUE_BEUFORT $VALUE_BEUFORT_DESCRIPTION " "$LIVEDATA_WINDGUSTSPEED" "%6.1f" "$UNIT_WIND" "%4s" 'wgspd' "%6.1f" "" "" "\t%s$LIVEVIEW_COMPASS_WE_FMT"
        fi

        LIVEDATA_WINDDIRECTION_HEADER="$LIVEDATA_WINDDIRECTION_HEADER $VALUE_COMPASS_DELIMITER $LIVEDATA_WINDDIRECTION_COMPASS" #integrate direction in header
        
        [ -n "$LIVEDATA_WINDDIRECTION" ] && printLivedataLine "$LIVEDATA_WINDDIRECTION_HEADER" "$LIVEDATA_WINDDIRECTION"   "%6u" "$UNIT_DEGREE"\
         "%5s" 'wdeg' "%4u" "$LIVEDATA_WINDDIRECTION" "" "\t%s$LIVEVIEW_COMPASS_S_FMT"
        
        if [ -n "$LIVEDATA_WINDDAILYMAX" ]; then
            if [ -z "$LIVEVIEW_HIDE_BEUFORT" ]; then
                setBeufort "$LIVEDATA_WINDDAILYMAX_RAW"
                setStyleBeufort "$LIVEDATA_WINDDAILYMAX_RAW"
                STYLE_LIVE_VALUE=$STYLE_BEUFORT
            else
                unset VALUE_BEUFORT_DELIMITER
            fi
            printLivedataLine  "$LIVEDATA_WINDDAILYMAX_HEADER $VALUE_BEUFORT_DELIMITER $VALUE_BEUFORT $VALUE_BEUFORT_DESCRIPTION"   "$LIVEDATA_WINDDAILYMAX"  "%6.1f" "$UNIT_WIND" "%4s" 'wdmax' "%6.1f" 
         fi 
      
        #[ -n "$LIVEDATA_WINDDIRECTION_COMPASS" ]    && printLivedataLine "LIVEDATA_WINDDIRECTION_COMPASS_HEADER"   "$LIVEDATA_WINDDIRECTION_COMPASS"  "%6s" "" "%5s" 'wdir' "%4s"
    fi

    if [ -n "$LIVEDATA_LIGHT" ] && [ "$LIVEDATA_LIGHT_RAW" -eq 0 ] && [ "$HIDE_LIGHT_LIVEDATA_AUTO" -eq 1 ]; then
      LIVEVIEW_HIDE_LIGHT=1 # auto hide_liveview, when dark
    fi

    if [ -z "$LIVEVIEW_HIDE_LIGHT" ]; then
        [ -n "$LIVEDATA_LIGHT" ] && printLivedataHeader "" "$LIVEDATA_SOLAR_HEADER"
        [ -n "$LIVEDATA_LIGHT" ]    && printLivedataLine "$LIVEDATA_LIGHT_HEADER" "$LIVEDATA_LIGHT"  "%6.1f" "$UNIT_LIGHT" "%4s" 'light'
        [ -n "$LIVEDATA_UV" ]       && printLivedataLine "$LIVEDATA_UV_HEADER" "$LIVEDATA_UV"        "%6.1f" "$UNIT_UV" "%5s" 'uv'
        if [ -n "$LIVEDATA_UVI" ]; then
           if [ -z "$LIVEVIEW_HIDE_UVI" ]; then
                setUVRisk "$LIVEDATA_UVI"
                setStyleUVI "$LIVEDATA_UVI"
                #shellcheck disable=SC2153
                STYLE_LIVE_VALUE=$STYLE_UVI
            else
              unset VALUE_UVI_DELIMITER
            fi
            printLivedataLine "$LIVEDATA_UVI_HEADER $VALUE_UVI_DELIMITER $VALUE_UV_RISK" "$LIVEDATA_UVI"      "%6u" "    " "%4s" 'uvi' "%3u"
        fi
    fi

    if [ -n "$LIVEDATA_RAINDAY_RAW" ] && [ "$LIVEDATA_RAINDAY_RAW" -eq 0 ] && [ "$HIDE_RAIN_LIVEDATA_AUTO" -eq 1 ]; then
       LIVEVIEW_HIDE_RAIN=1 #auto hide_liveview, if no rain today
    fi

    if [ -z "$LIVEVIEW_HIDE_RAIN" ]; then
      
        setRainValueFormat # 2 decimals for inch or 1 decimals for mm
       
        if [ -n "$LIVEDATA_RAINRATE" ]; then
              printLivedataHeader "" "$LIVEDATA_RAIN_HEADER"

               setRainIntensity "$LIVEDATA_RAINRATE_RAW"
               setStyleRainIntensity "$LIVEDATA_RAINRATE_RAW"
               setRainIntensityStatus "$LIVEDATA_RAINRATE_RAW"
               STYLE_LIVE_VALUE=$STYLE_RAININTENSITY
              
               if [ "$LIVEDATA_RAINRATE_RAW" -gt 0 ]; then
                    delimiter=$VALUE_RAININTENSITY_DELIMITER 
                else
                    delimiter=" "
                fi
               
               printLivedataLine "$LIVEDATA_RAINRATE_HEADER $delimiter $VALUE_RAININTENSITY"  "$LIVEDATA_RAINRATE" "$VALUE_RAIN_FMT"  "$UNIT_RAINRATE" "%4s" 'rrate'  '' '' "$VALUE_RAININTENSITY_STATUS" 
            fi
        # rainhour available in Ecowitt http request
        [ -n "$LIVEDATA_RAINHOUR" ]     && printLivedataRainLine "$LIVEDATA_RAINHOUR_RAW"  "$LIVEDATA_RAINHOUR_LIMIT"  "$LIVEDATA_RAINHOUR_HEADER"  "$LIVEDATA_RAINHOUR" "$UNIT_RAIN" 'rhour' "" "$STYLE_LIMIT_LIVEDATA_RAINHOUR"
        [ -n "$LIVEDATA_RAINDAY" ]      && printLivedataRainLine "$LIVEDATA_RAINDAY_RAW"   "$LIVEDATA_RAINDAY_LIMIT"   "$LIVEDATA_RAINDAY_HEADER"   "$LIVEDATA_RAINDAY"  "$UNIT_RAIN" 'rday' "" "$STYLE_LIMIT_LIVEDATA_RAINDAY"
        [ -n "$LIVEDATA_RAINEVENT" ]    && printLivedataRainLine "$LIVEDATA_RAINEVENT_RAW" "$LIVEDATA_RAINEVENT_LIMIT" "$LIVEDATA_RAINEVENT_HEADER" "$LIVEDATA_RAINEVENT" "$UNIT_RAIN" 'revent' "" "$STYLE_LIMIT_LIVEDATA_RAINEVENT"

        [ -n "$LIVEDATA_RAINWEEK" ]     && printLivedataLine "$LIVEDATA_RAINWEEK_HEADER" "$LIVEDATA_RAINWEEK"    "$VALUE_RAIN_FMT" "$UNIT_RAIN" "%3s" 'rweek' ''  "$LIVEDATA_WH40_RAINFALL_BATTERY" "$LIVEDATA_WH40_RAINFALL_BATTERY_STATE" "" "$LIVEDATA_WH40_RAINFALL_SIGNAL" "$LIVEDATA_WH40_RAINFALL_SIGNAL_STATE"
        [ -n "$LIVEDATA_RAINMONTH" ]    && printLivedataLine "$LIVEDATA_RAINMONTH_HEADER" "$LIVEDATA_RAINMONTH"  "$VALUE_RAIN_FMT" "$UNIT_RAIN" "%3s" 'rmonth' "$VALUE_RAIN_FMT"
        [ -n "$LIVEDATA_RAINYEAR" ]     && printLivedataLine "$LIVEDATA_RAINYEAR_HEADER" "$LIVEDATA_RAINYEAR"    "$VALUE_RAIN_FMT" "$UNIT_RAIN" "%3s" 'ryear'
        [ -n "$LIVEDATA_RAINTOTAL" ]    && printLivedataLine "$LIVEDATA_RAINTOTAL_HEADER" "$LIVEDATA_RAINTOTAL"  "$VALUE_RAIN_FMT" "$UNIT_RAIN" "%3s" 'rtotal' "$VALUE_RAIN_FMT"
    fi

     if [ -z "$LIVEVIEW_HIDE_TEMP" ]; then 
        [ -n "$LIVEDATA_TEMP1" ] && printLivedataHeader "" "$LIVEDATA_TEMP_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH31TEMP_MAXCH" ]; do
        #shellcheck disable=SC2153
        {
            #eval echo !!!!!!!!!!!!!!!!! \"\$LIVEDATA_TEMP${n}_SIGNAL_STATE\" n=$n
            #set -x
            eval " if [ -n ''"\$LIVEDATA_TEMP$n" ]; then
                       # setSGIBatteryLowNormal "\$LIVEDATA_TEMP${n}_BATTERY"
                        printLivedataLine \"\$LIVEDATA_TEMP_HEADER$n\" \"\$LIVEDATA_TEMP$n\" '%6.1f'  \"\$UNIT_TEMP\" '%2s' 'temp$n' '' \"\$LIVEDATA_TEMP${n}_BATTERY\" \"\$LIVEDATA_TEMP${n}_BATTERY_STATE\" '' \"\$LIVEDATA_TEMP${n}_SIGNAL\" \"\$LIVEDATA_TEMP${n}_SIGNAL_STATE\"
                   fi "
            #set +x
        }
            n=$((n + 1))
        done

        n=1
        while [ "$n" -le "$SENSORTYPE_WH31TEMP_MAXCH" ]; do
        #shellcheck disable=SC2153
        {
            eval "[ -n ''"\$LIVEDATA_HUMI$n" ] && printLivedataLine \"\$LIVEDATA_HUMIDITY_HEADER$n\" \"\$LIVEDATA_HUMI$n\" \"%6u\" \"%\" \"%4s\" \"hum$n\" \"%4u\""
        }
            n=$((n + 1))
        done

     fi

    if [ -z "$LIVEVIEW_HIDE_SOILMOISTURE" ]; then
        [ -n "$LIVEDATA_SOILMOISTURE1" ] && printLivedataHeader "" "$LIVEDATA_SOILMOISTURE_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH51SOILMOISTURE_MAXCH" ]; do
            eval "if [ -n ''"\$LIVEDATA_SOILMOISTURE$n" ]; then
                    #setSGIBatteryVoltage \"\$LIVEDATA_SOILMOISTURE${n}_BATTERY_RAW\"
                    printLivedataLine  \"\$LIVEDATA_SOILMOISTURE_HEADER$n\" \"\$LIVEDATA_SOILMOISTURE$n\" \"%6u\" \"%\" \"%4s\" \"sm$n\" \"%3u\" \"\$LIVEDATA_SOILMOISTURE${n}_BATTERY\" \"\$LIVEDATA_SOILMOISTURE${n}_BATTERY_STATE\" '' \"\$LIVEDATA_SOILMOISTURE${n}_SIGNAL\" \"\$LIVEDATA_SOILMOISTURE${n}_SIGNAL_STATE\"
                  fi "
            n=$((n + 1))
        done
    fi

    if [ -z "$LIVEVIEW_HIDE_SOILTEMPERATURE" ]; then

        [ -n "$LIVEDATA_SOILTEMP1" ] && printLivedataHeader "" "$LIVEDATA_SOILTEMP_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH34SOILTEMP_MAXCH" ]; do
            eval "if [ -n ''"\$LIVEDATA_SOILTEMP$n" ]; then
                    #setSGIBatteryVoltage \"\$LIVEDATA_SOILTEMP${n}_BATTERY_RAW\"
                    printLivedataLine \"\$LIVEDATA_SOILTEMP_HEADER$n\" \"\$LIVEDATA_SOILTEMP$n\" \"%6.1f\" \"$UNIT_TEMP\" \"%2s\" \"st$n\" '' \"\$LIVEDATA_SOILTEMP${n}_BATTERY\" \"\$LIVEDATA_SOILTEMP${n}_BATTERY_STATE\" '' \"\$LIVEDATA_SOILMOISTURE${n}_SIGNAL\" \"\$LIVEDATA_SOILMOISTURE${n}_SIGNAL_STATE\"
                  fi"
            n=$((n + 1))
        done
    fi
   
    if [ -z "$LIVEVIEW_HIDE_TEMPUSR" ]; then
       
       [ -n "$LIVEDATA_TF_USR1" ] && printLivedataHeader "" "$LIVEDATA_TEMPUSR_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH31TEMP_MAXCH" ]; do
            eval "if [ -n ''"\$LIVEDATA_TF_USR$n" ]; then
                #setSGIBatteryVoltage \"\$LIVEDATA_TF_USR${n}_BATTERY_RAW\"
                printLivedataLine \"\$LIVEDATA_TF_USR_HEADER$n\" \"\$LIVEDATA_TF_USR$n\" \"%6.1f\" \"\$UNIT_TEMP\" \"%2s\" \"tusr$n\" '' \"\$LIVEDATA_TF_USR${n}_BATTERY\"  \"\$LIVEDATA_TF_USR${n}_BATTERY_STATE\" '' \"\$LIVEDATA_TF_USR${n}_SIGNAL\"  \"\$LIVEDATA_TF_USR${n}_SIGNAL_STATE\"
                fi"
            n=$((n + 1))
        done
    fi

    if [ -z "$LIVEVIEW_HIDE_LEAK" ]; then

        [ -n "$LIVEDATA_LEAK1" ] && printLivedataHeader "" "$LIVEDATA_LEAK_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH55LEAK_MAXCH" ]; do
            #TEST eval LIVEDATA_LEAK$n=1
            #shellcheck disable=SC2034
            VALUE_LEAK=$LIVEDATA_LEAK_NO
            eval "if [ -n ''"\$LIVEDATA_LEAK$n" ]; then
                        #setSGIBatteryLowNormal \"\$LIVEDATA_LEAK${n}_BATTERY\"
                        [ \"\$LIVEDATA_LEAK$n\" -ne 0 ] && STYLE_LIVE_VALUE=\"$STYLE_LEAK\" && VALUE_LEAK=$LIVEDATA_LEAK_YES
                        LIVEDATA_LEAK_HEADER$n=\"\$LIVEDATA_LEAK_HEADER$n \$VALUE_LEAK_DELIMITER \$VALUE_LEAK\"
                        printLivedataLine \"\$LIVEDATA_LEAK_HEADER$n\" \"\$LIVEDATA_LEAK$n\" \"%6u\" \"\" \"%4s\" \"leak$n\" '' \"\$LIVEDATA_LEAK${n}_BATTERY\" \"\$LIVEDATA_LEAK${n}_BATTERY_STATE\" '' \"\$LIVEDATA_LEAK${n}_SIGNAL\" \"\$LIVEDATA_LEAK${n}_SIGNAL_STATE\"
                fi"
            n=$((n + 1))
        done
    fi

    if [ -z "$LIVEVIEW_HIDE_PM25" ]; then

        [ -n "$LIVEDATA_PM251" ] && printLivedataHeader "" "$LIVEDATA_PM25_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH43PM25_MAXCH" ]; do
            #shellcheck disable=SC2153
            eval "if [ -n ''"\$LIVEDATA_PM25$n" ]; then
                            #setSGIBatteryLowNormal \"\$LIVEDATA_PM25${n}_BATTERY\"
                            if [ -z \"\$LIVEVIEW_HIDE_PM25AQI\" ]; then
                                setAQI \"\$LIVEDATA_PM25${n}_RAW\"
                                setStyleAQI \"\$LIVEDATA_PM25${n}_RAW\"
                                STYLE_LIVE_VALUE=\$STYLE_AQI
                            else
                              unset VALUE_PM25_AQI_DELIMITER
                            fi
                            LIVEDATA_PM25_HEADER$n=\"\$LIVEDATA_PM25_HEADER$n \$VALUE_PM25_AQI_DELIMITER \$VALUE_PM25_AQI\"
                            printLivedataLine \"\$LIVEDATA_PM25_HEADER$n\" \"\$LIVEDATA_PM25$n\" \"%6.1f\" \"\$UNIT_PM25\" \"%6s\" \"pm25$n\" '' \"\$LIVEDATA_PM25${n}_BATTERY\" \"\$LIVEDATA_PM25${n}_BATTERY_STATE\" '' \"\$LIVEDATA_PM25${n}_SIGNAL\" \"\$LIVEDATA_PM25${n}_SIGNAL_STATE\"
                 fi"
            n=$((n + 1))
        done

        n=1
        while [ "$n" -le "$SENSORTYPE_WH43PM25_MAXCH" ]; do
            eval "if [ -n ''"\$LIVEDATA_PM25_24HAVG$n" ]; then
                        if [ -z \"\$LIVEVIEW_HIDE_PM25AQI\" ]; then
                            setAQI \"\$LIVEDATA_PM25_24HAVG${n}_RAW\"
                            setStyleAQI \"\$LIVEDATA_PM25_24HAVG${n}_RAW\"
                            STYLE_LIVE_VALUE=\$STYLE_AQI
                        else
                            unset VALUE_PM25_AQI_DELIMITER
                        fi
                        LIVEDATA_PM25_24HAVG_HEADER$n=\"\$LIVEDATA_PM25_24HAVG_HEADER$n \$VALUE_PM25_AQI_DELIMITER \$VALUE_PM25_AQI\"
                        printLivedataLine \"\$LIVEDATA_PM25_24HAVG_HEADER$n\" \"\$LIVEDATA_PM25_24HAVG$n\" \"%6.1f\" \"\$UNIT_PM25\" \"%6s\" \"pm25a$n\" \"%6.1f\"
             fi"
            n=$((n + 1))
        done
    fi

    if [ -z "$LIVEVIEW_HIDE_CO2" ]; then

        #WH45
        if [ -n "$LIVEDATA_WH45CO2_TEMPF" ]; then
             #setSGIBatteryLowNormal "$LIVEDATA_WH45CO2_BATTERY"
             printLivedataHeader "" "$LIVEDATA_WH45CO2_HEADER"
             printLivedataLine "$LIVEDATA_WH45CO2_TEMPF_HEADER" "$LIVEDATA_WH45CO2_TEMPF"  "%6.1f" "$UNIT_TEMP" "%2s" 'temp' '' "$LIVEDATA_WH45CO2_BATTERY" "$LIVEDATA_WH45CO2_BATTERY_STATE" "" "$LIVEDATA_WH45CO2_SIGNAL" "$LIVEDATA_WH45CO2_SIGNAL_STATE"
        fi

        [ -n "$LIVEDATA_WH45CO2_HUMI" ]         && printLivedataLine "$LIVEDATA_WH45CO2_HUMI_HEADER" "$LIVEDATA_WH45CO2_HUMI"                "%6u" "$UNIT_HUMIDITY" "%4s" 'humi'
        [ -n "$LIVEDATA_WH45CO2_PM10" ]         && printLivedataLine "$LIVEDATA_WH45CO2_PM10_HEADER" "$LIVEDATA_WH45CO2_PM10"                "%6.1f" "$UNIT_PM25" "%7s" 'pm10'
        [ -n "$LIVEDATA_WH45CO2_PM10_24HAVG" ]  && printLivedataLine "$LIVEDATA_WH45CO2_PM10_24HAVG_HEADER" "$LIVEDATA_WH45CO2_PM10_24HAVG"  "%6.1f" "$UNIT_PM25" "%7s" 'pm10a'
        if [ -n "$LIVEDATA_WH45CO2_PM25" ]; then
            setAQI "$LIVEDATA_WH45CO2_PM25_RAW"
            setStyleAQI "$LIVEDATA_WH45CO2_PM25_RAW"
            STYLE_LIVE_VALUE=$STYLE_AQI
            LIVEDATA_WH45CO2_PM25_HEADER="$LIVEDATA_WH45CO2_PM25_HEADER $VALUE_PM25_AQI_DELIMITER $VALUE_PM25_AQI"
            printLivedataLine "$LIVEDATA_WH45CO2_PM25_HEADER" "$LIVEDATA_WH45CO2_PM25"                "%6.1f" "$UNIT_PM25" "%7s" 'pm25'
        fi
        if [ -n "$LIVEDATA_WH45CO2_PM25_24HAVG" ]; then
            setAQI "$LIVEDATA_WH45CO2_PM25_24HAVG_RAW"
            setStyleAQI "$LIVEDATA_WH45CO2_PM25_24HAVG_RAW"
            STYLE_LIVE_VALUE=$STYLE_AQI
            LIVEDATA_WH45CO2_PM25_24HAVG_HEADER="$LIVEDATA_WH45CO2_PM25_24HAVG_HEADER $VALUE_PM25_AQI_DELIMITER $VALUE_PM25_AQI"
            printLivedataLine "$LIVEDATA_WH45CO2_PM25_24HAVG_HEADER" "$LIVEDATA_WH45CO2_PM25_24HAVG"  "%6.1f" "$UNIT_PM25" "%7s" 'pm25a'
        fi
        [ -n "$LIVEDATA_WH45CO2_CO2" ]          && printLivedataLine "$LIVEDATA_WH45CO2_CO2_HEADER" "$LIVEDATA_WH45CO2_CO2"                  "%6u" "$UNIT_CO2" "%6s" 'co2'
        [ -n "$LIVEDATA_WH45CO2_CO2_24HAVG" ]   && printLivedataLine "$LIVEDATA_WH45CO2_CO2_24HAVG_HEADER" "$LIVEDATA_WH45CO2_CO2_24HAVG"           "%6u" "$UNIT_CO2" "%6s" 'co2a'
    fi

    if [ -z "$LIVEVIEW_HIDE_LIGHTNING" ]; then

        if [ -n "$LIVEDATA_LIGHTNING_DISTANCE" ]; then
            printLivedataHeader "" "$LIVEDATA_LIGHTNING_HEADER"
            printLivedataLine "$LIVEDATA_LIGHTNING_DISTANCE_HEADER" "$LIVEDATA_LIGHTNING_DISTANCE"    "%6u" "km" "%5s" 'ldist' '' "$LIVEDATA_WH57_LIGHTNING_BATTERY" "$LIVEDATA_WH57_LIGHTNING_BATTERY_STATE" '' "$LIVEDATA_WH57_LIGHTNING_SIGNAL" "$LIVEDATA_WH57_LIGHTNING_SIGNAL_STATE" 
        fi
        [ -n "$LIVEDATA_LIGHTNING_TIME" ]       && printLivedataLine "$LIVEDATA_LIGHTNING_TIME_UTC_HEADER" "$LIVEDATA_LIGHTNING_TIME_UTC"    "%19s" "" "%5s" "lightningutc" 
        [ -n "$LIVEDATA_LIGHTNING_POWER" ]      && printLivedataLine "$LIVEDATA_LIGHTNING_POWER_HEADER" "$LIVEDATA_LIGHTNING_POWER"          "%6u" "" "%5s" 'lpower' "%6u"
    
    fi

    if [ -z "$LIVEVIEW_HIDE_LEAFWETNESS" ]; then
        [ -n "$LIVEDATA_LEAFWETNESS1" ] && printLivedataHeader "" "$LIVEDATA_LEAFWETNESS_HEADER"
        n=1
        while [ "$n" -le "$SENSORTYPE_WH35LEAFWETNESS_MAXCH" ]; do
            eval "if [ -n ''"\$LIVEDATA_LEAFWETNESS$n" ]; then
                    #setSGIBatteryVoltage \"\$LIVEDATA_LEAFWETNESS${n}_BATTERY_RAW\"
                    printLivedataLine \"\$LIVEDATA_LEAFWETNESS_HEADER$n\" \"\$LIVEDATA_LEAFWETNESS$n\" \"%6u\" \"%\" \"%4s\"  \"leaf$n\" '' \"\$LIVEDATA_LEAFWETNESS${n}_BATTERY\" \"\$LIVEDATA_LEAFWETNESS${n}_BATTERY_STATE\" '' \"\$LIVEDATA_LEAFWETNESS${n}_SIGNAL\" \"\$LIVEDATA_LEAFWETNESS${n}_SIGNAL_STATE\"
            fi"
            n=$((n + 1))
        done
    fi

    #battery

    if [ -z "$HIDE_BATTERY_LIVEDATA" ]; then
      :
       # printLivedataBatteryLowNormal "$LIVEDATA_WH65_BATTERY" "$LIVEDATA_WH65_BATTERY_STATE" "LIVEDATA_WH65_BATTERY_HEADER" 'bwh65'
       # printLivedataBatteryVoltage   "$LIVEDATA_WH68_BATTERY" "$LIVEDATA_WH68_BATTERY_STATE" "LIVEDATA_WH68_BATTERY_HEADER" 'bwh68'
       # printLivedataBatteryVoltage   "$LIVEDATA_WH80_BATTERY" "$LIVEDATA_WH80_BATTERY_STATE" "LIVEDATA_WH68_BATTERY_HEADER"  'bwh80'
       # printLivedataBatteryLowNormal "$LIVEDATA_WH32_TEMPERATURE_BATTERY" "$LIVEDATA_WH32_TEMPERATURE_BATTERY_STATE" "LIVEDATA_WH32_TEMPERATURE_BATTERY_HEADER" 'btout' 
       # printLivedataBatteryLowNormal "$LIVEDATA_WH40_RAINFALL_BATTERY" "$LIVEDATA_WH40_RAINFALL_BATTERY_STATE" "LIVEDATA_WH40_RAINFALL_BATTERY_HEADER" 'brain'
        #printLivedataBatteryLowNormal "$LIVEDATA_WH57_LIGHTNING_BATTERY" "$LIVEDATA_WH57_LIGHTNING_BATTERY_STATE" "LIVEDATA_WH57_LIGHTNING_BATTERY_HEADER" 'bwh57'
     
    fi

    #system
   
    if [ -z "$LIVEVIEW_HIDE_SYSTEM" ]; then
        
        printLivedataHeader "" "$LIVEDATA_SYSTEM_HEADER"

        [ -n "$LIVEDATA_SYSTEM_VERSION" ]   && printLivedataLine "$LIVEDATA_SYSTEM_VERSION_HEADER"   "$LIVEDATA_SYSTEM_VERSION"   "%-14s" "" "%5s" 'version'
        [ -n "$LIVEDATA_SYSTEM_MODEL" ]     && printLivedataLine "$LIVEDATA_SYSTEM_MODEL_HEADER"     "$LIVEDATA_SYSTEM_MODEL"     "%-7s"  "" "%5s" 'model'
        if [ -n "$LIVEDATA_SYSTEM_UTC" ]; then
       
            if [  "$LIVEDATA_SYSTEM_TIMEZONE_AUTO_BIT" -eq 0 ]; then
               if [ "$LIVEDATA_SYSTEM_TIMEZONE_DST_BIT" -eq 1 ]; then
                    printLivedataLine "$LIVEDATA_SYSTEM_UTC_HEADER" "$LIVEDATA_SYSTEM_UTC $LIVEDATA_SYSTEM_TIMEZONE_OFFSET_HOURS DST" "%-20s" "" "%5s" 'utc'
               else
                    printLivedataLine "$LIVEDATA_SYSTEM_UTC_HEADER" "$LIVEDATA_SYSTEM_UTC $LIVEDATA_SYSTEM_TIMEZONE_OFFSET_HOURS" "%-20s" "" "%5s" 'utc'
                fi     
            else
                printLivedataLine "$LIVEDATA_SYSTEM_UTC_HEADER"       "$LIVEDATA_SYSTEM_UTC"       "%-20s" "" "%5s" 'utc'
            fi

        #    [ -n "$LIVEDATA_SYSTEM_TIMEZONE_AUTO" ] && printLivedataLine "$LIVEDATA_SYSTEM_TIMEZONE_AUTO_HEADER" "$LIVEDATA_SYSTEM_TIMEZONE_AUTO" "%s"
        #    [ -n "$LIVEDATA_SYSTEM_TIMEZONE_DST" ] && printLivedataLine "$LIVEDATA_SYSTEM_TIMEZONE_DST_HEADER" "$LIVEDATA_SYSTEM_TIMEZONE_DST" "%s"
        #    [ -n "$LIVEDATA_SYSTEM_TIMEZONE" ] && printLivedataLine "$LIVEDATA_SYSTEM_TIMEZONE_HEADER" "$LIVEDATA_SYSTEM_TIMEZONE" "%-32.32s"
        fi
        
        [ -n "$LIVEDATA_SYSTEM_FREQUENCY" ] && printLivedataLine "$LIVEDATA_SYSTEM_FREQUENCY_HEADER" "$LIVEDATA_SYSTEM_FREQUENCY" "%-7s"  "" "%5s" 'freq' 
        [ -n "$LIVEDATA_SYSTEM_SENSORTYPE" ] && printLivedataLine "$LIVEDATA_SYSTEM_SENSORTYPE_HEADER" "$LIVEDATA_SYSTEM_SENSORTYPE" "%4s" "" "%4s" 'type' '' "$LIVEDATA_WH65_BATTERY" "$LIVEDATA_WH65_BATTERY_STATE" "" "$LIVEDATA_WH65_SIGNAL" "$LIVEDATA_WH65_SIGNAL_STATE"
   
       # setLivedataProtocolStyle "$LIVEDATA_SYSTEM_PROTOCOL"
       # space=' '
       # [ -z "$LIVEDATA_SYSTEM_PROTOCOL_VERSION" ] && unset space
       #    STYLE_LIVE_VALUE=$VALUE_STYLE_PROTOCOL   printLivedataLine "$LIVEDATA_SYSTEM_PROTOCOL_HEADER" "$LIVEDATA_SYSTEM_PROTOCOL_LONG$space$LIVEDATA_SYSTEM_PROTOCOL_VERSION" "%s" 
       
        [ -n "$LIVEDATA_SENSOR_COUNT_CONNECTED" ] && STYLE_LIVE_VALUE=$STYLE_SENSOR_CONNECTED printLivedataLineFinal "$LIVEDATA_SYSTEM_SENSOR_CONNECTED_HEADER" "$LIVEDATA_SENSOR_COUNT_CONNECTED" "%2u"
        [ -n "$LIVEDATA_SENSOR_COUNT_DISCONNECTED" ] && STYLE_LIVE_VALUE=$STYLE_SENSOR_DISCONNECTED printLivedataLineFinal "$LIVEDATA_SYSTEM_SENSOR_DISCONNECTED_HEADER" "$LIVEDATA_SENSOR_COUNT_DISCONNECTED" "%2u"
        [ -n "$LIVEDATA_SENSOR_COUNT_SEARCHING" ] && STYLE_LIVE_VALUE=$STYLE_SENSOR_SEARCH    printLivedataLine "$LIVEDATA_SYSTEM_SENSOR_SEARCHING_HEADER" "$LIVEDATA_SENSOR_COUNT_SEARCHING" "%2u"
        [ -n "$LIVEDATA_SENSOR_COUNT_DISABLED" ] && STYLE_LIVE_VALUE=$STYLE_SENSOR_DISABLE   printLivedataLine "$LIVEDATA_SYSTEM_SENSOR_DISABLED_HEADER" "$LIVEDATA_SENSOR_COUNT_DISABLED" "%2u"

    fi

    #WH68 sa,WH80 sa,WH40 rfall,WH32 tout
   # printLivedataLine '' "$LIVEDATA_WH68_BATTERY" "$LIVEDATA_WH45CO2_BATTERY_STATE" "" "$LIVEDATA_WH45CO2_SIGNAL" "$LIVEDATA_WH45CO2_SIGNAL_STATE"
  
    printAppendBuffer

    #unset local variables for ksh -> made global by using () function syntax without function keyword
    #https://www.unix.com/shell-programming-and-scripting/137435-ksh-different-syntax-function.html
    #man ksh93: ksh93 uses static scoping (one global scope, one local scope per function) and allows local variables only on Korn style functions
    
    unset n delimiter space
}

newRuler()
#creates a ruler for debugging positioning on screen
{
    n=1
    unset VALUE_RULER
    while [ "$n" -le "$1" ]; do
        VALUE_RULER=$VALUE_RULER"123456789${ANSIESC_SGI_BOLD_INVERT}0${ANSIESC_SGI_NORMAL}"
        n=$(( n + 1 ))
    done

    unset n
}

convertTemperatureLivedata()
{
    if [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_CELCIUS ]; then
        convertScale10ToFloat "$1"
    elif [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_FARENHEIT ]; then
        convert_celciusScale10_to_farenheitScale10 "$1"
        convertScale10ToFloat "$VALUE_FARENHEIT_SCALE10"
    fi
}

convertPressureLivedata()
{
    if [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
        convertScale10ToFloat "$1"
    elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
        convert_hpaScale10_To_inhgScale10 "$1"
        convertScale10ToFloat "$VALUE_INHG_SCALE10"
    fi
}

convertWindLivedata()
{
    if [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPS ]; then
        convertScale10ToFloat "$1"
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPH ]; then
        convcert_mpsScale10_to_mphScale10 "$1"
        convertScale10ToFloat "$VALUE_MPH_SCALE10"
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_KMH ]; then
        convert_mpsScale10_To_kmhScale10 "$1"
        convertScale10ToFloat "$VALUE_KMH_SCALE10"
    fi
}

getDateUTC()
{
    VALUE_DATE_UTC=$(date -u -d @"$1" +'%F %T') #add field
}

parseLivedata() { # ff ff 27 00 53 01 00 e1 06 25 08 27 b3 09 27 c2 02 00 05 07 5d 0a 01 59 0b 00 00 0c 00 00 15 00 00 93 bc 16 00 20 17 00 2c 12 1a 00 87 22 32 1b 00 b0 23 27 1c 00 dd 24 31 58 00 19 00 47 0e 00 00 10 00 08 11 00 42 12 00 00 02 9a 13 00 00 0f 8b 0d 00 42 63
    DEBUG_FUNC="parseLivedata"
    DEBUG_PARSE_LIVEDATA=${DEBUG_PARSE_LIVEDATA:=$DEBUG}
   
    LIVEDATA_SYSTEM_PROTOCOL=$LIVEDATA_PROTOCOL_ECOWITT_BINARY
    LIVEDATA_SYSTEM_PROTOCOL_LONG=$LIVEDATA_PROTOCOL_ECOWITT_BINARY_LONG

    while [ "${#OD_BUFFER}" -gt 4 ]; do

       # [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 Unparsed "$OD_BUFFER" length "${#OD_BUFFER}"

        readUInt8
        ldf=$VALUE_UINT8

        convertUInt8ToHex "$ldf"
        ldf_hex=$VALUE_UINT8_HEX
     
        if [ "$ldf" -eq $LDF_INTEMP ]; then

            readInt16BE
            export LIVEDATA_INTEMP_RAW=$VALUE_INT16BE
            convertTemperatureLivedata "$VALUE_INT16BE"
            export LIVEDATA_INTEMP="$VALUE_SCALE10_FLOAT" 
             [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex intemp int16be $LIVEDATA_INTEMP_RAW intemp $LIVEDATA_INTEMP $UNIT_UNICODE_CELCIUS"

        elif [ "$ldf" -eq $LDF_INHUMI ]; then

            readUInt8
            export LIVEDATA_INHUMI=$VALUE_UINT8
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex inhumi uint8 $LIVEDATA_INHUMI $UNIT_HUMIDITY"


        elif [ "$ldf" -eq $LDF_ABSBARO ]; then

            readUInt16BE
            #shellcheck disable=SC2034
            export LIVEDATA_ABSBARO_RAW=$VALUE_UINT16BE #may use for ansi escape coloring beyond limits
            convertPressureLivedata "$VALUE_UINT16BE"
            export LIVEDATA_ABSBARO="$VALUE_SCALE10_FLOAT"
            
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex absbaro int16be $LIVEDATA_ABSBARO_RAW absbaro $LIVEDATA_ABSBARO $UNIT_UNICODE_PRESSURE_HPA"


        elif [ "$ldf" -eq $LDF_RELBARO ]; then

            readUInt16BE
            export LIVEDATA_RELBARO_RAW=$VALUE_UINT16BE
            convertPressureLivedata "$VALUE_UINT16BE"
            export LIVEDATA_RELBARO="$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex relbaro int16be $LIVEDATA_RELBARO_RAW relbaro $LIVEDATA_RELBARO  $UNIT_UNICODE_PRESSURE_HPA"


        elif [ "$ldf" -eq $LDF_OUTTEMP ]; then

            readInt16BE
            export LIVEDATA_OUTTEMP_RAW=$VALUE_INT16BE
            convertTemperatureLivedata "$VALUE_INT16BE" 
            export LIVEDATA_OUTTEMP="$VALUE_SCALE10_FLOAT"
            
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex outtemp int16be $LIVEDATA_OUTTEMP_RAW outtemp $LIVEDATA_OUTTEMP $UNIT_UNICODE_CELCIUS"


        elif [ "$ldf" -eq $LDF_OUTHUMI ]; then

            readUInt8
            export LIVEDATA_OUTHUMI=$VALUE_UINT8
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex outhumi uint8 $LIVEDATA_OUTHUMI $UNIT_HUMIDITY"


        elif [ "$ldf" -eq $LDF_WINDDIRECTION ]; then

            readUInt16BE
            export LIVEDATA_WINDDIRECTION=$VALUE_UINT16BE
            convertWindDirectionToCompassDirection "$LIVEDATA_WINDDIRECTION"
            export LIVEDATA_WINDDIRECTION_COMPASS="$VALUE_COMPASS_DIRECTION"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex winddirection uint16BE $LIVEDATA_WINDDIRECTION $UNIT_DEGREE"


        elif [ "$ldf" -eq $LDF_WINDSPEED ]; then

            readUInt16BE
            export LIVEDATA_WINDSPEED_RAW=$VALUE_UINT16BE
            convertWindLivedata "$VALUE_UINT16BE"
            export LIVEDATA_WINDSPEED="$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex windspeed uint16BE $LIVEDATA_WINDSPEED_RAW windspeed $LIVEDATA_WINDSPEED $UNIT_UNICODE_WIND_MPS"  


        elif [ "$ldf" -eq $LDF_WINDGUSTSPPED ]; then

            readUInt16BE
            export LIVEDATA_WINDGUSTSPEED_RAW=$VALUE_UINT16BE
            convertWindLivedata "$VALUE_UINT16BE"
            export LIVEDATA_WINDGUSTSPEED="$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex windgustspeed uint16BE $LIVEDATA_WINDGUSTSPEED_RAW windspeed $LIVEDATA_WINDGUSTSPEED $UNIT_UNICODE_WIND_MPS"


        elif [ "$ldf" -eq $LDF_DAYLWINDMAX ]; then

            readUInt16BE
            export LIVEDATA_WINDDAILYMAX_RAW=$VALUE_UINT16BE
            convertWindLivedata "$VALUE_UINT16BE"
            export LIVEDATA_WINDDAILYMAX="$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex winddailymax uint16BE $LIVEDATA_WINDDAILYMAX_RAW winddailymax $LIVEDATA_WINDDAILYMAX $UNIT_UNICODE_WIND_MPS"


        elif [ "$ldf" -eq $LDF_LIGHT ]; then

            readUInt32BE
            export LIVEDATA_LIGHT_RAW=$VALUE_UINT32BE
            convertScale10ToFloat "$VALUE_UINT32BE"
            export LIVEDATA_LIGHT="$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex light uint32BE $LIVEDATA_LIGHT_RAW light $LIVEDATA_LIGHT lux"


        elif [ "$ldf" -eq $LDF_UV ]; then

            readUInt16BE
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex RAW UV value $VALUE_UINT16BE, converting lux $LIVEDATA_LIGHT to W/m2 instead "
            #setUVMode $UNIT_UV_MICROWM2
            #is it µW? is it scale 10 ?
            #lux 976 -> solar radiation raw value 11 -> ecowitt protcol: 7.7 W/m2
            #https://help.ambientweather.net/help/why-is-the-lux-to-w-m-2-conversion-factor-126-7/
            setUVMode $UNIT_UV_WATTM2
            VALUE_UINT16BE=$(( LIVEDATA_LIGHT_RAW*1075/136000 ))
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_UV="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_UVI ]; then

            readUInt8
            export LIVEDATA_UVI=$VALUE_UINT8
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex uvi uint8 $LIVEDATA_UVI"


        elif [ "$ldf" -eq $LDF_SOILMOISTURE1 ] || [ "$ldf" -eq $LDF_SOILMOISTURE2 ] ||
             [ "$ldf" -eq $LDF_SOILMOISTURE3 ] || [ "$ldf" -eq $LDF_SOILMOISTURE4 ] ||
             [ "$ldf" -eq $LDF_SOILMOISTURE5 ] || [ "$ldf" -eq $LDF_SOILMOISTURE6 ] ||
             [ "$ldf" -eq $LDF_SOILMOISTURE7 ] || [ "$ldf" -eq $LDF_SOILMOISTURE8 ]; then #is 16 channels supported?

            readUInt8
            channel=$((((ldf - LDF_SOILMOISTURE1) / 2) + 1))
            eval "export LIVEDATA_SOILMOISTURE$channel=$VALUE_UINT8"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex soilmoisture$channel uint8 $VALUE_UINT8 $UNIT_HUMIDITY"

 
        elif [ "$ldf" -eq $LDF_SOILTEMP1 ] || [ "$ldf" -eq $LDF_SOILTEMP2 ] ||
             [ "$ldf" -eq $LDF_SOILTEMP3 ] || [ "$ldf" -eq $LDF_SOILTEMP4 ] ||
             [ "$ldf" -eq $LDF_SOILTEMP5 ] || [ "$ldf" -eq $LDF_SOILTEMP6 ] ||
             [ "$ldf" -eq $LDF_SOILTEMP7 ] || [ "$ldf" -eq $LDF_SOILTEMP8 ]; then

            readInt16
            convertTemperatureLivedata "$VALUE_INT16BE"
            channel=$((((ldf - LDF_SOILTEMP1) / 2) + 1))
            eval "export LIVEDATA_SOILTEMP$channel=$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex soiltemperature$channel int16BE $VALUE_INT16BE $VALUE_SCALE10_FLOAT $UNIT_UNICODE_CELCIUS"


        elif [ "$ldf" -ge $LDF_TEMP1 ] && [ "$ldf" -le $LDF_TEMP8 ]; then

            readInt16BE
            convertTemperatureLivedata "$VALUE_INT16BE"

            channel=$((ldf - LDF_TEMP1 + 1))
            eval "export LIVEDATA_TEMP$channel=$VALUE_SCALE10_FLOAT"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex temperature$channel int16BE $VALUE_INT16BE $VALUE_SCALE10_FLOAT $UNIT_UNICODE_CELCIUS"


        elif [ "$ldf" -ge $LDF_HUMI1 ] && [ "$ldf" -le $LDF_HUMI8 ]; then

            readUInt8

            channel=$((ldf - LDF_HUMI1 + 1))
            eval "export LIVEDATA_HUMI$channel=$VALUE_UINT8"
            [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] && echo >&2 "$DEBUG_FUNC $ldf_hex humidity$channel uint8 $VALUE_UINT8 $UNIT_HUMIDITY"


        elif [ "$ldf" -eq $LDF_RAINMONTH ]; then

            readUInt32BE
            convertScale10ToFloat "$VALUE_UINT32BE"
            export LIVEDATA_RAINMONTH="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_RAINYEAR ]; then

            readUInt32BE
            convertScale10ToFloat "$VALUE_UINT32BE"
            export LIVEDATA_RAINYEAR="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_RAINWEEK ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_RAINWEEK="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_RAINDAY ]; then

            readUInt16BE
            export LIVEDATA_RAINDAY_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_RAINDAY="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_RAINEVENT ]; then

            readUInt16BE
            export LIVEDATA_RAINEVENT_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_RAINEVENT="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_RAINRATE ]; then

            readUInt16BE
            export LIVEDATA_RAINRATE_RAW=$VALUE_UINT16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_RAINRATE="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -ge $LDF_LEAK_CH1 ] && [ "$ldf" -le $LDF_LEAK_CH4 ]; then

            readUInt8

            channel=$((ldf - LDF_LEAK_CH1 + 1))
            eval "export LIVEDATA_LEAK$channel=$VALUE_UINT8"

        elif [ "$ldf" -eq $LDF_PM25_CH1 ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_PM251_RAW="$VALUE_UINT16BE"
            export LIVEDATA_PM251="$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -ge $LDF_PM25_CH2 ] && [ "$ldf" -le $LDF_PM25_CH4 ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"

            channel=$((ldf - LDF_PM25_CH1 + 1))
            eval "export LIVEDATA_PM25${channel}_RAW=$VALUE_UINT16BE"
            eval "export LIVEDATA_PM25$channel=$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -ge $LDF_PM25_24HAVG1 ] && [ "$ldf" -le $LDF_PM25_24HAVG4 ]; then

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"

            channel=$((ldf - LDF_PM25_24HAVG1 + 1))
            eval "export LIVEDATA_PM25_24HAVG${channel}_RAW=$VALUE_UINT16BE"
            eval "export LIVEDATA_PM25_24HAVG$channel=$VALUE_SCALE10_FLOAT"

        elif [ "$ldf" -eq $LDF_SENSOR_CO2 ]; then

            #/* ------------------Ecowitt-----------------
            # 1 tf_co2        short C x10
            # 2 humi_co2      unsigned char %
            # 3 pm10_co2      unsigned short ug/m3 x10
            # 4 pm10_24h_co2  unsigned short ug/m3 x10
            # 5 pm25_co2      unsigned short ug/m3 x10
            # 6 pm25_24h_co2  unsigned short ug/m3 x10
            # 7 co2           unsigned short ppm
            # 8 co2_24h       unsigned short ppm
            # 9 co2_batt      u8 (0~5)

            readInt16BE
            convertScale10ToFloat "$VALUE_INT16BE"
            export LIVEDATA_WH45CO2_TEMPF="$VALUE_SCALE10_FLOAT"

            readUInt8
            export LIVEDATA_WH45CO2_HUMI=$VALUE_UINT8

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_WH45CO2_PM10="$VALUE_SCALE10_FLOAT"

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_WH45CO2_PM10_24HAVG="$VALUE_SCALE10_FLOAT"

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_WH45CO2_PM25_RAW=$VALUE_UINT16BE
            export LIVEDATA_WH45CO2_PM25="$VALUE_SCALE10_FLOAT"

            readUInt16BE
            convertScale10ToFloat "$VALUE_UINT16BE"
            export LIVEDATA_WH45CO2_PM25_24HAVG_RAW=$VALUE_UINT16BE
            export LIVEDATA_WH45CO2_PM25_24HAVG="$VALUE_SCALE10_FLOAT"

            readUInt16BE
            export LIVEDATA_WH45CO2_CO2=$VALUE_UINT16BE

            readUInt16BE
            export LIVEDATA_WH45CO2_CO2_24HAVG=$VALUE_UINT16BE

            readUInt8
            export LIVEDATA_WH45CO2_BATTERY=$VALUE_UINT8

        elif [ "$ldf" -ge $LDF_TF_USR1 ] && [ "$ldf" -le $LDF_TF_USR8 ]; then

            readInt16BE
            convertTemperatureLivedata "$VALUE_INT16BE"

            channel=$((ldf - LDF_TF_USR1 + 1))
            eval "export LIVEDATA_TF_USR$channel=$VALUE_SCALE10_FLOAT"

            readUInt8
            convertScale10ToFloat "$VALUE_UINT8"
            eval "export LIVEDATA_TF_USR${channel}_BATTERY_RAW=$VALUE_UINT8"
            eval "export LIVEDATA_TF_USR${channel}_BATTERY=$VALUE_SCALE10_FLOAT"
            getBatteryVoltageLevelState "$VALUE_UINT8"
            eval "export LIVEDATA_TF_USR${channel}_BATTERY_STATE=$SBATTERY_STATE"
            

        elif [ "$ldf" -ge $LDF_LIGHTNING ]; then

            readUInt8
            export LIVEDATA_LIGHTNING_DISTANCE=$VALUE_UINT8 # 1-40km

        elif [ "$ldf" -ge $LDF_LIGHTNING_TIME ]; then

            readUInt32BE
            export LIVEDATA_LIGHTNING_TIME=$VALUE_UINT32BE
            getDateUTC "$LIVEDATA_LIGHTNING_TIME"
            export LIVEDATA_LIGHTNING_TIME_UTC="$VALUE_DATE_UTC"


        elif [ "$ldf" -ge $LDF_LIGHTNING_POWER ]; then

            readUInt32BE
            export LIVEDATA_LIGHTNING_POWER=$VALUE_UINT32BE

        elif [ "$ldf" -ge $LDF_LEAF_WETNESS_CH1 ] && [ "$ldf" -le $LDF_LEAF_WETNESS_CH8 ]; then

            readUInt8
            channel=$((ldf - LDF_LEAF_WETNESS_CH1 + 1))

            eval "export LIVEDATA_LEAFWETNESS${channel}=$VALUE_UINT8"

        else
            echo >&2 "ERROR Unable to parse livedata field $(printf "%x" $ldf)"
        fi

    done

    if [ ${#OD_BUFFER} -eq 2 ] && [ "$DEBUG_PARSE_LIVEDATA" -eq 1 ]; then
        readUInt8
        checksum=$VALUE_UINT8
        echo >&2 checksum "$(printf "%02x" $checksum)"
    fi

    [ "$DEBUG_OPTION_TESTSENSOR" -eq 1 ] && injectTestSensorLivedata

    #[ "$DEBUG_PARSE_LIVEDATA" -eq 1 ] &&
    # export -p

    printOrLogLivedata

    unset ldf channel checksum DEBUG_FUNC
    
}

printRaindata() {

    convertScale10ToFloat "$C_RAINRATE"
    rr="$VALUE_SCALE10_FLOAT"

    convertScale10ToFloat "$C_RAINDAILY"
    rd="$VALUE_SCALE10_FLOAT"
    
    convertScale10ToFloat "$C_RAINWEEK"
    rw="$VALUE_SCALE10_FLOAT"
    
    convertScale10ToFloat "$C_RAINMONTH"
    rm="$VALUE_SCALE10_FLOAT"
    
    convertScale10ToFloat "$C_RAINYEAR"
    ry="$VALUE_SCALE10_FLOAT"
    
    echo "rain rate  $rr $UNIT_RAINRATE
rain day   $rd $UNIT_RAIN
rain week  $rw $UNIT_RAIN
rain month $rm $UNIT_RAIN
rain year  $ry $UNIT_RAIN"
   
    unset rr rd rw rm ry
}

parseRaindata() {

    readUInt32BE
    C_RAINRATE=$VALUE_UINT32BE

    readUInt32BE
    C_RAINDAILY=$VALUE_UINT32BE

    readUInt32BE
    C_RAINWEEK=$VALUE_UINT32BE

    readUInt32BE
    C_RAINMONTH=$VALUE_UINT32BE

    readUInt32BE
    C_RAINYEAR=$VALUE_UINT32BE

    printRaindata
}

printCalibration() {
    #if [ "$SHELL_SUPPORT_BULTIN_PRINTF" -eq 1 ]; then
    #   printf "%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n%-40s %7s %-4s\n"\
    #    "calibration in temperature offset"           "$C_CALIBRATION_INTEMPOFFSET"     "$UNIT_TEMP"\
    #    "calibration in humidity offset"              "$C_CALIBRATION_INHUMIDITYOFFSET"   "$UNIT_HUMIDITY"\
    #    "calibration absolute pressure offset"        "$C_CALIBRATION_ABSOFFSET"        "$UNIT_PRESSURE"\
    #    "calibration relative pressure offset"        "$C_CALIBRATION_RELOFFSET"        "$UNIT_PRESSURE"\
    #    "calibration out temperature offset"          "$C_CALIBRATION_OUTTEMPOFFSET"    "$UNIT_TEMP"\
    ##    "calibration out humidity offset"             "$C_CALIBRATION_OUTHUMIDITYOFFSET" "$UNIT_HUMIDITY"\
    #    "calibration wind direction offset"           "$C_CALIBRATION_WINDDIROFFSET" ""
    #else
        echo "calibration in temperature offset           $C_CALIBRATION_INTEMPOFFSET $UNIT_TEMP
calibration in humidity offset              $C_CALIBRATION_INHUMIDITYOFFSET   %
calibration absolute pressure offset        $C_CALIBRATION_ABSOFFSET $UNIT_PRESSURE
calibration relative pressure offset        $C_CALIBRATION_RELOFFSET $UNIT_PRESSURE
calibration out temperature offset          $C_CALIBRATION_OUTTEMPOFFSET $UNIT_TEMP
calibration out humidity offset             $C_CALIBRATION_OUTHUMIDITYOFFSET   %
calibration wind direction offset           $C_CALIBRATION_WINDDIROFFSET" 
   # fi

}

parseCalibration() {

    readInt16BE
    convertScale10ToFloat "$VALUE_INT16BE"
    C_CALIBRATION_INTEMPOFFSET_INT="$VALUE_INT16BE"
    C_CALIBRATION_INTEMPOFFSET="$VALUE_SCALE10_FLOAT"

    readInt8
    C_CALIBRATION_INHUMIDITYOFFSET="$VALUE_INT8"

    readInt32BE
    C_CALIBRATION_ABSOFFSET_INT=$VALUE_INT32BE 
    convertScale10ToFloat "$VALUE_INT32BE"
    C_CALIBRATION_ABSOFFSET="$VALUE_SCALE10_FLOAT"

    readInt32BE
    C_CALIBRATION_RELOFFSET_INT=$VALUE_INT32BE #used for int comparison [ ... ]
    convertScale10ToFloat "$VALUE_INT32BE"
    C_CALIBRATION_RELOFFSET="$VALUE_SCALE10_FLOAT"

    readInt16BE
    C_CALIBRATION_OUTTEMPOFFSET_INT="$VALUE_INT16BE"
    convertScale10ToFloat "$VALUE_INT16BE"
    C_CALIBRATION_OUTTEMPOFFSET="$VALUE_SCALE10_FLOAT"

    readInt8
    C_CALIBRATION_OUTHUMIDITYOFFSET="$VALUE_INT8"

    readInt16BE
    C_CALIBRATION_WINDDIROFFSET="$VALUE_INT16BE"

    printCalibration
}

printPath() {
    echo "path ecowitt      $C_WS_CUSTOMIZED_PATH_ECOWITT
path wunderground $C_WS_CUSTOMIZED_PATH_WU"
}

parsePath() {
    readString
    C_WS_CUSTOMIZED_PATH_ECOWITT=$VALUE_STRING
    readString
    C_WS_CUSTOMIZED_PATH_WU=$VALUE_STRING

    printPath
}

printCustomized() {
    if [ "$C_WS_CUSTOMIZED_HTTP" -eq $HTTP_WUNDERGROUND ]; then #wunderground
    echo "id                 $C_WS_CUSTOMIZED_ID
password           $C_WS_CUSTOMIZED_PASSWORD"
fi

    echo "server             $C_WS_CUSTOMIZED_SERVER
port               $C_WS_CUSTOMIZED_PORT
interval           $C_WS_CUSTOMIZED_INTERVAL
http               $C_WS_CUSTOMIZED_HTTP $C_WS_CUSTOMIZED_HTTP_STATE 
enabled            $C_WS_CUSTOMIZED_ENABLED $C_WS_CUSTOMIZED_ENABLED_STATE"

if [ "$C_WS_CUSTOMIZED_HTTP" -eq $HTTP_ECOWITT ]; then
    echo "path ecowitt       $C_WS_CUSTOMIZED_PATH_ECOWITT"
else
    echo "path wunderground  $C_WS_CUSTOMIZED_PATH_WU"
fi
}

parseCustomized() {
    readString
    C_WS_CUSTOMIZED_ID=$VALUE_STRING

    readString
    C_WS_CUSTOMIZED_PASSWORD=$VALUE_STRING

    readString
    C_WS_CUSTOMIZED_SERVER=$VALUE_STRING

    readUInt16BE
    C_WS_CUSTOMIZED_PORT=$VALUE_UINT16BE

    readUInt16BE
    C_WS_CUSTOMIZED_INTERVAL=$VALUE_UINT16BE

    readUInt8
    C_WS_CUSTOMIZED_HTTP=$VALUE_UINT8

    if [ "$C_WS_CUSTOMIZED_HTTP" -eq 1 ]; then
        C_WS_CUSTOMIZED_HTTP_STATE="wunderground"
    elif [ "$C_WS_CUSTOMIZED_HTTP" -eq 0 ]; then
        C_WS_CUSTOMIZED_HTTP_STATE="ecowitt"
    fi

    readUInt8

    C_WS_CUSTOMIZED_ENABLED=$VALUE_UINT8
    if [ "$C_WS_CUSTOMIZED_ENABLED" -eq 1 ]; then
        C_WS_CUSTOMIZED_ENABLED_STATE="on"
    elif [ "$C_WS_CUSTOMIZED_ENABLED" -eq 0 ]; then
        C_WS_CUSTOMIZED_ENABLED_STATE="off"
    fi

    printCustomized
}

printWunderground() {
    echo "wunderground station id       $C_WS_WUNDERGROUND_ID
wunderground station password $C_WS_WUNDERGROUND_PASSWORD"
}

parseWunderground() {
    readString
    C_WS_WUNDERGROUND_ID=$VALUE_STRING
    readString
    C_WS_WUNDERGROUND_PASSWORD=$VALUE_STRING

    printWunderground
}

printWeathercloud() {
    echo "weathercloud id               $C_WS_WC_ID
weathercloud password         $C_WS_WC_PASSWORD"
}

parseWeathercloud() {
    readString
    C_WS_WC_ID=$VALUE_STRING

    readString
    C_WS_WC_PASSWORD=$VALUE_STRING

    printWeathercloud
}

printWow() {
    echo "wow id                        $C_WS_WOW_ID
wow password                  $C_WS_WOW_PASSWORD"
}

parseWow() {
    readString
    C_WS_WOW_ID=$VALUE_STRING

    readString
    C_WS_WOW_PASSWORD=$VALUE_STRING

    printWow
}

printSensorLine()
#$1 - sensortype, $2 sensor id, $3 battery, $4 signal
{
#observation: leak sensor signal -> starts at level 1 after search state, then increases +1 each time a new rf message is received

    unset SBATTERY_STATE

    getSensorNameShort "$1"
    
   # TEST data 
    #if [ "$1" -eq 40 ]; then
    #   set -- "39" "$(( 0xfff ))" 4 4  # co2
    #  set -- "40" "$(( 0xfff ))" 14 4 # leaf wetness
    #fi

    if [ "$2" -eq "$SENSORID_DISABLE" ]; then 
      style_sensor=$STYLE_SENSOR_DISABLE
      sensorIdState=$SENSORIDSTATE_DISABLED
    elif [ "$2" -eq "$SENSORID_SEARCH" ]; then
      style_sensor=$STYLE_SENSOR_SEARCH
      sensorIdState=$SENSORIDSTATE_SEARCHING
    else
        unset style_sensor
       getSensorBatteryState "$1" "$3"
       if [ "$4" -gt 0 ]; then 
            sensorIdState=$SENSORIDSTATE_CONNECTED
        else
            style_sensor=$STYLE_SENSOR_DISCONNECTED
            sensorIdState=$SENSORIDSTATE_DISCONNECTED
        fi

       if [ "$SHELL_SUPPORT_UNICODE" -eq 1 ]; then
            getSignalUnicode "$4"
            sensorsignal_unicode=$VALUE_SIGNAL_UNICODE
           # unicode e2 96 81 e2 96 82 e2 96 83 e2 96 84 -> each symbol 3 bytes, minimum field size = 4*3 = 12
        fi
    fi

    if [ -n "$style_sensor" ]; then
       style_sensor_off=$STYLE_RESET # insert end escape sequence only if sgi is used
    fi
    
     # 1 battery unicode is field size 4 in printf format string. TEST printf  "🔋 1.3 V" | od -A n -t x1 | wc -w -> 10
     # use \r\t\t\t workaround for unicode alignment
  
    appendBuffer "%6u %9x %3u %1u %4s %-17s $style_sensor%-12s$style_sensor_off\t%s\t%s\n"\
 "'$1' '$2' '$3' '$4'  '$SENSORNAME_WH' '$SENSORNAME_SHORT' '$sensorIdState' '$SBATTERY_STATE' '$sensorsignal_unicode'"
    
    unset sensorIdState sensorsignal_unicode style_sensor_off style_sensor
}

resetAppendBuffer()
{
   unset APPEND_FORMAT APPEND_ARGS
}

getSignalUnicode()
{
    eval VALUE_SIGNAL_UNICODE="\$UNICODE_SIGNAL_LEVEL$1"
}

setSignal()
#$1 sensorname WH?? $2 value
{
    export LIVEDATA_"$1"_SIGNAL="$2"
    getSignalUnicode "$2"
    export LIVEDATA_"$1"_SIGNAL_STATE="$VALUE_SIGNAL_UNICODE" 
}

setLivedataSignal()
# $1 sensortype $2 signal
#maps sensor type to livedata
{
    
    if [ "$1" -ge $SENSORTYPE_WH31TEMP ] && [ "$1" -lt $(( SENSORTYPE_WH31TEMP + SENSORTYPE_WH31TEMP_MAXCH )) ]; then
        setSignal "TEMP$(( $1 - SENSORTYPE_WH31TEMP + 1))" "$2"
    elif [ "$1" -eq $SYSTEM_SENSOR_TYPE_WH24 ]; then
        setSignal "WH65" "$2"
    elif [ "$1" -eq $SENSORTYPE_WH68 ]; then
        setSignal "WH68" "$2"
    elif [ "$1" -eq $SENSORTYPE_WH80 ]; then
        setSignal "WH80" "$2"
    elif [ "$1" -eq $SENSORTYPE_WH32 ]; then
        setSignal "WH32" "$2"
    elif [ "$1" -eq $SENSORTYPE_WH40 ]; then
       setSignal "WH40_RAINFALL" "$2"
    elif [ "$1" -eq $SENSORTYPE_WH57LIGHTNING ]; then
       setSignal "LIGHTNING" "$2"
    elif [ "$1" -ge $SENSORTYPE_WH51SOILMOISTURE ] && [ "$1" -lt $(( SENSORTYPE_WH51SOILMOISTURE + SENSORTYPE_WH51SOILMOISTURE_MAXCH )) ]; then
       setSignal "SOILMOISTURE$(( $1 - SENSORTYPE_WH51SOILMOISTURE + 1))" "$2"
    elif [ "$1" -ge $SENSORTYPE_WH55LEAK ] && [ "$1" -lt $(( SENSORTYPE_WH55LEAK + SENSORTYPE_WH55LEAK_MAXCH )) ]; then
       setSignal "LEAK$(( $1 - SENSORTYPE_WH55LEAK + 1))" "$2"
    elif [ "$1" -ge $SENSORTYPE_WH34SOILTEMP ] && [ "$1" -lt $(( SENSORTYPE_WH34SOILTEMP + SENSORTYPE_WH34SOILTEMP_MAXCH )) ]; then
       setSignal "SOILTEMP$(( $1 - SENSORTYPE_WH34SOILTEMP + 1))" "$2"
    elif [ "$1" -ge $SENSORTYPE_WH43PM25 ] && [ "$1" -lt $(( SENSORTYPE_WH43PM25 + SENSORTYPE_WH43PM25_MAXCH )) ]; then
       setSignal "PM25$(( $1 - SENSORTYPE_WH43PM25 + 1))" "$2"
    elif [ "$1" -ge $SENSORTYPE_WH35LEAFWETNESS ] && [ "$1" -lt $(( SENSORTYPE_WH35LEAFWETNESS + SENSORTYPE_WH35LEAFWETNESS_MAXCH )) ]; then
       setSignal "LEAFWETNESS$(( $1 - SENSORTYPE_WH35LEAFWETNESS + 1))" "$2"
    fi
      
}

parseSensorIdNew()
{
    resetAppendBuffer

    printSensorHeader=0
    if [ -z "$SENSORVIEW_HIDE_HEADER" ];  then 
       printSensorHeader=1
    elif [ "$SENSORVIEW_HIDE_HEADER" -eq 0 ]; then
       printSensorHeader=1
    fi

    if [ $printSensorHeader -eq 1 ]; then
                      #1:Sensortype 2:sid 3:battery 4:signal 5:type 6:name 7:state 8:battery 9:signal
        appendBuffer "%6s %9s %3s %1s %-4s %-17s %-12s\t%s\t%s\n%s\n" "$SENSORID_HEADER ───────────────────────────────────────────────────────────────────────────────"
    fi

    [ "$DEBUG" -eq  1 ] && >&2 echo "parseSensorIdNew SPATTERNID $SPATTERNID length od buffer ${#OD_BUFFER}"
    
     LIVEDATA_SENSOR_COUNT_SEARCHING=0
     LIVEDATA_SENSOR_COUNT_CONNECTED=0
     LIVEDATA_SENSOR_COUNT_DISCONNECTED=0
     LIVEDATA_SENSOR_COUNT_DISABLED=0

    while [ ${#OD_BUFFER} -ge 7 ]; do
       
        readUInt8            #type
        stype=$VALUE_UINT8
       
        readUInt32BE         #id
        SID=$VALUE_UINT32BE

        readUInt8   
        battery=$VALUE_UINT8
        
        readUInt8
        signal=$VALUE_UINT8

        if [ $SID -eq $SENSORID_SEARCH ]; then
            LIVEDATA_SENSOR_COUNT_SEARCHING=$(( LIVEDATA_SENSOR_COUNT_SEARCHING + 1 ))
        elif [ $SID -eq $SENSORID_DISABLE ]; then
            LIVEDATA_SENSOR_COUNT_DISABLED=$(( LIVEDATA_SENSOR_COUNT_DISABLED + 1 ))
        elif [ $signal -gt 0 ]; then
            LIVEDATA_SENSOR_COUNT_CONNECTED=$(( LIVEDATA_SENSOR_COUNT_CONNECTED + 1 ))
            setLivedataSignal "$stype" "$signal"
        elif [ $signal -eq 0 ]; then
            LIVEDATA_SENSOR_COUNT_DISCONNECTED=$(( LIVEDATA_SENSOR_COUNT_DISCONNECTED + 1 ))
        fi

        #pattern matching
        printSensorMatch=0

        if [ "$SPATTERNID" = "$SPATTERNID_CONNECTED" ] && [ $SID -ne $SENSORID_SEARCH ] && [ $SID -ne $SENSORID_DISABLE ]; then # connected sensor
            printSensorMatch=1
        elif [ "$SPATTERNID" = "$SPATTERNID_DISCONNECTED" ] && [ $SID -ne $SENSORID_SEARCH ] && [ $SID -ne $SENSORID_DISABLE ] && [ $signal -eq 0 ]; then
            printSensorMatch=1
        elif [ "$SPATTERNID" = "$SPATTERNID_RANGE" ] && [ -n "$SPATTERNID_RANGE_LOW" ] && [ -n "$SPATTERNID_RANGE_HIGH" ] && [ $stype -ge "$SPATTERNID_RANGE_LOW" ] && [ $stype -le "$SPATTERNID_RANGE_HIGH" ]; then 
            printSensorMatch=1
        elif [ "$SPATTERNID" = "$SPATTERNID_SEARCHING" ] && [ $SID -eq "$SENSORID_SEARCH"  ]; then 
            printSensorMatch=1
        elif [ "$SPATTERNID" = "$SPATTERNID_DISABLED" ] && [ "$SID" -eq "$SENSORID_DISABLE" ]; then
            printSensorMatch=1
        elif [ -z "$SPATTERNID" ]; then #all sensors
            printSensorMatch=1
        fi

        if [ $printSensorMatch -eq 1 ]; then
            printSensorLine $stype $SID $battery $signal
        fi
        
        [ "$DEBUG" -eq 1 ] && >&2 echo "type $stype id $SID battery $battery signal $signal od_buffer length ${#OD_BUFFER}"
    done

    printAppendBuffer

    unset stype signal battery printSensorHeader printSensorMatch
}

parsePacket() {
   
    EXITCODE_PARSEPACKET=0
   
    if [ -z "$1" ]; then
        [ "$DEBUG" -eq 1 ] && echo >&2 Empty od buffer
        EXITCODE_PARSEPACKET="$ERROR_OD_BUFFER_EMPTY"
        return "$EXITCODE_PARSEPACKET"
    fi

    newBuffer "OD_BUFFER" "$1"
    OD_BUFFER_BACKUP="$1"

    readSlice 4

    PRX_PREAMBLE="$B1 $B2"
    if [ "$PRX_PREAMBLE" != "255 255" ]; then
        EXITCODE_PARSEPACKET="$ERROR_PRX_PREAMBLE"
        return $EXITCODE_PARSEPACKET
    fi

    PRX_CMD_UINT8=$((B3))
    getCommandName "$PRX_CMD_UINT8"
    { [ "$DEBUG" -eq 1 ] || [ "$DEBUG_OPTION_OD_BUFFER" ] ; } && {
       printf >&2 "< %-20s" "$COMMAND_NAME"
       printBuffer >&2 "$1" 
    }

    #Packet length
    if [ "$PRX_CMD_UINT8" -eq $CMD_BROADCAST ] || [ "$PRX_CMD_UINT8" -eq $CMD_LIVEDATA ] || [ "$PRX_CMD_UINT8" -eq $CMD_READ_SENSOR_ID_NEW ]; then
        readUInt8
        PACKET_RX_LENGTH=$(((B4 << 8) & VALUE_UINT8))
    else
        PACKET_RX_LENGTH=$((B4))
    fi

    [ $DEBUG -eq 1 ] && echo >&2 "RX PACKET LENGTH $PACKET_RX_LENGTH"

    if isWriteCommand "$PRX_CMD_UINT8"; then
        parseResult
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_VERSION ]; then
        parseVersion
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_MAC ]; then
        parseMAC
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_ECOWITT_INTERVAL ]; then
        parseEcowittInterval
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_WUNDERGROUND ]; then
        parseWunderground
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_WEATHERCLOUD ]; then
        parseWeathercloud
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_WOW ]; then
        parseWow
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_SYSTEM ]; then
        parseSystem
    elif [ "$PRX_CMD_UINT8" -eq $CMD_LIVEDATA ]; then
        parseLivedata
    elif [ "$PRX_CMD_UINT8" -eq $CMD_BROADCAST ]; then
        parseBroadcast
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_RAINDATA ]; then
        parseRaindata
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_CALIBRATION ]; then
        parseCalibration
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_PATH ]; then
        parsePath
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_CUSTOMIZED ]; then
        parseCustomized
    elif [ "$PRX_CMD_UINT8" -eq $CMD_READ_SENSOR_ID_NEW ] ||[ "$PRX_CMD_UINT8" -eq $CMD_READ_SENSOR_ID ]; then
        parseSensorIdNew
    else
        echo >&2 ERROR Parsing of command "$COMMAND_NAME" not supported
        EXITCODE_PARSEPACKET=$ERROR_PARSEPACKET_UNSUPPORTED_COMMAND
    fi

    [ $DEBUG -eq 1 ] && echo >&2 "Received command $PRX_CMD integer cmd $PRX_CMD_UINT8"

    return "$EXITCODE_PARSEPACKET"
}

getHexDigit() {
    unset VALUE_HEX_DIGIT

    if [ "$1" -ge 0 ] && [ "$1" -le 9 ]; then
        VALUE_HEX_DIGIT=$1
    elif [ "$1" -eq 10 ]; then
        VALUE_HEX_DIGIT='a'
    elif [ "$1" -eq 11 ]; then
        VALUE_HEX_DIGIT='b'
    elif [ "$1" -eq 12 ]; then
        VALUE_HEX_DIGIT='c'
    elif [ "$1" -eq 13 ]; then
        VALUE_HEX_DIGIT='d'
    elif [ "$1" -eq 14 ]; then
        VALUE_HEX_DIGIT='e'
    elif [ "$1" -eq 15 ]; then
        VALUE_HEX_DIGIT='f'
    fi
}

convertUInt8ToHex() {
#$1 - decimal value to convert to hex
    if [ "$SHELL_SUPPORT_BULTIN_PRINTF_VOPT" -eq 1 ]; then
    #shellcheck disable=SC3045
        printf -v VALUE_UINT8_HEX "%02x" "$1"
        return
    fi

    lsb=$(($1 & 0xf))
    getHexDigit "$lsb"
    lsb_hexdigit=$VALUE_HEX_DIGIT

    if [ "$1" -gt 15 ]; then
        msb=$(($1 >> 4))
        getHexDigit "$msb"
        VALUE_UINT8_HEX=$VALUE_HEX_DIGIT$lsb_hexdigit
    else
        VALUE_UINT8_HEX=0$VALUE_HEX_DIGIT
    fi

    unset lsb lsb_hexdigit msb
}

newPacketBody() {
    if [ -z "$1" ]; then
        echo >&2 Error no command given to newPacketBody
        return 1
    fi

    PACKET_TX_CMD=$(($1))
    getCommandName "$PACKET_TX_CMD"

    PACKET_TX_PREAMBLE="255 255"
    unset PACKET_TX_BODY
}

getLength()
#get length of tx packet buffer
#$1 string of uint8 integers with space
{
    IFS=' '
    VALUE_LENGTH=0
    for BYTE in $1; do
      VALUE_LENGTH=$(( VALUE_LENGTH + 1 ))
    done
    unset BYTE
}

checksumPacketTX() {
    getLength "$PACKET_TX_BODY"
    PACKET_TX_BODY_LENGTH=$((VALUE_LENGTH + 2)) # at least 2 byte for length + checksum bytes

    if [ "$PACKET_TX_CMD" -eq "$CMD_BROADCAST" ] || [ "$PACKET_TX_CMD" -eq $CMD_WRITE_SSID ]; then # 2 byte length 
        PACKET_TX_BODY_LENGTH=$(( PACKET_TX_BODY_LENGTH + 1 ))
        PACKET_TX_LENGTH=" $(( ((PACKET_TX_BODY_LENGTH + 1) & 0xff00) >> 8 )) $(( (PACKET_TX_BODY_LENGTH + 1) & 0xff ))"
    else
        PACKET_TX_LENGTH=$((PACKET_TX_BODY_LENGTH + 1)) # add 1 byte for cmd field
    fi

    if [ -n "$PACKET_TX_BODY" ]; then
        PACKET_TX_BODY="$PACKET_TX_CMD $PACKET_TX_LENGTH $PACKET_TX_BODY"

    else
        PACKET_TX_BODY="$PACKET_TX_CMD $PACKET_TX_LENGTH"
    fi

    checksum "$PACKET_TX_BODY"

    PACKET_TX_BODY="$PACKET_TX_BODY $VALUE_CHECKSUM"
    PACKET_TX="$PACKET_TX_PREAMBLE $PACKET_TX_BODY"

    [ $DEBUG -eq 1 ] && echo >&2 "PACKET_TX $PACKET_TX PACKET_TX_BODY $PACKET_TX_BODY"
}

convertHexToOctal() { #$1 - 0xff format
    if [ "$SHELL_SUPPORT_BULTIN_PRINTF_VOPT" -eq 1 ]; then
    #shellcheck disable=SC3045
       printf -v VALUE_OCTAL "%03o" "$1"
       return
    fi

    dec=$(($1))

    lsb=$((dec & 7)) #least significant 3-bit sequence
    middle=$(((dec >> 3) & 7))
    msb=$((dec >> 6))
    VALUE_OCTAL=$msb$middle$lsb

    [ $DEBUG -eq 1 ] && echo >&2 Converting "$1" to octal "$VALUE_OCTAL"

    unset dec lsb msb middle
}

convertBufferFromDecToOctalEscape() {
    unset VALUE_OCTAL_BUFFER_ESCAPE

    for BYTE in $1; do
        convertHexToOctal "$BYTE"
        VALUE_OCTAL_BUFFER_ESCAPE="$VALUE_OCTAL_BUFFER_ESCAPE\\0$VALUE_OCTAL"
    done

    [ $DEBUG -eq 1 ] && echo >&2 "Octal buffer $VALUE_OCTAL_BUFFER_ESCAPE"

    unset BYTE
}

createPacketTX()
{
    checksumPacketTX
    convertBufferFromDecToOctalEscape "$PACKET_TX" # \0377 \0377 \0nnn

    PACKET_TX_ESCAPE=$VALUE_OCTAL_BUFFER_ESCAPE
}

sendPacket() {
    EXITCODE_SENDPACKET=0

   if ! sendPacketnc "$@"; then # $@ each arg expands to a separate word
      EXITCODE_SENDPACKET=$EXITCODE_SENDPACKETNC
      [ "$DEBUG" -eq 1 ] && echo >&2 "Sendpacket failed with error code $EXITCODE_SENDPACKET"
   fi
    
    return "$EXITCODE_SENDPACKET"
}

sendPacketnc() { #$1 - command
    EXITCODE_SENDPACKETNC=0
    #$2 - host

    timeout_nc=0.05
    timeout_udp_broadcast=0.236 # timeout selected based on udp port scanning 254 hosts in 60s (60s/254=0.236s)
    useTimeout=0

    #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
    if [ $# -ge 1 ]; then
        newPacketBody "$1"
    fi

    if [ -n "$2" ]; then
        host="$2" # for udp broadcast probing on subnet
    else
        host="$C_HOST" # -g option
    fi

    if [ -z "$host" ]; then
      echo >&2 Error: No host specified
      EXITCODE_SENDPACKETNC="$ERROR_NO_HOST_SPECIFIED"
      return $EXITCODE_SENDPACKETNC
    fi

    createPacketTX

    { [ "$DEBUG" -eq 1 ] || [ "$DEBUG_OPTION_OD_BUFFER" ] ; } &&
    {
        printf >&2 "> %-20s" "$COMMAND_NAME"
        printBuffer >&2 "$PACKET_TX"
    }

    unset rxpipecmd txpipecmd

    if [ "$DEBUG_OPTION_TRACEPACKET" -eq 1 ]; then
       #visual studio code: problems with : display for date -> using space
       tracedate=$(date +'%H %M %S %N') #https://superuser.com/questions/674464/print-current-time-with-milliseconds
       rxpipecmd=" | tee \"rx-$COMMAND_NAME-$tracedate.hex\""
       txpipecmd=" | tee \"tx-$COMMAND_NAME-$tracedate.hex\""
    fi

    port=$PORT_GW_TCP

    if [ $PACKET_TX_CMD -eq $CMD_BROADCAST ]; then
        ncUDPOpt='-u' # udp mode
        port=$PORT_GW_UDP
        timeout_nc=$timeout_udp_broadcast
        useTimeout=1
    elif [ "$PACKET_TX_CMD" -eq $CMD_WRITE_RESET ] || [ "$PACKET_TX_CMD" -eq $CMD_WRITE_SSID ]; then
        :
    elif [ "$PACKET_TX_CMD" -eq $CMD_REBOOT ]; then
       useTimeout=1
       timeout_nc=1
       #sometimes result packet from gw is not received, and nc hangs
    fi

    # change between openbsd/nmap ncat in WSL2/ubuntu - sudo update-alternatives --config nc

    odcmdstr="od -A n -t u1 -w$MAX_16BIT_UINT"

    if [ "$NC_VERSION" = $NC_OPENBSD ]; then

        # -N shutdown(2) the network socket after EOF on the input / from man nc - otherwise nc hangs
        nccmdstr="\"$NC_CMD\" -4 -N -w 1 $ncUDPOpt $host $port" 
       
       # if [ "$useTimeout" -eq 1 ]; then
       #    nccmdstr="timeout $timeout_nc $nccmdstr"
       # fi
        
        cmdstr="printf %b \"$PACKET_TX_ESCAPE\" $txpipecmd | $nccmdstr $rxpipecmd | $odcmdstr"

    elif [ "$NC_VERSION" = $NC_NMAP ]; then

        #sleep to disable immediate EOF and shutdown of ncat -> which leads to data not received from udp socket
       
        nccmdstr="\"$NC_CMD\" -4 -w 1  $ncUDPOpt $host $port"
        cmdstr="{ printf %b \"$PACKET_TX_ESCAPE\" $txpipecmd ; sleep $timeout_nc; } |  $nccmdstr $rxpipecmd | $odcmdstr"

    elif [ "$NC_VERSION" = $NC_TOYBOX ]; then

        nccmdstr="$NC_CMD -4 $ncUDPOpt $host $port"
        
        if [ "$useTimeout" -eq 1 ]; then
           nccmdstr="timeout $timeout_nc $nccmdstr"
        fi

        cmdstr="printf %b \"$PACKET_TX_ESCAPE\" $txpipecmd | $nccmdstr $rxpipecmd | $odcmdstr"

    elif [ "$NC_VERSION" = $NC_BUSYBOX ]; then

        nccmdstr="$NC_CMD $host $port"

        if [ -z "$ncUDPOpt" ]; then
            cmdstr="printf %b \"$PACKET_TX_ESCAPE\" $txpipecmd |  $nccmdstr $rxpipecmd | $odcmdstr"
        else
            echo >&2 Busybox nc does not support UDP
        fi
    else
        echo >&2 "Error: nc version $NC_VERSION not supported sendPacketnc $ERROR_DEPENDENCY_NC"
        return "$ERROR_DEPENDENCY_NC"
    fi

    if [ -n "$cmdstr" ]; then

       if [ -n "$DEBUG_OPTION_COMMAND" ] && [ "$DEBUG_OPTION_COMMAND" -eq 1 ]; then
            printf >&2 "%s: %s\n" "$COMMAND_NAME" "$cmdstr"
       fi
       
       if [ $DEBUG -eq 1 ]; then
            echo >&2 "Sending packet to ip $host port $port"
       fi 

       od_buffer=$(eval "$cmdstr" )
       #maybe use: https://stackoverflow.com/questions/1550933/catching-error-codes-in-a-shell-pipe
       parsePacket "$od_buffer"
       EXITCODE_SENDPACKETNC=$?
    fi

    unset ncUDPOpt ncIdleOpt port host timeout_udp_broadcast useTimeout timeout_nc od_buffer cmdstr nccmdstr odcmdstr  rxpipecmd txpipecmd

    return $EXITCODE_SENDPACKETNC
}

discovery() {
    if [ -n "$NC_VERSION" ]; then
        discovery_nc "$@"
    else
        echo >&2 Error nc not found, cannot scan for devices
    fi
}

discovery_udp_subnet() { #$1 - subnet, for example 192.168.3
    #issue: nc fails to read when sending to subnet broadcast address 192.168.3.255
    #host reply with ICMP host/port unreachable or broadcast response
    #send broadcast cmd to port 46000
    #some host responses take a long time > 175ms, but most take only 4-8ms, so -s subnet should be run multiple times to get all hosts on the subnet
    #wireshark filter: ip.addr == 192.168.3.80 || ip.addr == 192.168.3.49 || ip.addr == 192.168.3.204
    #wireshark: Time field: "Delta time displayed"
    #testing environment: vEthernet WSL adapter/ubuntu, Windows 11, Realtek RTL8852AE WiFi 6 802.11ax PCIe, Huawei AX mesh router 5Ghz channel 36,WPA2
    
    EXITCODE_DISCOVERY=0

    case $1 in
        *.*.*) 
                subnet_valid=1
                ;;
            *)
                subnet_valid=0 
                ;;
    esac

   if [ $subnet_valid -eq 0 ]; then
        echo >&2 "Error: Invalid subnet address, use ddd.ddd.ddd"
        EXITCODE_DISCOVERY=$ERROR_INVALID_SUBNET
        return "$ERROR_INVALID_SUBNET"
   fi
    
    hostnumber=1
    while [ "$hostnumber" -le 254 ]; do
        #[ $DEBUG -eq 1 ] && 
        printf >&2 "\r%s " "$1.$hostnumber"
        sendPacket $CMD_BROADCAST "$1.$hostnumber" 
        hostnumber=$((hostnumber + 1))
    done

    unset hostnumber

    return $EXITCODE_DISCOVERY
}

discovery_nc() { #$1 - subnet for udp scan

    scan_max_iterations=10
    scan_nc_idle_timeout=0.005 # 5ms

    case "$KSH_VERSION" in
        *Android*)
            echo >&2 "Error: UDP scanning for devices not supported ( -u -l options ), nc version $NC_VERSION"
            # udp -u -l option gives 1 error code and 'nc: listen' output
            return "$ERROR_NC_UDP_SCAN_UNAVAILABLE"
            ;;
    esac

    if [ -z "$1" ]; then # set up server on 59387 port

        if [ "$NC_VERSION" = $NC_NMAP ]; then
            scan_max_iterations=30
            SCAN_NC_TIMEOUT=0.1
        fi

        if scan_result=$(
            n=0
            while [ $n -lt $scan_max_iterations ]; do
                if [ "$NC_VERSION" = $NC_NMAP ]; then
                    $NC_CMD -4 -u -i $scan_nc_idle_timeout -l $PORT_CLIENT_UDP 2>/dev/null | od -A n -w64 -t x1
                else
                    timeout $SCAN_NC_TIMEOUT "$NC_CMD" -4 -u -l $PORT_CLIENT_UDP 2>/dev/null | od -A n -w64 -t x1
                fi
                n=$((n + 1))
            done | sort -u
        ); then #"A Brief POSIX Advocacy: Shell Script Portability" https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf

            if [ -n "$scan_result" ]; then
                IFS=$(printf "\n\b") # #https://stackoverflow.com/questions/16831429/when-setting-ifs-to-split-on-newlines-why-is-it-necessary-to-include-a-backspac
                for broadcast in $scan_result; do
                    parse_od_hex_packet "$broadcast"
                done
            fi
        else
            echo >&2 Error failed to obtain scan result while listening on UDP port $PORT_CLIENT_UDP, error code $?
        fi
    else
        discovery_udp_subnet "$1"
    fi

    unset scan_max_iterations scan_nc_idle_timeout n broadcast

    return $EXITCODE_DISCOVERY
}

checksum() {
    sum=0

    [ "$DEBUG" -eq 1 ] && >&2 echo  "checksum calculation on $1"
    
    IFS=" "
    for BYTE in $1; do
        [ $DEBUG -eq 1 ] && >&2 echo  "checksum read $BYTE"
        sum=$(( (sum + BYTE) & 255 ))
    done

    [ $DEBUG -eq 1 ] &&  >&2  echo "checksum $sum $(printf "%2x" $sum)"

    VALUE_CHECKSUM=$sum

     unset sum BYTE
}

newCustomizedPacket() {
    newPacketBody $CMD_WRITE_CUSTOMIZED
    writeString "$C_WS_CUSTOMIZED_ID"
    writeString "$C_WS_CUSTOMIZED_PASSWORD"
    writeString "$C_WS_CUSTOMIZED_SERVER"
    writeUInt16BE "$C_WS_CUSTOMIZED_PORT"
    writeUInt16BE "$C_WS_CUSTOMIZED_INTERVAL"
    writeUInt8 "$C_WS_CUSTOMIZED_HTTP"
    writeUInt8 "$C_WS_CUSTOMIZED_ENABLED"
}

newPathPacket() {
    newPacketBody $CMD_WRITE_PATH
    writeString "$C_WS_CUSTOMIZED_PATH_ECOWITT"
    writeString "$C_WS_CUSTOMIZED_PATH_WU"
}

parseSystemOption()
#format : t=wh65,tz=3,dst=1|on,auto=on|1'
{
    EXITCODE_PARSESYSTEMOPTIONS=0

    #copy current configuration
    systemtype=$C_SYSTEM_SENSORTYPE
    systemtzindex=$C_SYSTEM_TIMEZONE_INDEX
    systemdst=$C_SYSTEM_TIMEZONE_DST_BIT
    systemauto=$C_SYSTEM_TIMEZONE_AUTOOFF_BIT

    IFS=','
    #shellcheck disable=SC2086
    set -- $1
    
    for opt in "$@"; do
      IFS='='
      #shellcheck disable=SC2086
      set -- $opt
      case "$1" in 
        t|type) case "$2" in
                0|wh24)    systemtype=0
                        ;;
                1|wh65)     systemtype=1
                        ;;
                *)  echo >&2 "type=0 | wh24 or 1 | wh65"
                            EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
                            ;;
            esac
            ;;
        tz) if isNumber "$2"; then
                systemtzindex=$2
            else
                echo >&2 "tz=0-$SYSTEM_TIMEZONE_MAX_INDEX"
                printTimezones
                EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
            fi
            ;;
        dst|d) case "$2" in
                0|off)  systemdst=0
                        ;;
                1|on)   systemdst=1
                        ;;
                *)      echo >&2 "dst=0 | off | 1 | on"
                        EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
                        ;;
                esac
                ;;
        auto|a) case "$2" in
                0|off)  systemauto=0
                        ;;
                1|on)   systemauto=1
                        ;;
                 *)     echo >&2 "auto=0 | off | 1 | on"
                        EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
                        ;;
                esac
                ;; 
            
        *) echo >&2 "Unknown key '$1', use type,tz,dst,auto"
           EXITCODE_PARSESYSTEMOPTIONS=$ERROR_SYSTEMPARAM_NOTSPECIFIED
        ;;
      esac
    done

    sendSystemPacket "$systemtype" "$systemtzindex" "$systemdst" "$systemauto"

    unset opt systemtype systemtzindex systemdst systemauto

    return $EXITCODE_PARSESYSTEMOPTIONS

}

sendSystemPacket() 
#$1 sysmtemtype, $2 tz index, $3 dst bit, $4 autooff bit
{
    dst=0

    if ! isNumber "$1" || [ "$1" -gt 1 ]; then
        echo >&2 Error: System type must be 0 for WH24, or 1 for WH65 - "$1" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    if ! isNumber "$2" || [ "$2" -gt "$SYSTEM_TIMEZONE_MAX_INDEX" ]; then
        echo >&2 Error: System timezone index must be between 0 - "$SYSTEM_TIMEZONE_MAX_INDEX", "$2" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    if ! isNumber "$3" || [ "$3" -gt 1 ]; then
        echo >&2 Error: Daylight saving must be 0 for disabled, or 1 for enabled - "$3" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    if ! isNumber "$4" || [ "$4" -gt 1 ]; then
        echo >&2 Error: Auto timezone must be 0 for enabled, or 1 for disabled - "$4" invalid
        return "$ERROR_SYSTEMPARAM_NOTSPECIFIED"
    fi

    #autooff 0->auto 1
    #autooff 1->auto 0

    if [ "$4" -eq 0 ]; then
        dst=$(($3 | 2))
    else
        dst=$(($3))
    fi

    newPacketBody $CMD_WRITE_SYSTEM
    writeUInt8 0      #frequency - only read
    writeUInt8 "$1"   #sensortype 0=WH24, 1=WH65
    writeUInt32BE 0   #UTC time - only read
    writeUInt8 "$2"   #timezone index/manual -> not updated by setting auto timezone
    writeUInt8 "$dst" #daylight saving - dst
    
    sendPacket

    unset dst
}

sendRaindata() {
    # if ! [[ "$1" =~ ^[0-9]+$ ]] || ! [[ "$2" =~ ^[0-9]+$ ]] || ! [[ "$3" =~ ^[0-9]+$ ]] || ! [[ "$4" =~ ^[0-9]+$ ]]; then
    if ! isNumber "$1" || ! isNumber "$2" || ! isNumber "$3" || ! isNumber "$4"; then
        echo Error: Raindata has "element(s)" which is not a number
        return "$ERROR_RAINDATA_NOTSPECIFIED"
    fi

    [ $DEBUG -eq 1 ] && echo >&2 rainday "$2" rainweek "$3" rainmonth "$4" rainyear "$5"

    newPacketBody $CMD_WRITE_RAINDATA
    writeUInt32BE "$1" #rainday
    writeUInt32BE "$2" #rainweek
    writeUInt32BE "$3" #rainmonth
    writeUInt32BE "$4" #rainyear
    [ $DEBUG -eq 1 ] && echo >&2 "Sending raindata rd $1 rw $2 rm $3 ry $4"
   
   if ! sendPacket; then
        echo >&2 "Error: Failed to send rain data $EXITCODE_SENDPACKET" 
   fi

   return $EXITCODE_SENDPACKET
}

sendCalibration() {
    
    newPacketBody $CMD_WRITE_CALIBRATION

    writeInt16BE    "$1" #intempoffset
    writeInt8       "$2" #inhumidityoffset
    writeInt32BE    "$3" #absoffset
    writeInt32BE    "$4" #reloffset
    writeInt16BE    "$5" #outtempoffset
    writeInt8       "$6" #outhumidityoffset
    writeInt16BE    "$7" #winddiroffset

    #[ $DEBUG -eq 1 ] &&
     echo >&2 "Sending calibration intemp $1 inhumi $2 abspressure $3 relpressure $4 outtemp $5 outhumi $6 winddirection $7"
    
    sendPacket
    

    return "$EXITCODE_SENDPACKET"
}

sendEcowittIntervalnew() {
    # observation: GW1000 red-wifi led blinks slowly if not sending data to ecowitt when 0=off
    if [ "$1" -ge 0 ] && [ "$1" -le 5 ]; then
        newPacketBody $CMD_WRITE_ECOWITT_INTERVAL
        writeUInt8 "$1" #interval
        [ $DEBUG -eq 1 ] && echo >&2 Sending ecowitt interval "$1"
        sendPacket
    else
        echo >&2 Error Not a valid ecowitt interval, range 0-5 minutes
    fi
}

sendEcowittInterval() {
    # observation: GW1000 red-wifi led blinks slowly if not sending data to ecowitt when 0=off
    if [ "$1" -ge 0 ] && [ "$1" -le 5 ]; then
        newPacketBody $CMD_WRITE_ECOWITT_INTERVAL
        writeUInt8 "$1" #interval
        [ $DEBUG -eq 1 ] && echo >&2 Sending ecowitt interval "$1"
        sendPacket
    else
        echo >&2 Error Not a valid ecowitt interval, range 0-5 minutes
    fi
}

sendWeatherservice() {

    newPacketBody "$1"
    writeString "$2"
    writeString "$3"

    case "$1" in
    "$CMD_WRITE_WOW")
        writeUInt8 0 # stationnum size - unused
        writeUInt8 1
        ;;

    "$CMD_WRITE_WEATHERCLOUD")
        writeUInt8 1
        ;;
    esac
    [ $DEBUG -eq 1 ] && echo >&2 "Sending weather service $1 id $2 password $3"
    sendPacket
}

sendCustomized() {
    newCustomizedPacket
    sendPacket

    newPathPacket
    sendPacket
}

updateCustomized() {

    EXITCODE_CUSTOMIZED=0

    #readarray -d ',' -t OPTION_CUSTOMIZED < <(echo -n "$1") # <<< HERE string appends 0x0a -> using process substitution

    [ $DEBUG -eq 1 ] && echo >&2 "updateCustomized $1"

    # 1. parse , expressions server=localhost,port=8080,protocol=ecowitt,enabled=yes

     IFS=','
     for option in $1; do
        
        [ $DEBUG -eq 1 ] && echo >&2 "updateCustomized: option $option"

        # 2. parse = expressions

        IFS='='
        #shellcheck disable=SC2086
        set -- $option
        key=$1
        value=$2

        [ $DEBUG -eq 1 ] && echo >&2 "updateCustomized KEY $key len ${#key} VALUE $value len ${#value}"

        case "$key" in

            id)
                [ $DEBUG -eq 1 ] && echo >&2 Update customized_id from "$C_WS_CUSTOMIZED_ID to $value"
                C_WS_CUSTOMIZED_ID=$value
                ;;

            password | pw)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_password from "${C_WS_CUSTOMIZED_PASSWORD} to $value"
                C_WS_CUSTOMIZED_PASSWORD=$value
                #observation: gw1000 client will not send wunderground http request unless password and id is specified
                ;;

            server | s)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_server from "$C_WS_CUSTOMIZED_SERVER to $value"
                C_WS_CUSTOMIZED_SERVER=$value

                ;;

            port | p)

                if ! isNumber "$value"; then
                    echo >&2 Error NaN cannot set customized port to "$value" from "$value"
                    EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                else
                    C_WS_CUSTOMIZED_PORT=$((value))
                    [ $DEBUG -eq 1 ] && echo >&2 Update customized_port from "$C_WS_CUSTOMIZED_PORT to $value"
                fi

                ;;

            http | h)

                case $value in

                    wunderground | w | 1)
                        value=1
                        ;;

                    ecowitt | e | 0)
                        value=0
                        ;;

                    *)  echo >&2 "Error: Unknown value $value for http protocol, use wunderground|w|1 or ecowitt|e|0"
                        EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                esac

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_TYPE from "$C_WS_CUSTOMIZED_HTTP to $value"
                C_WS_CUSTOMIZED_HTTP=$value
                ;;

            enabled | e)

                case $value in

                    on | 1 | yes | y)
                       value=1
                        ;;

                    off | 0 | no | n)
                        value=0
                        ;;

                    *)  echo >&2 "Error: Unknown value $value for enabled, use on|1|yes|y, off|0|no|n"
                        EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                esac

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_enabled from "$C_WS_CUSTOMIZED_ENABLED to $value"
                C_WS_CUSTOMIZED_ENABLED=$value

                ;;

            interval | i)

                if ! isNumber "$value"; then
                    echo >&2 Error NaN cannot set customized interval to "$value"
                    EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                else
                    [ $DEBUG -eq 1 ] && echo >&2 "Update customized_interval from $C_WS_CUSTOMIZED_INTERVAL to $value"
                    C_WS_CUSTOMIZED_INTERVAL=$((value))

                fi

                ;;

            path_wunderground | p_w)

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_path_wu from "$C_WS_CUSTOMIZED_PATH_WU to $value"
                C_WS_CUSTOMIZED_PATH_WU=$value

                ;;

            path_ecowitt | p_e )

                [ $DEBUG -eq 1 ] && echo >&2 Update customized_ecowitt_path from "$C_WS_CUSTOMIZED_PATH_ECOWITT to $value"
                C_WS_CUSTOMIZED_PATH_ECOWITT=$value

                ;;

            help|?|*)
                echo >&2 "Error: Unknown key $key, use id, password|pw, server|s, port|p, http|h, enabled|e, interval|i, path_wunderground|p_w, path_ecowitt|p_e"
                EXITCODE_CUSTOMIZED="$ERROR_CUSTOMIZED"
                ;;
        esac

    done

    #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash

    if [ $EXITCODE_CUSTOMIZED -eq 0 ]; then

        [ $DEBUG -eq 1 ] && printCustomized >&2

        sendCustomized
    fi

    unset key value option

    return $EXITCODE_CUSTOMIZED
}

convertScale10ToFloat() {
    if [ "$SHELL_SUPPORT_FLOATINGPOINT" -eq 1 ]; then
        #shellcheck disable=SC2079
        VALUE_SCALE10_FLOAT=$(( $1 / 10.0 ))
    else
        convertScale10ToFloatInt "$1"
    fi

}

convertScale10ToFloatInt() {
    # $1 - number to convert

    unset VALUE_SCALE10_FLOAT

    if [ -z "$1" ]; then
        echo >&2 Error convertScale10ToFloat empty arg "$1"
        return "$ERROR_CONVERT"
    fi

    number=$(($1))
    if [ "$number" -lt 0 ]; then
        number=$((number * -1))
        sign="-"
    fi

    if [ "$number" -lt 10 ]; then
        VALUE_SCALE10_FLOAT=$sign"0$SHELL_DECIMAL_POINT"$number
    else
        int=$((number / 10))
        frac=$((number - int * 10))
        VALUE_SCALE10_FLOAT=$sign$int$SHELL_DECIMAL_POINT$frac
    fi

    unset int frac number sign
  
}

logErr()
#$1 - 1=on,0=off
{
     [ "$1" -eq 1 ] && { shift; echo >&2 "$*" ; }
}

initnc() 
#different versions of nc use slightly different options
{
    EXITCODE_INITNC=0

    DEBUG_FUNC="initnc"
    DEBUG_NC=${DEBUG_NC:=$DEBUG}
   
   #if force nc version on command line NC_VERSION=? ./gw ...
    if [ -n "$NC_VERSION" ]; then
        
        #specifying override path to nc executable is possible: NC_CMD='/path/nc' ./gw ...
        if [ "$NC_VERSION" = $NC_NMAP ]; then
            [ -z "$NC_CMD" ] && NC_CMD=$(which ncat)
        elif [ "$NC_VERSION" = $NC_OPENBSD ]; then
            [ -z "$NC_CMD" ] && NC_CMD=$(which nc)
        elif [ "$NC_VERSION" = $NC_BUSYBOX ]; then
            [ -z "$NC_CMD" ] && NC_CMD="$(which busybox) nc"
        elif [ "$NC_VERSION" = $NC_TOYBOX ]; then
            [ -z "$NC_CMD" ] && NC_CMD="$(which toybox) nc"
        else
            EXITCODE_INITNC=$ERROR_DEPENDENCY_NC
            return $EXITCODE_INITNC
        fi
       
    else

        NC_CMD="$(which nc 2>/dev/null)"
        if [ -z "$NC_CMD" ]; then
            logErr $DEBUG_NC "$DEBUG_FUNC nc not found. Ubuntu: sudo update-alternatives --config nc"
            EXITCODE_INITNC=$ERROR_DEPENDENCY_NC
        else
            # ls -l $(readlink -f /usr/bin/nc)
            case "$(readlink -f "$NC_CMD" 2>&1)" in 
                
                */nc.openbsd|*/netcat) NC_VERSION=$NC_OPENBSD #nc.openbsd Ubuntu/netcat Fedora
                        logErr $DEBUG_NC "$DEBUG_FUNC nc version openbsd"
                        ;;
                
                */ncat) NC_VERSION=$NC_NMAP 
                        logErr $DEBUG_NC "$DEBUG_FUNC nc version nmap"
                        ;;
                    
                    *)  logErr $DEBUG_NC "$DEBUG_FUNC Warning: Failed to determine nc version, not nc openbsd/ncat, use NC_VERSION=, NM_CMD= to override, trying openbsd compability"
                        NC_VERSION=$NC_OPENBSD
                        ;;
            esac

        fi
    fi
    
    logErr $DEBUG_NC "$DEBUG_FUNC Using nc version $NC_VERSION exec $NC_CMD"
    unset DEBUG_FUNC

    return $EXITCODE_INITNC
}

initConfigDir() {

  #  DIR_CONFIG=$HOME"/.config/gw"                              # .config subdirectory used for configuration on gnome/linux
    
  #  [ -n "$EXTERNAL_STORAGE" ] && DIR_CONFIG=$EXTERNAL_STORAGE # testing in Android 11 adb shell
  #  DIR_LIVEDATA="$EXTERNAL_STORAGE/tmp/gw/livedata"
  #  [ ! -d "$DIR_CONFIG" ] || [ ! -d "$DIR_LIVEDATA" ]  && mkdir -p -v "$DIR_CONFIG" "$DIR_LIVEDATA"   1>&2
  #  [ "$DEBUG" -eq 1 ] &&  echo >&2 Directory config "$DIR_CONFIG" livedata "$DIR_LIVEDATA"

    #SHELLPID=$$
  :
}

argEmptyOrOption() {
    [ "$DEBUG" -eq 1 ] && echo >&2 argEmptyOrOption "$@"
    if [ -z "$1" ]; then
        return 0
    else
        case "$1" in

        -*)
            return 0
            ;;

        *)
            return 1
            ;;
        esac
    fi
}

printCommands() {

    commands="$CMDOPT_RESET reboot mac $CMDOPT_VERSION"

    echo "Commands available -c:"
    
    for cmd in $commands; do
      echo "   $cmd"
    done | sort | uniq 

    unset cmd commands
}

initcoptCommands ()
#-c option commands
{
    CMDOPT_RESET='reset'
    CMDOPT_VERSION='version|ver'
}

writeSensorId()
#$1 - low sensortype, $2 - high sensortype, $3 - sensorid
{

    newPacketBody $CMD_WRITE_SENSOR_ID

    if [ -z "$2" ]; then
     [ "$DEBUG" -eq 1 ] && printf >&2 "Writing sensor type %2d sensorid %x\n" "$1" "$3"
      writeUInt8 "$1"
      writeUInt32BE "$3"
    else
      n="$1"
      while [ "$n" -le "$2" ]; do
        [ "$DEBUG" -eq 1 ] && printf >&2  "Writing sensor type %2d sensorid %x\n" "$n" "$3"
         writeUInt8 "$n"
         writeUInt32BE "$3"
         n=$(( n + 1 ))
      done
    fi

    unset n

    sendPacket
}

parseRangeExpression()
{
    IFS=- # range with hyphen, for example 31-33
            #shellcheck disable=SC2086
    set -- $1
    VALUE_RANGE_LOW=$1 #global for use if 
    VALUE_RANGE_HIGH=$2
}


processSensorOptions()
# process -c sensor command option; format: 31-38=disable,40-47=disable
{
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
       #shellcheck disable=SC3044
       {
        typeset f  sensortypeexpr cmdexpr sentReadSensorIdCommand
        case "$KSH_VERSION" in

          *MIRBSD?KSH*) typeset -iU sensorid sensorid_hex
                        ;;
                    *) typeset sensorid sensorid_hex
                    ;;
        esac
       }  
    fi

    [ "$DEBUG" -eq 1 ] && echo >&2 processSensorOptions "$*"

    sentReadSensorIdCommand=0

     IFS=,

     for f in $1; do #parse , expressions
       IFS='='
       #shellcheck disable=SC2086
       set -- $f #parse = expression -> set to $1 $2 ...
       sensortypeexpr=$1
       cmdexpr=$2

       unset sensorType_low sensorType_high 

        case $sensortypeexpr in
            *-*)    parseRangeExpression "$sensortypeexpr" 
                    sensorType_low=$VALUE_RANGE_LOW
                    sensorType_high=$VALUE_RANGE_HIGH
                    [ "$DEBUG" -eq 1 ] &&  >&2 echo "Sensor type low $sensorType_low sensor type high $sensorType_high"
                    ;;
            all)    sensorType_low=0
                    sensorType_high=$SENSORTYPE_MAX
                    ;;
            *)      sensorType_low=$sensortypeexpr # only a single sensortype
                    ;;
       esac

       #validation

       if [ -z "$sensorType_low" ]; then
          echo >&2 "Error: Empty sensor id low $sensorType_low"
          return "$ERROR_INVALID_SENSORID"
       fi
       
       if [ -n "$sensorType_low" ] && ! isNumber "$sensorType_low" || [ "$sensorType_low" -gt "$SENSORTYPE_MAX" ]; then
          echo >&2 "Error: Not a valid sensor type $sensorType_low, max sensortype $SENSORTYPE_MAX"
          return "$ERROR_INVALID_SENSORID"
       fi
       
       if [ -n "$sensorType_high" ]; then
          if  ! isNumber "$sensorType_high" || [ "$sensorType_high" -gt "$SENSORTYPE_MAX" ]; then
            echo >&2 "Error: Not a valid sensor id $sensorType_high, max sensortype $SENSORTYPE_MAX"
            return "$ERROR_INVALID_SENSORID"
          fi

          if [ "$sensorType_low" -gt "$sensorType_high" ]; then
            echo >&2 "Error: Sensor id low $sensorType_low is greather than sensorid high $sensorType_high"
            return "$ERROR_INVALID_SENSORID"
          fi

       fi

        if [ -n "$sensorType_low" ] && [ -z "$sensorType_high" ]; then #single sensortype
            sensorType_high=$sensorType_low
        fi

        if [ -n "$sensorType_low" ] && [ -n "$sensorType_high" ] && [ -z "$cmdexpr" ]; then #only range without command
            SPATTERNID=$SPATTERNID_RANGE
            SPATTERNID_RANGE_LOW=$sensorType_low
            SPATTERNID_RANGE_HIGH=$sensorType_high
            if [ $sentReadSensorIdCommand -eq 0 ]; then 
                sendPacket $CMD_READ_SENSOR_ID_NEW #only sent for first , expression
                sentReadSensorIdCommand=1
            else # yet another read (for example -c sensor 1-10,40-47) use in-memory buffer backup 
               IFS=" " parsePacket "$OD_BUFFER_BACKUP" 
            fi
            SENSORVIEW_HIDE_HEADER=1 #disabled header for next , expression
            continue
        fi

       sentReadSensorIdCommand=0 #reset for WRITE
       sensorid_hex=0
       
       case $cmdexpr in 

          disable|d|disabled)                   sensorid=$SENSORID_DISABLE
                                                 ;;

          search|s|enable|e|searching|enabled)  sensorid=$SENSORID_SEARCH
                                                 ;;

          '')                                   echo >&2 "Error: Empty command, use sensortype=disable|search|d|s"
                                                return "$ERROR_INVALID_SENSORID_COMMAND"
                                                ;;
          *) 
                                                if ! isHex "$cmdexpr"; then
                                                echo >&2 "Error: Invalid hex number for sensor id $cmdexpr"
                                                return "$ERROR_INVALID_SENSORID_COMMAND"
                                                else
                                                    sensorid_hex=1
                                                    sensorid=$(( 0x$cmdexpr ))
                                                fi
                                                ;;
       esac

        if [ "$sensorid_hex" -eq 1 ] && [ "$sensorType_low" -lt "$sensorType_high" ]; then
            echo >&2 "Error: Cannot set sensortype range to same sensorid $cmdexpr"
            return $ERROR_INVALID_SENSORID
        fi

       writeSensorId "$sensorType_low" "$sensorType_high" "$sensorid"
          
    done

    unset f sensorid sensortypeexpr cmdexpr sensorid_hex
}

convertFloatToScale10()
{
    DEBUG_CONVERT=${DEBUG_CONVERT:=$DEBUG}
    EXITCODE_CONVERTFLOAT_SCALE10=0

    if [ "$SHELL_SUPPORT_FLOATINGPOINT" -eq 1 ]; then
         VALUE_FLOAT_SCALE10=$(( $1 * 10))
         roundFloat "$VALUE_FLOAT_SCALE10"
         VALUE_FLOAT_SCALE10=$VALUE_FLOAT_TO_INT
    else
    
        unset sign

        case "$1" in
            *.*)    int=${1%%.*} # . suffix remove -> integer part
                    case "$int" in
                        -*) sign=-1; int=${int#-}; ;;
                        *) sign=1 ;;
                    esac
                    dec=${1##*.} # prefix . remove -> decimal part
                    if isNumber "$int" && isNumber "$dec"; then
                        dec_suffix=${dec#?} #deletes first digit
                        dec=${dec%%"$dec_suffix"} # no rounding, just cut off
                        VALUE_FLOAT_SCALE10_ABS=$(( $int$dec ))
                        VALUE_FLOAT_SCALE10=$(( sign*$int$dec ))
                    else
                        EXITCODE_CONVERTFLOAT_SCALE10="$ERROR_CONVERT"
                    fi
                    ;;

            *)  int=$1
                case "$int" in
                    -*) sign=-1; int=${int#-} ;;
                    *) sign=1 ;;
                esac
                if isNumber "$int"; then
                        VALUE_FLOAT_SCALE10_ABS=$(( int * 10 )) 
                        VALUE_FLOAT_SCALE10=$(( sign * int * 10 ))
                else
                    EXITCODE_CONVERTFLOAT_SCALE10="$ERROR_CONVERT"
                fi
                ;;
        esac
    fi

    [ $DEBUG_CONVERT -eq 1 ] && echo >&2 "Converting float $1 to $VALUE_FLOAT_SCALE10 (scale 10)" 

    unset int dec dec_suffix sign DEBUG_CONVERT

    return $EXITCODE_CONVERTFLOAT_SCALE10

}

parseRaindataOptions()
#parse options to -c rain command
{
    
    #copy read values
    rainday=$C_RAINDAILY
    rainweek=$C_RAINWEEK
    rainmonth=$C_RAINMONTH
    rainyear=$C_RAINYEAR

    rain_needsupdate=0

    IFS=,
    for rainexpr in $1; do
        IFS='='
        #shellcheck disable=SC2086
        set -- $rainexpr
            case "$1" in
                d|day)   if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainday" ]  &&  { rainday="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                         else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                w|week)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainweek" ]  &&  { rainweek="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                         else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                m|month) if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainmonth" ] &&  { rainmonth="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                         else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                y|year)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10" -le "$CALIBRATION_RAIN_MAX" ] && [ "$VALUE_FLOAT_SCALE10" -ge 0 ]; then
                             [ "$VALUE_FLOAT_SCALE10" -ne "$rainyear" ] &&  { rainyear="$VALUE_FLOAT_SCALE10"; rain_needsupdate=1; }
                        else
                           >&2 echo "Warning: Invalid value for $rainexpr, min/max 0/$CALIBRATION_RAIN_MAX"
                         fi
                            ;;
                *) >&2 echo "Warning: use day|d,week|w,month|m,year|y, for example d=10.0 sets daily rain to 10.0 mm"
                    ;;
            esac
    done

    [ $rain_needsupdate -eq 1 ] &&  sendRaindata "$rainday" "$rainweek" "$rainmonth" "$rainyear"

    unset rainexpr rainday rainweek rainmonth rainyear rain_needsupdate
    
}

processCalibrationOptions()
{
    #DEBUG_CALIBRATION_OPTIONS=1
    DEBUG_CALIBRATION_OPTIONS=${DEBUG_CALIBRATION_OPTIONS:=$DEBUG}

    calibration_intemp=$C_CALIBRATION_INTEMPOFFSET_INT
    calibration_inhumi=$C_CALIBRATION_INHUMIDITYOFFSET
    calibration_outtemp=$C_CALIBRATION_OUTTEMPOFFSET_INT
    calibration_outhumi=$C_CALIBRATION_OUTHUMIDITYOFFSET
    calibration_absoffset=$C_CALIBRATION_ABSOFFSET_INT
    calibration_reloffset=$C_CALIBRATION_RELOFFSET_INT
    calibration_winddir=$C_CALIBRATION_WINDDIROFFSET

    IFS=,
    calibration_need_update=0
    for expr in $1; do
        IFS='='
        #shellcheck disable=SC2086
        set -- $expr
        key=$1
        value=$2
        
        [ $DEBUG_CALIBRATION_OPTIONS -eq 1 ] && echo >&2 "processCalibrationOptions, parsing expr: $expr k: $1, v: $2"

        case "$key" in
        
            it|intemp)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_INTEMPOFFSET_MAX ]; then
                            [ "$calibration_intemp" -ne "$VALUE_FLOAT_SCALE10" ] && { calibration_intemp=$VALUE_FLOAT_SCALE10; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_INTEMPOFFSET_MAX/$CALIBRATION_INTEMPOFFSET_MAX (scale 10)"
                        fi
                        ;;
            
            ih|inhumi) if isNumber "$2" &&  [ "$2" -ge -$CALIBRATION_INHUMIOFFSET_MAX ] && [ "$2" -le $CALIBRATION_INHUMIOFFSET_MAX ] ; then
                            [ "$calibration_inhumi" -ne "$2" ] && { calibration_inhumi=$2; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_INHUMIOFFSET_MAX/$CALIBRATION_INHUMIOFFSET_MAX"
                        fi
                        ;;

            ot|outtemp) if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_OUTTEMPOFFSET_MAX ]; then
                            [ "$calibration_outtemp" -ne "$VALUE_FLOAT_SCALE10" ] && { calibration_outtemp=$VALUE_FLOAT_SCALE10; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_OUTTEMPOFFSET_MAX/$CALIBRATION_OUTTEMPOFFSET_MAX (scale 10)"
                        fi
                        ;;
        
            oh|outhumi)  if isNumber "$2" &&  [ "$2" -ge -$CALIBRATION_OUTHUMIOFFSET_MAX ] && [ "$2" -le $CALIBRATION_OUTHUMIOFFSET_MAX ] ; then
                            [ "$calibration_outhumi" -ne "$2" ] && { calibration_outhumi=$2; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max " "-$CALIBRATION_OUTHUMIOFFSET_MAX/$CALIBRATION_OUTHUMIOFFSET_MAX"
                        fi
                        ;;

            a|absoffset)  if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_ABSOFFSET_MAX ]; then
                             [ "$C_CALIBRATION_ABSOFFSET_INT" -ne "$VALUE_FLOAT_SCALE10" ] && { 
                                 set -x
                                 calibration_absoffset=$VALUE_FLOAT_SCALE10; calibration_need_update=1; 
                                 set +x ; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_ABSOFFSET_MAX/$CALIBRATION_ABSOFFSET_MAX (scale 10)"
                        fi
                        ;;
            
            r|reloffset) if [ -n "$2" ] && convertFloatToScale10 "$2" && [ "$VALUE_FLOAT_SCALE10_ABS" -le $CALIBRATION_RELOFFSET_MAX ]; then

                              [ "$C_CALIBRATION_RELOFFSET_INT" -ne "$VALUE_FLOAT_SCALE10" ] && { calibration_reloffset=$VALUE_FLOAT_SCALE10; calibration_need_update=1; }
                        else
                           echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_RELOFFSET_MAX/$CALIBRATION_RELOFFSET_MAX (scale 10)"
                        fi
                         ;;

            w|winddiroffset) if isNumber "$2" &&  [ "$2" -ge -$CALIBRATION_WINDDIROFFSET_MAX ] && [ "$2" -le $CALIBRATION_WINDDIROFFSET_MAX ] ; then
                               [ "$calibration_winddir" -ne "$2" ] && { calibration_winddir=$2; calibration_need_update=1; }
                            else
                                echo >&2 "Warning: Invalid value for $expr, min/max -$CALIBRATION_WINDDIROFFSET_MAX/$CALIBRATION_WINDDIROFFSET_MAX"
                            fi
                        ;;

            *) echo >&2 "Error: Unknown key $1, use it | intemp, ih | inhumi, ot | outtemp, oh | outhumi, a | absoffset, r | reloffset, w | winddiroffset"
                ;;
        esac

    done

    if [ $calibration_need_update -eq 1 ]; then
       if ! sendCalibration "$calibration_intemp" "$calibration_inhumi" "$calibration_absoffset" "$calibration_reloffset" "$calibration_outtemp" "$calibration_outhumi" "$calibration_winddir"  ; then
          echo >&2 "Error: Failed to send calibration to device $?"
       fi
    fi


    unset expr calibration_intemp calibration_inhumi calibration_outtemp calibration_outhumi calibration_absoffset calibration_reloffset calibration_winddir DEBUG_CALIBRATION_OPTIONS IFS
}

processCommand() {
   EXITCODE_PROCESSCOMMAND=0

   [ "$DEBUG" -eq 1 ] && >&2 echo ARGS to processCommand "$@" length "$#" COMMAND "$COMMAND"

   if [ "$#" -ge 1 ]; then
      shift # remove {command} (to -c option) -> all args to {command} starts at $1
   fi

    case $COMMAND in

        "")
            printCommands
            ;;

         w-s | wifi-server) # method 1 in spec. part 3
            #open tcp 49123 in windows firewall for private network, set GW1000-WIFI???? network as private-network 
            #inside wsl2: setup tcp portproxy (allow external tcp 49123 -> wsl tcp 49123)
            #    iex "netsh interface portproxy add v4tov4 listenaddress=(Get-NetIPAddress -InterfaceAlias Wi-Fi -AddressFamily IPv4).IPAddress connectaddress=$(wsl -e hostname -I) connectport=49123 listenport=49123"
            #windows: netsh wlan connect GW1000-WIFI????

            if [ -z "$1" ]; then
                echo >&2 Error: Empty SSID not allowed
                shift
                EXITCODE_PROCESSCOMMAND=$ERROR_SSID_EMPTY
           else
                createWIFIpacket "$1" "$2"
                createPacketTX
                od_buffer=$(printf %b "$PACKET_TX_ESCAPE" | timeout "$TIMEOUT_WIFICONFIG_SERVER" nc -l "$PORT_WIFICONFIG_SERVER_TCP" | od -A n -t u1 -w$MAX_16BIT_UINT) 
                if parsePacket "$od_buffer"; then
                    [ $VALUE_PACKET_WRITE_RESULT -eq 1 ] && EXITCODE_PROCESSCOMMAND=$ERROR_WIFICONFIG_SERVER_FAILED
                else
                   echo >&2 "Error: No connection received for ${TIMEOUT_WIFICONFIG_SERVER}s on $PORT_WIFICONFIG_SERVER_TCP"
                   EXITCODE_PROCESSCOMMAND=$EXITCODE_PARSEPACKET
                fi
                shift && [ -n "$2" ] && shift
            fi
            ;;


        w-c | wifi-client)

           if [ -z "$2" ]; then
                echo >&2 Error: Empty SSID not allowed
                shift
                EXITCODE_PROCESSCOMMAND=$ERROR_SSID_EMPTY
           else
                createWIFIpacket "$1" "$2"
                if ! sendPacket && [ "$EXITCODE_SENDPACKET" -ne $ERROR_OD_BUFFER_EMPTY ]; then
                    #sometimes OK response from gw is not received -> empty buffer
                    echo >&2 Error: Failed to send wifi configuration to "$C_HOST", error code "$EXITCODE_SENDPACKET"
                    EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
                fi
                shift && [ -n "$2" ] && shift
            fi
            ;;

        "$CMDOPT_RESET")

            if sendPacket $CMD_BROADCAST >/dev/null; then

                printf "%s" "Reset $C_BROADCAST_MAC $C_BROADCAST_SSID (Y/N)? "
                read -r REPLY

                case $REPLY in
                    Y)
                        sendPacket $CMD_WRITE_RESET # 3 blink in red LED
                        ;;
                esac

            else
               echo >&2 Error: Failed to receive broadcast with MAC and SSID
               EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
            fi

            ;;

        reboot)

            sendPacket $CMD_REBOOT
            ;;

        mac)

            sendPacket $CMD_READ_MAC
            ;;

        version|ver)

            sendPacket $CMD_READ_VERSION
            ;;

        system | sys)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_SYSTEM
            else
                C_NOPRINT=1
                sendPacket $CMD_READ_SYSTEM 
                unset C_NOPRINT
                parseSystemOption "$1"
                EXITCODE_PROCESSCOMMAND=$EXITCODE_PARSESYSTEMOPTIONS
            fi
            ;;

        ecowitt | ec | e)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_ECOWITT_INTERVAL
            else
                #sendEcowittInterval "$1"
                sendEcowittIntervalnew "$1"
            fi
            
            ;;

        wunderground | wu)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WUNDERGROUND
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error: {id} {password} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WUNDERGROUND" "$1" "$2"
                fi
            fi

            ;;

        wow)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WOW
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error: {id} {password} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WOW" "$1" "$2"
                fi
            fi
            ;;

        weathercloud | wc)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_WEATHERCLOUD
            else
                if [ $# -lt 2 ]; then
                    echo >&2 "Error: {id} {key} must be specified"
                else
                    sendWeatherservice "$CMD_WRITE_WEATHERCLOUD" "$1" "$2"
                fi
            fi
            ;;

        customized | c | cust)

            if argEmptyOrOption "$1"; then
                if ! sendPacket $CMD_READ_PATH >/dev/null || ! sendPacket $CMD_READ_CUSTOMIZED; then
                  >&2 echo Failed to get customized settings
                fi
            else
                
                if sendPacket $CMD_READ_CUSTOMIZED >/dev/null && sendPacket $CMD_READ_PATH >/dev/null; then
                    if ! updateCustomized "$1"; then
                        EXITCODE_PROCESSCOMMAND=$EXITCODE_CUSTOMIZED
                        #echo >&2 "Error: Failed to update customized settings"
                    fi
                else
                  >&2 echo "Cannot update customized, failed to read customized settings from device"
                fi
            fi

            ;;

       # path | p) # deprecate?

       #    sendPacket $CMD_READ_PATH
       #    ;;

        broadcast | b)
            sendPacket $CMD_BROADCAST
            ;;

        rain | r)

            if argEmptyOrOption "$1"; then
                sendPacket $CMD_READ_RAINDATA
            else
                if sendPacket $CMD_READ_RAINDATA >/dev/null ; then #refresh
                    parseRaindataOptions "$1"
                else
                  echo >&2 Error: Failed to get raindata from "$C_HOST"
                fi
            fi

            ;;

        livedata | l)

            sendPacket "$CMD_READ_SENSOR_ID_NEW" >/dev/null   #get battery and signal info as well

            if [ -z "$LOG_CMD" ]; then
                sendPacket $CMD_LIVEDATA
                EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET
            else
              
                while true; do
                  sendPacket $CMD_LIVEDATA
                  sleep "$LOG_INTERVAL"
                done
            fi

            ;;

        sensor_id)

            sendPacket $CMD_READ_SENSOR_ID
            ;;

        sensor_id_new | sensor | s) # for new SENSOR_TYPE types

            if ! argEmptyOrOption "$1"; then
             #filter for senorid; -c sensor connected|-c s co

                case "$1" in 
                    connected|c)
                                    SPATTERNID=$SPATTERNID_CONNECTED #matches connected sensors
                                    sendPacket $CMD_READ_SENSOR_ID_NEW
                                    ;;
                    disconnected)
                                    SPATTERNID=$SPATTERNID_DISCONNECTED
                                    sendPacket $CMD_READ_SENSOR_ID_NEW
                                    ;;
                    searching|s)
                                    SPATTERNID=$SPATTERNID_SEARCHING
                                    sendPacket $CMD_READ_SENSOR_ID_NEW
                                    ;;
                    disabled|d)
                                    SPATTERNID=$SPATTERNID_DISABLED
                                    sendPacket $CMD_READ_SENSOR_ID_NEW
                                    ;;
                    
                    *) 
                                    processSensorOptions "$1"
                    ;;
                esac

            else
                sendPacket $CMD_READ_SENSOR_ID_NEW
            fi

            ;;

        calibration | cal)
   
            sendPacket $CMD_READ_CALIBRATION

            case "$1" in
                ""|--*|-*) :
                ;;
                
                *) processCalibrationOptions "$1"
                ;;
            esac
            
            ;;

        *)

            echo >&2 "Error: Unknown command $COMMAND $*"
            return "$ERROR_COMMAND_UNKNOWN"
            ;;
    esac

    [ -z "$EXITCODE_PROCESSCOMMAND" ] && EXITCODE_PROCESSCOMMAND=$EXITCODE_SENDPACKET

    return "$EXITCODE_PROCESSCOMMAND"
}

isNumber() {
    #https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash?page=1&tab=votes#tab-top
    isnumber_int=$1
    case "$isnumber_int" in
              -*) isnumber_int=${isnumber_int#-} ;; # remove sign
    esac

    case "$isnumber_int" in
        '' | *[!0-9]* ) return 1 ;;
        *) return 0 ;;
    esac
    unset isnumber_int
   #echo "1: $1"
   #if [ "$1" -ge 0 ] || [ "$1" -lt 0 ]; then #does not work in ksh93
   #  return 0
   #else
   #  return 1
   #fi
}

isHex()
{
    case $1 in 
      '' | *[!0-9a-fA-F]*) return 1 ;;
      *) return 0 ;;
    esac
}

initTerm()
{
    
    #https://stackoverflow.com/questions/1780483/lines-and-columns-environmental-variables-lost-in-a-script
    if [ -n "$COLUMNS" ] && [ -n "$LINES" ]; then
        TERM_COLUMNS=$COLUMNS
        TERM_LINES=$LINES
    elif type stty >/dev/null; then
      size=$(stty size)
      TERM_LINES=${size% *}
      TERM_COLUMNS=${size#* }
    elif type tput >/dev/null; then
       #shellcheck disable=SC2034
       {
       TERM_LINES=$(tput lines)
       TERM_COLUMNS=$(tput cols)
       }
    fi

    unset size

}

test_printf_sformat()
{
    od_unicode=$(printf "%2s" "🔋" | od -A n -t x1)

    if [ "$od_unicode" = " 20 f0 9f 94 8b" ]; then #zsh printf correctly insert a space infront
        SHELL_SUPPORT_PRINTF_UNICODE_SFORMAT=1
        [ "$DEBUG" -eq 1 ] && echo >&2 "Shell support printf unicode right/left adjustment"
    else
        #shellcheck disable=SC2034
        SHELL_SUPPORT_PRINTF_UNICODE_SFORMAT=0
         [ "$DEBUG" -eq 1 ] && echo >&2 "Shell NO SUPPORT for printf unicode right/left adjustment"
    fi

    unset od_unicode
}

initShell() {
    #shellcheck disable=SC3010,SC2050
    eval "if 2>/dev/null 1>/dev/null type '[['  && 2>/dev/null [[ a =~ a ]] ; then
        SHELL_SUPPORT_TILDE_REGEX=1
    else
        SHELL_SUPPORT_TILDE_REGEX=0
    fi"

    #shellcheck disable=SC3044
    if type typeset >/dev/null; then
        export SHELL_SUPPORT_TYPESET=1 # allows function in subprocess/ui-view to access it
    else
        export SHELL_SUPPORT_TYPESET=0
    fi

    if [ -n "$ZSH_VERSION" ]; then
    #https://zsh.sourceforge.io/FAQ/zshfaq03.html
       setopt shwordsplit  #zsh compability for "1 2 3" -> split in 1 2 3
    fi

    if [ -n "$BASH_VERSION" ]; then
        #shellcheck disable=SC3045
        type_res=$(type -t printf) # otherwise language translation
    else
        type_res=$(type printf)
    fi

    case "$type_res" in 
        
        *builtin) #mksh does not have printf bulitin -> printf calls clone a new process -> reduced performance -> prefer echo over printf unless formatting is absolutely required
            
            SHELL_SUPPORT_BULTIN_PRINTF=1 
              #storing value in variable from printf
            #shellcheck disable=SC3045
            if printf -v SHELL_SUPPORT_BULTIN_PRINTF_VOPT "%s" "-v" 1>/dev/null 2>/dev/null && [ "$SHELL_SUPPORT_BULTIN_PRINTF_VOPT" = '-v' ]; then
                SHELL_SUPPORT_BULTIN_PRINTF_VOPT=1
            else
                SHELL_SUPPORT_BULTIN_PRINTF_VOPT=0
            fi
        ;;
        
        *is*)
            #shellcheck disable=SC2034
            SHELL_SUPPORT_BULTIN_PRINTF=0
            ;;
    esac

     test_printf_sformat #only zsh bultin printf works with unicode when using %-30s format -> workaround \r\t\t\t\t positioning instead which works with every shell printf
     
   #shellcheck disable=SC2034,SC3019
  # I=$(( 10 ** 1 )) 2>/dev/null;
  #dash shell exit with: arithmetic expression: expecting primary: " 10 ** 1 "
    
    if [ -n "$BASH_VERSION" ] || [ -n "$ZSH_VERSION" ] || [ "$KSH_VERSION" = "Version AJM 93u+ 2012-08-01" ]; then
      SHELL_SUPPORT_MATH_POWER=1
      [ -z "$BASH_VERSION" ] && SHELL_SUPPORT_FLOATINGPOINT=1 || SHELL_SUPPORT_FLOATINGPOINT=0 #set 0 for bash
    else
      SHELL_SUPPORT_MATH_POWER=0 #probably
      SHELL_SUPPORT_FLOATINGPOINT=0 #probably
    fi
    
    #https://stackoverflow.com/questions/602912/how-do-you-echo-a-4-digit-unicode-character-in-bash/602924#602924

    SHELL_SUPPORT_UNICODE=1 # assume shell supports unicode
   
     [ "$DEBUG" -eq 1 ] && >&2 echo Shell support unicode "$SHELL_SUPPORT_UNICODE"

    #TEST unciode: i=$(( 0x2500 )); while [ "$i" -le $(( 0x2600 )) ]; do printf -v hex "%x" "$i"; eval 'printf "%s \u$hex\n" "$hex"'; i=$(( i + 1 )); done
    
#https://www.gnu.org/software/gettext/manual/html_node/The-TERM-variable.html
#https://www.gnu.org/software/gettext/libtextstyle/manual/html_node/The-NO_005fCOLOR-variable.html
# TEST : msgcat --color=test
    [ "$DEBUG" -eq 1 ] && >&2 echo TERM "$TERM" NO_COLOR "$NO_COLOR"

    if [ -z "$NO_COLOR" ]; then
        case "$TERM" in
            *color)
                    # shellcheck source=./style/ansiesc.sh
                    . "$GW_STYLE_FILE"
                    ;;
        esac
    fi
    
   if ! SHELL_DECIMAL_POINT=$(locale decimal_point) 2>/dev/null; then
      SHELL_DECIMAL_POINT="."
   fi
    
    unset type_res
   
}

printWeatherServices () {
    sendPacket $CMD_READ_ECOWITT_INTERVAL
    sendPacket $CMD_READ_WUNDERGROUND
    sendPacket $CMD_READ_WOW
    sendPacket $CMD_READ_WEATHERCLOUD
    sendPacket $CMD_READ_CUSTOMIZED
}

getFloatAsIntDecmial()
#$1 - floating point number
#get int and decimal porition; int.decimals
#assumes always . present in $1
{
    FLOAT_INT=${1%%.*}
    FLOAT_DECIMALS=${1#*.}
    FLOAT_SCALE10=${#FLOAT_DECIMALS}
    if [ "$FLOAT_INT" = 0 ]; then # we have a number 0.???
      while [ ${#FLOAT_DECIMALS} -gt 1 ]; do # removes leadning zeros, otherwise number is intepreted as  octal
        case "$FLOAT_DECIMALS" in
                0*) FLOAT_DECIMALS=${FLOAT_DECIMALS#0} # removes zeros after .
                    true
                    ;;
                *) break # this while loop
                   false
                   ;;
        esac
      done
      FLOAT_AS_INT=$FLOAT_DECIMALS
    else
      FLOAT_AS_INT=$FLOAT_INT$FLOAT_DECIMALS
    fi

    if [ "$SHELL_SUPPORT_MATH_POWER" -eq 1 ]; then
      #shellcheck disable=SC3019
      CONVERT_10MULTIPLIER=$(( 10 ** FLOAT_SCALE10))
    else
        n=2
        CONVERT_10MULTIPLIER=10
        while [ "$n" -le "$FLOAT_SCALE10" ]; do # power of 10 
            CONVERT_10MULTIPLIER=$(( CONVERT_10MULTIPLIER * 10))
            n=$(( n + 1 ))
        done
    fi

    unset n
}

convert_farenheit_to_celciusScale10()
#tempinf=72.7
#$2 - number of digits after . -> using power to scale value
{
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        # VALUE_CELCIUS_SCALE10=$(printf %.0f "$(echo "($1 - 32 )*50/9" | bc)")
        getFloatAsIntDecmial "$1"
        VALUE_CELCIUS_SCALE10=$(( (FLOAT_AS_INT - 32*CONVERT_10MULTIPLIER) * 500 / (9*CONVERT_10MULTIPLIER) ))
        round "$VALUE_CELCIUS_SCALE10"
        VALUE_CELCIUS_SCALE10=$VALUE_ROUND
    else
        #shellcheck disable=SC2079
        VALUE_CELCIUS_SCALE10=$(( ($1 - 32 )*50/9.0 ))
    fi
    [ "$DEBUG" -eq 1 ] && echo >&2 "Converted $1 farenheit to $VALUE_CELCIUS_SCALE10 celcius - scale 10"

}

convert_celcius_to_farenheitScale10()
{
    # VALUE_CELCIUS_SCALE10=$(printf %.0f "$(echo "($1 - 32 )*50/9" | bc)")
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        getFloatAsIntDecmial "$1"
        VALUE_FARENHEIT_SCALE10=$(( (FLOAT_AS_INT*9/5) + 32*CONVERT_10MULTIPLIER ))
    else
        #shellcheck disable=SC2079
        VALUE_FARENHEIT_SCALE10=$(( ( $1 - 32.0) *50/9 ))
    fi
    [ "$DEBUG" -eq 1 ] && echo >&2 "Converted $1 celcius to $VALUE_FARENHEIT_SCALE10 farenheit - scale 10"

}

convert_celciusScale10_to_farenheitScale10()
{
    if [ "$SHELL_SUPPORT_FLOATINGPOINT" -eq 0 ]; then
        VALUE_FARENHEIT_SCALE10=$(( ($1*9/5) + 320 ))
    else
        #shellcheck disable=SC2079
        VALUE_FARENHEIT_SCALE10=$(( ( $1*9.0/5) + 320 ))
    fi
     [ "$DEBUG" -eq 1 ] && echo >&2 "Converted $1 celcius to $VALUE_FARENHEIT_SCALE10 farenheit - scale 10"

}

convert_inhg_to_hpa()
#convert from inhg to hpa
#baromrelin=29.731 -> 3 decimals -> multiply by 1000 = 29731
#assumes always 3 decimals after .
#some info: http://justinparrtech.com/JustinParr-Tech/programming-tip-turn-floating-point-operations-in-to-integer-operations/
#https://en.wikipedia.org/wiki/Inch_of_mercury
#using: SI unit 1 inHg = 3.38639 kPa
{
       # VALUE_INHG_HPA_SCALE10=$(printf %.0f "$(echo "338.639 * $1" | bc)")

    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then

        getFloatAsIntDecmial "$1"

        case "$KSH_VERSION" in 
                *MIRBSD?KSH*)
                    # maybe use $((# )) for 32-bit usigned int expression
                    VALUE_INHG_HPA_SCALE10=$(( (4233 * FLOAT_AS_INT)/ 1250)) # round conversion constant/scale down 10 -> 338639 -> 338640
                    #factorize 33864=8*4233, 10000=8*1250, $(( (33864 * FLOAT_AS_INT)/ 10000)) -> $(( (4233 * FLOAT_AS_INT)/ 1250))
                    ;;
                *)
                    #does not work with 32-bit unsigned integer arithmetic as used by mksh with $((# ... ))
                    VALUE_INHG_HPA_SCALE10=$(( (338639 * FLOAT_AS_INT) / 100000)) # use interger arithmetic
                    ;;
            esac
        
        round "$VALUE_INHG_HPA_SCALE10"
        VALUE_INHG_HPA_SCALE10=$VALUE_ROUND
    else
        #shellcheck disable=SC2079
        VALUE_INHG_HPA_SCALE10=$(( $1 * 338.639 ))
    fi
    [ "$DEBUG" -eq 1 ] && echo >&2 "Converted $1 inhg to $VALUE_INHG_HPA_SCALE10 hpa - scale 10"
}

convert_hpaScale10_To_inhgScale10()
#using: SI unit 1 inHg = 3.38639 kPa
{
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        round $(( $1 * 100000 / 338639  ))
        VALUE_INHG_SCALE10=$VALUE_ROUND
    else
            #shellcheck disable=SC2079
       VALUE_INHG_SCALE10=$(( $1 * 1/ 33.8639 ))
    fi

    [ "$DEBUG" -eq 1 ] && echo >&2 "Converted $1 hpa to $VALUE_INHG_SCALE10 - scale 10"
}

round()
{

    [ "$DEBUG" -eq 1 ] && >&2 echo "round $1"

    modulo=$(( $1 % 10 ))
    if [ $modulo -ge 5 ]; then
        VALUE_ROUND=$(( $1 + 10 - modulo )) # round up
    else
        VALUE_ROUND=$(( $1 - modulo )) #round down
    fi

   VALUE_ROUND=$(( VALUE_ROUND / 10 ))

    unset modulo
}

convert_mph_To_mps()
# https://www.convertunits.com/from/mph/to/m/s
# 1 mph is equal to 0.44704 meter/second.
# format: speedmph=5.82&windgustmph=10.29&maxdailygust=15.88 -> 2 digits after .
#using International mile: using scaling 63360/141732 
{
   #VALUE_MPS_SCALE10=$(printf %.0f "$(echo "4.4704 * $1" | bc)")

   if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        getFloatAsIntDecmial "$1"
    
        #factorize : 63360 = 18*3520, 141732 = 18* 7874 -> $(( 63360 * FLOAT_AS_INT/ 141732)) -> $(( 3520 * FLOAT_AS_INT / 7874 ))
        #https://www.calculatorsoup.com/calculators/math/factors.php?input=141732&action=solve
    
        round "$(( 3520 * FLOAT_AS_INT / 7874 ))"
        VALUE_MPS_SCALE10=$VALUE_ROUND
    else
        #shellcheck disable=SC2079
        VALUE_MPS_SCALE10=$(( $1 * 4.4704 ))
    fi
    [ $DEBUG -eq 1 ] && echo >&2 "Convert mph $1 to mps $VALUE_MPS_SCALE10 scale 10"

}

convert_mpsScale10_To_kmhScale10()
{
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        round "$(( $1 * 36 ))" # really scale * 100
        VALUE_KMH_SCALE10=$VALUE_ROUND
    else
        #shellcheck disable=SC2079
         VALUE_KMH_SCALE10=$(( $1 * 3.6 ))
    fi
    [ $DEBUG -eq 1 ] && echo >&2 "Convert mps $1 to mph $VALUE_KMH_SCALE10 scale 10"

}

convcert_mpsScale10_to_mphScale10()
{

    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        #factorize:  10000000 = 32*312500, 44704 = 32*1397 $(( 10000000/44704 )) -> $ (( 312500 / 1397))
        round "$(( $1*31250 / 1397))"
        VALUE_MPH_SCALE10=$VALUE_ROUND
    else
        #shellcheck disable=SC2079
        VALUE_MPH_SCALE10=$(( $1 * 3125/ 1397.0 ))
    fi
    [ $DEBUG -eq 1 ] && echo >&2 "Convert mps $1 to mph $VALUE_MPH_SCALE10 scale 10"
}

convert_mph_to_kmhScale10()
#http request: wind is in mph, -u w=kmh to convert
{
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        getFloatAsIntDecmial "$1"     #format: speedmph=5.82 -> 582
        #1mph=1.609344 km/h -> 1609344/1000000 -> largerst factor = 64 -> 64*25146/64*15625 -> 25146/15625
        round "$(( FLOAT_AS_INT * 251467/156250 ))"
        VALUE_KMH_SCALE10=$VALUE_ROUND
    else
        #shellcheck disable=SC2079
        VALUE_KMH_SCALE10=$(( $1 * 16.09344 ))
    fi
    [ $DEBUG -eq 1 ] && echo >&2 "Convert mph $1 to kmh $VALUE_KMH_SCALE10 scale 10"

}

convert_in_to_mm()
#1 inch SI unit = 25.4 mm
#https://en.wikipedia.org/wiki/Inch
# web format: rainratein=0.000&eventrainin=0.669&hourlyrainin=0.000&dailyrainin=0.028&weeklyrainin=0.831&monthlyrainin=0.972&yearlyrainin=17.130&totalrainin=17.130
{
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 0 ]; then
        getFloatAsIntDecmial "$1"

        #factorize 254=2*127, 100=2*50 -> $(( 254 * FLOAT_AS_INT / 100)) -> $(( 127 * FLOAT_AS_INT / 50 ))
        round "$(( 127 * FLOAT_AS_INT / 50))"
        VALUE_IN_MM_SCALE10=$VALUE_ROUND
    else
        VALUE_IN_MM_SCALE10=$(( $1 * 254 ))
    
    fi
    [ $DEBUG -eq 1 ] && echo >&2 "Convert in $1 to mm $VALUE_IN_MM_SCALE10 scale 10"

}

setRainHttpLivedata()
#$1 - field name
#$2 - value
{
    convert_in_to_mm "$2"
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 1 ]; then
        roundFloat "$VALUE_IN_MM_SCALE10"
        VALUE_IN_MM_SCALE10=$VALUE_FLOAT_TO_INT
    fi
    eval export "$1"_RAW="$VALUE_IN_MM_SCALE10"
    if [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_MM ]; then
        convertScale10ToFloat "$VALUE_IN_MM_SCALE10"
        eval export "$1"="$VALUE_SCALE10_FLOAT"
    elif [ "$UNIT_RAIN_MODE" -eq $UNIT_RAIN_IN ]; then
        eval export "$1"="$2"
    fi
}

setWindHttpLivedata()
{
     if [ "$2" = $WUNDERGROUND_UNDEFINED_VALUE ]; then
      return
    fi

    convert_mph_To_mps "$2"
      if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 1 ]; then
        roundFloat "$VALUE_MPS_SCALE10"
        VALUE_MPS_SCALE10=$VALUE_FLOAT_TO_INT
    fi
    eval export "$1_RAW=$VALUE_MPS_SCALE10"
    if [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPS ]; then
       convertScale10ToFloat "$VALUE_MPS_SCALE10"
       eval export "$1"="$VALUE_SCALE10_FLOAT"
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_MPH ]; then
       eval export "$1"="$2"
    elif [ "$UNIT_WIND_MODE" -eq $UNIT_WIND_KMH ]; then
       convert_mph_to_kmhScale10 "$2"
       convertScale10ToFloat "$VALUE_KMH_SCALE10"
       eval export "$1"="$VALUE_SCALE10_FLOAT"
    fi
}

setWindDirHttpLivedata()
{
    if [ "$2" = $WUNDERGROUND_UNDEFINED_VALUE ]; then
      return
    fi
 
    eval export "$1"="$2" 
    convertWindDirectionToCompassDirection "$2"
    eval export "$1"_COMPASS="$VALUE_COMPASS_DIRECTION"

}

roundFloat()
#https://unix.stackexchange.com/questions/89712/how-to-convert-floating-point-number-to-integer
{
    if [ $SHELL_SUPPORT_BULTIN_PRINTF_VOPT -eq 1 ]; then
    #shellcheck disable=SC3045
       printf -v VALUE_FLOAT_TO_INT "%.0f" "$1"
    else
        VALUE_FLOAT_TO_INT=$(printf "%.0f" "$1")
    fi

}

setTemperatureHttpLivedata()
{
    #skip undefined value -9999
    if [ "$2" = $WUNDERGROUND_UNDEFINED_VALUE ]; then
      return
    fi

    convert_farenheit_to_celciusScale10 "$2" 
    if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 1 ]; then
       roundFloat $VALUE_CELCIUS_SCALE10
       VALUE_CELCIUS_SCALE10=$VALUE_FLOAT_TO_INT
    fi
    eval export "$1_RAW=$VALUE_CELCIUS_SCALE10"
    if [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_CELCIUS ]; then
        convertScale10ToFloat "$VALUE_CELCIUS_SCALE10"
        eval export "$1"="$VALUE_SCALE10_FLOAT"
    elif [ "$UNIT_TEMPERATURE_MODE" -eq $UNIT_TEMPERATURE_FARENHEIT ]; then
        eval export "$1"="$2"
    fi
}

setPressureHttpLivedata()
{
    convert_inhg_to_hpa "$2"
     if [ $SHELL_SUPPORT_FLOATINGPOINT -eq 1 ]; then
       roundFloat "$VALUE_INHG_HPA_SCALE10"
       VALUE_INHG_HPA_SCALE10=$VALUE_FLOAT_TO_INT
    fi
    eval export "$1"_RAW="$VALUE_INHG_HPA_SCALE10"
    if [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_HPA ]; then
        convertScale10ToFloat "$VALUE_INHG_HPA_SCALE10"
        eval export "$1"="$VALUE_SCALE10_FLOAT"
    elif [ "$UNIT_PRESSURE_MODE" -eq $UNIT_PRESSURE_INHG ]; then
        eval export "$1"="$2"
    fi
}

copyConfigurationToLivedata()
#copies low-level configuration variables to UI-level variables
{
    copyVersionToLivedata
    copySystemToLivedata
}

printOrLogLivedata()
{
    copyConfigurationToLivedata

    if [ -z "$LOG_CMD" ]; then
       if [ $LIVEDATA_VIEW -eq $LIVEDATA_VIEW_NORMAL ]; then
            printLivedata
       else
          echo >&2 Not implemented liveview $LIVEDATA_VIEW
       fi
    else
      eval "$LOG_CMD" # would allow executing of anything inside 
    # case "$LOG_CMD" in
    #   csv) "$GW_VIEW_CSV_FILE"
    #       ;;
    #    *) echo >&2 Error Valid log formats are: csv
     #esac
    fi
}

parseHttpHeader()
{
    [ $DEBUG -eq 1 ] &&  echo >&2 "parseHttpHeader $1"
    
    IFS=: read -r HTTP_KEY HTTP_VALUE <<EOH
$1
EOH
   #echo "KEY $HTTP_KEY VALUE $HTTP_VALUE"
    case $HTTP_KEY in
        *-*) 
                IFS=-
                #shellcheck disable=SC2086
                set -- $HTTP_KEY
                #echo KEY PART1 "$1" KEY PART2 "$2"
                toLowercase "$1"
                HTTP_KEY_PART1=$LOWERCASE
                toLowercase "$2"
                HTTP_KEY_PART2=$LOWERCASE
                eval "HTTP_HEADER_${HTTP_KEY_PART1}_$HTTP_KEY_PART2=${HTTP_VALUE# }"
                ;;
        *)         
                toLowercase "$HTTP_KEY"
                HTTP_KEY=$LOWERCASE
                eval "HTTP_HEADER_$HTTP_KEY=${HTTP_VALUE# }" # trim 1 leading space
               ;;
    esac

    unset HTTP_KEY HTTP_VALUE
   #IFS=- set -- $HTTP_KEY
}

parseHttpLines()
{
    #http://mywiki.wooledge.org/BashFAQ/001
    N=0
    NBODY=0 #line number to body
    while eval IFS= read -r HTTP_LINE$((N + 1)); do
        N=$(( N + 1 ))
        [ $NBODY -eq 0 ] && eval HTTP_LINE$N="\${HTTP_LINE$N%?}" # remove trailing \r (\n removed by read), do not touch body
        eval "if [ \"\${#HTTP_LINE$N}\" -eq 0 ]; then NBODY=$((N + 1 )); fi" 
      [ $DEBUG -eq 1 ] &&  eval echo >&2 HTTP LINE $N \"\$HTTP_LINE$N\"
    done <<EOF
$1
EOF

     if [ -n "$HTTP_LINE1" ]; then
           #shellcheck disable=SC2034
           IFS=' ' read -r HTTP_METHOD HTTP_URL HTTP_VERSION <<EOL
$HTTP_LINE1
EOL
    fi

    if [ "$NBODY" -gt 2 ]; then
        eval HTTP_BODY="\$HTTP_LINE$NBODY"
        IFS=' '
        for linenr in $(seq -s ' ' 2 $(( NBODY - 2 )) ); do
            eval parseHttpHeader \"\$HTTP_LINE"$linenr"\"
        done
        unset linenr
    fi
}

parseHttpRequestEcowitt()
#$1 - http request message (entire)
{

    parseHttpLines "$1"

    LIVEDATA_SYSTEM_PROTOCOL=$LIVEDATA_PROTOCOL_ECOWITT_HTTP
    LIVEDATA_SYSTEM_PROTOCOL_LONG=$LIVEDATA_PROTOCOL_ECOWITT_HTTP_LONG
    LIVEDATA_SYSTEM_PROTOCOL_VERSION=$HTTP_VERSION
    
    [ "$DEBUG" -eq 1 ] && printf "HTTP BODY\n%s\n" "$HTTP_BODY"
    IFS='&'
    
    for f in $HTTP_BODY; do
        
        [ "$DEBUG" -eq  1 ] && echo >&2 Parsing field "$f" 
        value=${f##*=}  # remove largest prefix pattern
        key=${f%%=*}    # remove largest suffix pattern
        
        case "$key" in

           PASSKEY) ;;

            tempinf)
                   setTemperatureHttpLivedata LIVEDATA_INTEMP "$value" 
                  
                ;;

            tempf)
                    setTemperatureHttpLivedata LIVEDATA_OUTTEMP "$value"
                ;;

            humidityin)

                export LIVEDATA_INHUMI="$value"
                ;;

            humidity)
                
                 export LIVEDATA_OUTHUMI="$value"
                ;;

            baromrelin)
                
                setPressureHttpLivedata LIVEDATA_RELBARO "$value"
                ;;

            baromabsin)

                setPressureHttpLivedata LIVEDATA_ABSBARO "$value"
                    ;;

            temp?f)
            
                channel=${key##temp}
                channel=${channel%f}
                setTemperatureHttpLivedata LIVEDATA_TEMP"$channel" "$value" 
                ;;

            humidity?)

                channel=${key##humidity}
                eval export LIVEDATA_HUMI"$channel"="$value"
                ;;
            
            winddir)

                    setWindDirHttpLivedata LIVEDATA_WINDDIRECTION "$value"
                ;;

            windspeedmph)

                setWindHttpLivedata LIVEDATA_WINDSPEED "$value"
                ;;

            windgustmph)

                setWindHttpLivedata LIVEDATA_WINDGUSTSPEED "$value"
                ;;

            maxdailygust)

                setWindHttpLivedata LIVEDATA_WINDDAILYMAX "$value"
                ;;
        
            rainratein)

                setRainHttpLivedata LIVEDATA_RAINRATE "$value"
                ;;

            eventrainin)

                setRainHttpLivedata LIVEDATA_RAINEVENT "$value"
                ;;

                hourlyrainin)

                setRainHttpLivedata LIVEDATA_RAINHOUR "$value"
                ;;

                dailyrainin)

                setRainHttpLivedata LIVEDATA_RAINDAY "$value"
                ;;

            weeklyrainin)

                setRainHttpLivedata LIVEDATA_RAINWEEK "$value"
                ;;

            monthlyrainin)
                
                setRainHttpLivedata LIVEDATA_RAINMONTH "$value"
                ;;

            yearlyrainin)

                setRainHttpLivedata LIVEDATA_RAINYEAR "$value"
                ;;

            totalrainin)

               setRainHttpLivedata LIVEDATA_RAINTOTAL "$value"
               ;;

            soilmoisture?)

                channel=${key##soilmoisture}
                eval export LIVEDATA_SOILMOISTURE"$channel"="$value"
            ;;

            pm25_ch?)

                channel=${key##pm25_ch}
                eval export "LIVEDATA_PM25$channel=$value"
                eval export "LIVEDATA_PM25${channel}_RAW=${value%%.?}${value##*.}"
                ;;

            pm25_avg_24h_ch?)

                channel=${key##pm25_avg_24h_ch}
                eval export "LIVEDATA_PM25_24HAVG$channel=$value"
                eval export "LIVEDATA_PM25_24HAVG${channel}_RAW=${value%%.?}${value##*.}"

                ;;

            leak_ch?)

                channel=${key##leak_ch}
                eval "export LIVEDATA_LEAK$channel=$value"
                ;;

            solarradiation)
            
                   export LIVEDATA_UV="$value"
                ;;

            uv)
                    export LIVEDATA_UVI="$value"
                ;;


            wh65batt)

                getBatteryLowOrNormal "$value"
                export LIVEDATA_WH65_BATTERY="$value"
                export LIVEDATA_WH65_BATTERY_STATE="$SBATTERY_STATE"
                ;;

            batt?)

                channel=${key##batt}
                getBatteryLowOrNormal "$value"
                eval "export LIVEDATA_TEMP${channel}_BATTERY=$value"
                eval "export LIVEDATA_TEMP${channel}_BATTERY_STATE=$SBATTERY_STATE"
                ;;

            pm25batt?)
            
                channel=${key##pm25batt}
                getBatteryLevelState "$value"
                eval "export LIVEDATA_PM25${channel}_BATTERY=$value"
                eval "export LIVEDATA_PM25${channel}_BATTERY_STATE=$SBATTERY_STATE"
                ;;

            soilbatt?)

                channel=${key##soilbatt}
                getFloatAsIntDecmial "$value"
                getBatteryVoltageLevelState "$FLOAT_AS_INT"
                
                eval "export LIVEDATA_SOILMOISTURE${channel}_BATTERY_RAW=$FLOAT_AS_INT"  
                eval "export LIVEDATA_SOILMOISTURE${channel}_BATTERY=$value"
                eval "export LIVEDATA_SOILMOISTURE${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""  
                ;;

            leakbatt?)
                
                channel=${key##leakbatt}
                getBatteryLevelState "$value"
                eval "export LIVEDATA_LEAK${channel}_BATTERY=$value"
                eval "export LIVEDATA_LEAK${channel}_BATTERY_STATE=\"$SBATTERY_STATE\""
                ;;

            stationtype)

                export LIVEDATA_SYSTEM_VERSION="$value"
                ;;

            dateutc)
            
                IFS=+
                #shellcheck disable=SC2086
                set -- $value
                
                export LIVEDATA_SYSTEM_UTC="$1 $2"
                ;;

            freq)

                IFS="M"
                #shellcheck disable=SC2086
                set -- $value
                export LIVEDATA_SYSTEM_FREQUENCY="$1"
                ;;

            model)
               export LIVEDATA_SYSTEM_MODEL="$value"
               ;; 

            *) echo >&2 "Warning: Unsupported key $key length ${#key} in ecowitt http request"
               [ "$DEBUG" -eq 1 ] && printf >&2 "%s" "$key" | od -A n -t x1
               ;;
                
        esac
    done

    printOrLogLivedata

    unset f key value
}

parseHttpRequestWunderground()
{
   parseHttpLines "$1"

   LIVEDATA_SYSTEM_PROTOCOL=$LIVEDATA_PROTOCOL_WUNDERGROUND_HTTP
   #shellcheck disable=SC2034
   {
   LIVEDATA_SYSTEM_PROTOCOL_LONG=$LIVEDATA_PROTOCOL_WUNDERGROUND_HTTP_LONG
   LIVEDATA_SYSTEM_PROTOCOL_VERSION=$HTTP_VERSION
   }
      #https://www.w3.org/Protocols/HTTP/1.0/spec.html#Request

    #http_request=$(echo "$1" | head -n 1)
    #[ "$DEBUG" -eq 1 ] && printf "HTTP REQUEST\n%s\n" "$http_request"

   # http_request=${http_request##GET*ID=} # remove method GET and directory prefix, assume qs always starts with ID=
   # LIVEDATA_SYSTEM_PROTOCOL_VERSION=${http_request##*rtfreq=? } #assumes request always ends with rtfreq=
   # http_request=${http_request%% HTTP*} # remove HTTP/1.0 at end
    #http_request="ID="$http_request

    IFS='&'
    #for f in $http_request; do
    for f in ${HTTP_URL#*\?}; do #\? remove everything in front up to ?-> start at ID=

        [ "$DEBUG" -eq  1 ] && echo >&2 Parsing field "$f" 

        value=${f##*=}
        key=${f%%=*}
    
            #password is url encoded, for example space=%20 https://stackoverflow.com/questions/6250698/how-to-decode-url-encoded-string-in-shell
        #TEST echo "$key=$value"

    #https://support.weather.com/s/article/PWS-Upload-Protocol?language=en_US
        case "$key" in

            PASSWORD | ID)
              ;;

            tempf)
                
                setTemperatureHttpLivedata LIVEDATA_OUTTEMP "$value"
                ;;

            dewptf)
               setTemperatureHttpLivedata LIVEDATA_DEWPOINT "$value"
               ;;
            
            windchillf)
              setTemperatureHttpLivedata LIVEDATA_WINDCHILL "$value"
              ;;
            
            humidity)
                if [ "$value" != $WUNDERGROUND_UNDEFINED_VALUE ]; then
                  export LIVEDATA_OUTHUMI="$value"
                fi
                ;;

            indoortempf)

                setTemperatureHttpLivedata LIVEDATA_INTEMP "$value"
                ;;
            
            indoorhumidity)

                export LIVEDATA_INHUMI="$value"
                ;;
            
            baromin)
                
                setPressureHttpLivedata LIVEDATA_RELBARO "$value"
                ;;

            absbaromin)
               setPressureHttpLivedata LIVEDATA_ABSBARO "$value"
               ;;

            rainin)
                #or pr hour?
                setRainHttpLivedata LIVEDATA_RAINRATE "$value"
                ;;

            dailyrainin)

                setRainHttpLivedata LIVEDATA_RAINDAY "$value"
                ;;

            weeklyrainin)

                setRainHttpLivedata LIVEDATA_RAINWEEK "$value"
                ;;

            monthlyrainin)

                setRainHttpLivedata LIVEDATA_RAINMONTH "$value"
                ;;

            yearlyrainin)

                setRainHttpLivedata LIVEDATA_RAINYEAR "$value"
                ;;

            winddir)

                setWindDirHttpLivedata LIVEDATA_WINDDIRECTION "$value"

                ;;

            windspeedmph)

                setWindHttpLivedata LIVEDATA_WINDSPEED "$value"
                ;;

            windgustmph)

                setWindHttpLivedata LIVEDATA_WINDGUSTSPEED "$value"
                ;;

            solarradiation)
                
                 if [ "$value" != $WUNDERGROUND_UNDEFINED_VALUE ]; then
                   export LIVEDATA_UV="$value"
                fi
                ;;

            UV)
               
                 if [ "$value" != $WUNDERGROUND_UNDEFINED_VALUE ]; then
                     export LIVEDATA_UVI="$value"
                 fi
                ;;

            AqPM2\.5)
                #shellcheck disable=SC2034
                export LIVEDATA_PM251="$value"
                export LIVEDATA_PM251_RAW="${value%%.?}${value##*.}"
                ;;

            soilmoisture)
                #shellcheck disable=SC2034
                export LIVEDATA_SOILMOISTURE1="$value"
                ;;

            soilmoisture?)

                channel=${key##soilmoisture}
                eval export LIVEDATA_SOILMOISTURE"$channel"="$value"
                ;;

            softwaretype)

               export LIVEDATA_SYSTEM_VERSION="$value"
               ;;

            lowbatt|action|realtime|rtfreq)
               : # silently discard, dateutc=now with EasyWeather fw 1.6.0
               ;;

            dateutc)
               #Easyweather fw 1.6.1
               #format 2021-12-16%2008:52:24
               case "$value" in
                    [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]%20[0-9][0-9]:[0-9][0-9]:[0-9][0-9])
                        export LIVEDATA_SYSTEM_UTC="${value%\%20*} ${value#*%20}"
                        ;;
               esac
               ;;

            *) echo >&2 "Warning: Unsupported $key length ${#key} in wunderground http request"
               ;;

        esac
    done

    printOrLogLivedata

    unset http_request f key value
}

httpServer()
#$1 - port number 
{
    EXITCODE_HTTPSERVER=0

    [ "$DEBUG" -eq 1 ] && >&2 echo Listening on port "$1"

    if [ $NC_VERSION = $NC_NMAP ]; then 
        http_message=$("$NC_CMD" -l -i 0.1 "$1" 2>/dev/null) # - idle timeout to exit early, not waiting for client to close/FIN
        EXITCODE_HTTPSERVER=$? 
        if [ "$EXITCODE_HTTPSERVER" -eq 2 ]; then
          EXITCODE_HTTPSERVER=0 # 2 exit from nc when idle timeout expires (Ncat: Idle timeout expired (100 ms). QUITTING.)
        fi
    elif [ $NC_VERSION = $NC_OPENBSD ]; then
        http_message=$("$NC_CMD" -l -w 1 "$1" 2>/dev/null) # - -w to exit on idle for 1s
        EXITCODE_HTTPSERVER=$?
    elif [ $NC_VERSION = $NC_TOYBOX ]; then 
        http_message=$("$NC_CMD" -p "$1" -W 1 -l  2>/dev/null) # - -W to exit on idle for 1s
        EXITCODE_HTTPSERVER=$?
    else
        echo >&2 Error: Listen unsupported for nc version "$NC_VERSION"
        EXITCODE_HTTPSERVER=$ERROR_LISTEN_UNSUPPORTED_NC
    fi

    if [ -z "$http_message" ]; then
        [ "$DEBUG" -eq 1 ] && echo >&2 Empty http message from nc
        return $ERROR_HTTP_MESSSAGE_EMPTY
    fi

    if [ -n "$DEBUG_OPTION_HTTP" ]; then
        if  [ "$DEBUG_OPTION_HTTP" -eq 1  ] ; then
            echo >&2 "$http_message"
        fi
    fi
    
    case "$http_message" in
        
        POST*tempinf*)  parseHttpRequestEcowitt "$http_message"
                
                #https://stackoverflow.com/a/69836872/2076536
                ;;
        
        GET*tempf*)   parseHttpRequestWunderground "$http_message"
                #cd /tmp/gw/wunderground; watch -n 16 'for f in *; do read v < "$f"; printf "%-30s %s\n" "$f" "$v"; done'
                ;;
        *) echo >&2 Error: Unable to parse "$http_message" #maybe add csv/json response on request?
           ;;
    esac

    unset http_message
    
    return $EXITCODE_HTTPSERVER
}

cleanup()
{
    :
#   exit
}

initTrap()
{
    :
   #some info here: https://unix.stackexchange.com/questions/57940/trap-int-term-exit-really-necessary
   # trap cleanup INT TERM #ctrl-c pressed by user, or TERM sent default by kill when script in background doing livedata logging 
}

#read -r -u 0 -t 0 STDIN

#if [ -n "$STDIN" ]; then
#  echo STDIN "$STDIN"
:
#maybe parse packet if gw used as filter echo hex dump | gw

#fi

initUnit()
{
    if [ -z "$UNIT_TEMPERATURE_MODE" ]; then 
        setTemperatureMode $UNIT_TEMPERATURE_CELCIUS # default
    else
        setTemperatureMode "$UNIT_TEMPERATURE_MODE"
    fi

    if [ -z "$UNIT_PRESSURE_MODE" ]; then
        setPressureMode $UNIT_PRESSURE_HPA # default
    else
        setPressureMode "$UNIT_PRESSURE_MODE"
    fi

    if [ -z "$UNIT_RAIN_MODE" ]; then 
        setRainMode $UNIT_RAIN_MM #default
    else
        setRainMode "$UNIT_RAIN_MODE"
    fi
    
    if [ -z "$UNIT_WIND_MODE" ]; then 
        setWindMode $UNIT_WIND_MPS #default
    else
        setWindMode "$UNIT_WIND_MODE"
    fi

    if [ $SHELL_SUPPORT_UNICODE -eq 1 ]; then
        UNIT_LIGHT="㏓"
    else
        UNIT_LIGHT="lux"
    fi 
    
    if [ $SHELL_SUPPORT_UNICODE -eq 1 ]; then
        UNIT_PM25="µg/㎥"
    else
        UNIT_PM25="µg/m3"
    fi

    UNIT_CO2="ppm"
    UNIT_HUMIDITY="%"

    if [ $SHELL_SUPPORT_UNICODE -eq 1 ]; then
        UNIT_DEGREE="°"
    else
        UNIT_DEGREE="deg"
    fi

}

initWinddirectionCompass()
{
    WIND_DIRECTION_NNE="$WIND_DIRECTION_N$WIND_DIRECTION_N$WIND_DIRECTION_E"
        WIND_DIRECTION_NE="$WIND_DIRECTION_N$WIND_DIRECTION_E"
    WIND_DIRECTION_ENE="$WIND_DIRECTION_E$WIND_DIRECTION_N$WIND_DIRECTION_E"
    WIND_DIRECTION_ESE="$WIND_DIRECTION_E$WIND_DIRECTION_S$WIND_DIRECTION_E"
        WIND_DIRECTION_SE="$WIND_DIRECTION_S$WIND_DIRECTION_E"
    WIND_DIRECTION_SSE="$WIND_DIRECTION_S$WIND_DIRECTION_S$WIND_DIRECTION_E"
    WIND_DIRECTION_SSW="$WIND_DIRECTION_S$WIND_DIRECTION_S$WIND_DIRECTION_W"
        WIND_DIRECTION_SW="$WIND_DIRECTION_S$WIND_DIRECTION_W"
    WIND_DIRECTION_WSW="$WIND_DIRECTION_W$WIND_DIRECTION_S$WIND_DIRECTION_W"
    WIND_DIRECTION_WNW="$WIND_DIRECTION_W$WIND_DIRECTION_N$WIND_DIRECTION_W"
        WIND_DIRECTION_NW="$WIND_DIRECTION_N$WIND_DIRECTION_W"
    WIND_DIRECTION_NNW="$WIND_DIRECTION_N$WIND_DIRECTION_N$WIND_DIRECTION_W"
}

processUnitOptions()
#format: temp=farenheit|celius,pressure=inhg|hpa
{
    IFS=,
    for f in $1; do
        IFS='='
        #shellcheck disable=SC2086
        set -- $f
        case "$1" in
            temperature|t) case "$2" in 

                                celcius|c)    setTemperatureMode $UNIT_TEMPERATURE_CELCIUS 
                                                ;;
                                farenheit|f)   setTemperatureMode $UNIT_TEMPERATURE_FARENHEIT 
                                                ;;
                                *)             echo >&2 Warning: Unknown temperature mode "$2", use "celcius|c, farenheit|f" 
                                                ;;
                                esac
                                ;;

            pressure|p)     case "$2" in
                                inhg|i)     setPressureMode $UNIT_PRESSURE_INHG 
                                            ;;
                                hpa|h)      setPressureMode $UNIT_PRESSURE_HPA 
                                            ;;
                                *)          echo >&2 Warning: Unknown pressure mode "$2", use "inhg|i, hpa|h" 
                                            ;;
                            esac
                            ;;

             wind|w)     case "$2" in
                                mph|h)     setWindMode $UNIT_WIND_MPH 
                                            ;;
                                mps|s)      setWindMode $UNIT_WIND_MPS 
                                            ;;
                                kmh|k)      setWindMode $UNIT_WIND_KMH
                                            ;;
                                *)          echo >&2 Warning: Unknown wind mode "$2", use "mph|h, mps|s, kmh|k" 
                                            ;;
                            esac
                            ;;

            rain|r)     case "$2" in
                                mm)         setRainMode $UNIT_RAIN_MM
                                            ;;
                                in)         setRainMode $UNIT_RAIN_IN
                                            ;;
                                *)          echo >&2 Warning: Unknown rain mode "$2", use "mm|in" 
                                            ;;
                        esac
                        ;;
                    
                    *)      echo >&2 Warning: Unknown mode "$1", use "temperature|t, pressure|p, wind|w, rain|r" 
                            ;;
        esac
    done

    unset f
}

createWIFIpacket()
#$1 SSID, $2 password
{
    [ $DEBUG -eq 1 ] && echo >&2 "createWIFIpacket SSID $1 Password $2"
    newPacketBody $CMD_WRITE_SSID
    #ssid packet has two byte length
    # TEST wsview android app, wireshark: ffff | 11 |001b| 
    #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/ConfigrouterFragment.java - SaveData
    writeString "$1" # ssid
    writeString "$2" # password
}

processDebugOptions()
#allows setting multiple options; for examplel -d buffer,command
{
    IFS=,
    for opt in $1; do 

       [ "$DEBUG" -eq 1 ] && echo  >&2 "Processing debug option $opt"
    
        case "$opt" in
        
            ""|--*|-*)  DEBUG=1
                        ;;
            t|trace)    DEBUG_OPTION_TRACEPACKET=1 # trace tx/rx packets in hex format during sendpacketnc
                        ;;
            a|append)   DEBUG_OPTION_APPEND=1 # print append format/args - default livedata view/table layout
                        ;;
            b|buffer)   DEBUG_OPTION_OD_BUFFER=1 # show hex buffers of transmitted/received data
                        ;;
            c|command)  DEBUG_OPTION_COMMAND=1 #echo command printf/nc/od pipeline
                        ;;
            h|http)     DEBUG_OPTION_HTTP=1 #show http request when listening 
                        ;;
            s|sensor)   DEBUG_OPTION_TESTSENSOR=1 # inject test sensor data
                        . $GWDIR/lib/testsensor.sh
                        ;;
            #STYLING
            w|beufort|wind) IFS=" " 
                        printf >&2 "\nBeufort scale styling\n\n"
                        for f in $(seq -s ' ' 0 12); do 
                                eval >&2 printf \""%2d \$STYLE_BEUFORT_$f%s\$STYLE_RESET %4d\\\n"\"  \""$f"\" \"\$BEUFORT_"${f}"_DESCRIPTION\" \"\$BEUFORT_"${f}"\"
                        done
                        unset f
                        ;;
                pm25) IFS=" "
                        printf >&2 "\nPM25 Air Quality Index styling\n\n"
                        for pm25 in $(( PM25_AQI_GOOD_LIMIT -1)) $((  PM25_AQI_MODERATE_LIMIT - 1)) $((  PM25_AQI_UNHEALTHY_SENSITIVE_LIMIT - 1)) $((  PM25_AQI_UNHEALTHY_LIMIT - 1)) $((  PM25_AQI_VERY_UNHEALTHY_LIMIT - 1)) $((  PM25_AQI_VERY_UNHEALTHY_LIMIT + 1)) ; do
                            setAQI $pm25
                            setStyleAQI $pm25
                            printf >&2 "$STYLE_AQI%s$STYLE_RESET %s\n" "$VALUE_PM25_AQI" "$(( pm25 + 1))"
                        done
                        unset pm25
                        ;;

            ri|rainintensity) IFS=" "
                        printf >&2 "\nRainintensity styling\n\n"
                        for ri in $(( RAININTENSITY_LIGHT_LIMIT -1)) $(( RAININTENSITY_LIGHT_LIMIT + 1)) $((RAININTENSITY_MODERATE_LIMIT + 1)) $((RAININTENSITY_HEAVY_LIMIT + 1)); do
                            setRainIntensity $ri
                            setStyleRainIntensity $ri
                            printf >&2 "$STYLE_RAININTENSITY%s$STYLE_RESET %d\n" "$VALUE_RAININTENSITY" "$(( ri + 1))"
                        done
                        unset ri
                        ;;
            uvi) IFS=" " 
                      printf >&2 "\nUVI styling\n\n"
                      for uvi in $(seq -s ' ' 0 11); do 
                          setStyleUVI "$uvi"
                          printf >&2 "$STYLE_UVI%2d$STYLE_RESET\n" "$uvi"
                      done
                      unset uvi
                      ;;
                    *)  echo >&2 "Error: Unknown debug option $opt, use append | a, buffer | b, command | c, http | h, sensor | s, t | trace"
                        echo >&2  "Styling: beufort | wind, pm25, rainintensity | ri, uvi"
                        ;;
        esac
    done
    unset opt 
}

processOptionsLiveview()
{
     #default is show all information gathered, these options allows to filter output/turn off display of sensors

    IFS=,

    for hide_liveview in $1; do 

        case "$hide_liveview" in

            uvi)
                LIVEVIEW_HIDE_UVI=1
                ;;

            pm25aqi)
                #shellcheck disable=SC2034
                LIVEVIEW_HIDE_PM25AQI=1 #hides PM 2.5 AQI  styling/description
                ;;

            b|beufort)
                LIVEVIEW_HIDE_BEUFORT=1 # hides beufort styling and description
                ;;

            status) #battery/signal status unicode icons
                LIVEVIEW_HIDE_STATUSLINE=1
                ;;

            c | compass)
                LIVEVIEW_HIDE_COMPASS=1
                ;;

            sh | sensor-header)
                SENSORVIEW_HIDE_HEADER=1
                ;;

            h | headers)
                LIVEVIEW_HIDE_HEADERS=1
                ;;

            # b | battery)
            #    HIDE_BATTERY_LIVEDATA=1
                #  ;;
                
            s | system)
                LIVEVIEW_HIDE_SYSTEM=1
                ;;

            r | rain)
                LIVEVIEW_HIDE_RAIN=1
                ;;

            l | light)
                LIVEVIEW_HIDE_LIGHT=1
                ;;
                
            t | temperature | temp)
                LIVEVIEW_HIDE_TEMP=1
                ;;

            w | wind)
                LIVEVIEW_HIDE_WIND=1
                ;;

            sm | soilmoisture | soilm)
                LIVEVIEW_HIDE_SOILMOISTURE=1
                ;;

            st | soiltemperature | soilt)
                LIVEVIEW_HIDE_SOILTEMPERATURE=1
                ;;

            leak)
                LIVEVIEW_HIDE_LEAK=1
                ;;

            tusr | tempusr)
                LIVEVIEW_HIDE_TEMPUSR=1
                ;;

            pm25)
                LIVEVIEW_HIDE_PM25=1
                ;;

            co2)
                LIVEVIEW_HIDE_CO2=1
                ;;

            leafw | leafwetness)
                LIVEVIEW_HIDE_LEAFWETNESS=1
                ;;

            lightning)
                LIVEVIEW_HIDE_LIGHTNING=1
                ;;

            *) echo >&2 "Warning: Unknown hide_liveview option $hide_liveview; use sensor-header | sh, headers | h, rain | r, wind | w,temperature | t,light | l, system | s, soilmoisture | sm, soiltemperature | st, leak, co2, pm25, leafwetness | leafw, lightning, tempusr | tusr, compass | c, status, beufort | b, pm25aqi, uvi"
                ;;
            esac
    done

    unset hide_liveview

}

initShell
initTerm
initcoptCommands
initConfigDir
initTrap
if ! initnc; then
    exit
fi

. $GWDIR/lib/timezone.sh
initTimezones
initUnit
initWinddirectionCompass

#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
#useful CLI info: https://clig.dev/#arguments-and-flags

while [ $# -gt 0 ]; do

    EXITCODE_MAIN=0

    KEY="$1"

    case $KEY in

       -v | --view) IFS=,
                    for liveview in $2; do
                       case "$liveview" in
                         
                           t | terse) LIVEDATA_VIEW=$LIVEDATA_VIEW_TERSE
                                    ;;
                            *) >&2 echo "Warning: Unknown livedata view $liveview, use terse|t"
                            ;;
                        esac
                    done
                    [ -n "$2" ] && shift
                    shift
                    unset liveview
                    ;;

       -A | --lang)

           if [ -n "$2" ] && [ -s "$2" ]; then
              #shellcheck disable=SC1090
              . "$2"
               initUnit # update UNIT_HOUR
               initWinddirectionCompass
           else
              echo >&2 Warning: language file not found "$2"
           fi

           shift 2
           ;;

       -H | --hide-liveview)

            processOptionsLiveview "$2"
            
            [ -n "$2" ] && shift
            shift

            ;;

      -n   | --log-interval)

            if ! argEmptyOrOption "$2"; then
                LOG_INTERVAL="$2"
                shift 2
            else
                shift
            fi
          
            [ "$DEBUG" -eq 1 ] &&  echo >&2 Logging each "$LOG_INTERVAL" seconds
            ;;

       -L  | --log)
          
           if ! argEmptyOrOption "$2"; then
               LOG_CMD="$2"
              shift 2
            else
              shift
            fi
          ;;
      
        -W | --show-ws)
            
            printWeatherServices
            shift
            ;;

        -c | --command)

            toLowercase "$2"
            COMMAND=$LOWERCASE

            shift 1 # remove -c

            processCommand "$@"
            EXITCODE_MAIN=$?

            for param in "$@"; do #remove params to command (until new - option)

                case "$param" in

                -*)
                    break
                    ;;

                *)
                    [ $DEBUG -eq 1 ] && echo >&2 Shift param "$@" "$param"
                    shift
                    ;;
                esac

            done

            unset COMMAND param
            ;;
        
        -u | --unit)
               
               if argEmptyOrOption "$2"; then
                 echo >&2 "Warning: no arguments specified for unit, for example temp=farenheit|celcius"
                 shift # ignore
               else
                 processUnitOptions "$2"
                 shift 2 
               fi
              ;;

        -d | --debug)

              processDebugOptions "$2"
              case "$2"  in
                    ""|--*|-*)  shift       # -d only
                                ;;
                            *)  shift 2     # -d options
                                ;;
              esac
              
            ;;

        -f | --firmware)
            HTTP_UA="gw"
            [ -n "$BASH_VERSION" ] && HTTP_UA="$HTTP_UA bash $BASH_VERSION"
            [ -n "$ZSH_VERSION" ] && HTTP_UA="$HTTP_UA zsh $ZSH_VERSION"
            [ -n "$KSH_VERSION" ] && HTTP_UA="$HTTP_UA ksh $KSH_VERSION"
            HTTP_UA="$HTTP_UA nc $NC_VERSION $(uname -srv)"
            HTTP_REQ_HOST="download.ecowitt.net"
            HTTP_REQ_PATH="/down/filewave?v=FirwaveReadme.txt"
            #HTTP_FIRMWARE_URL="http://$HTTP_REQ_HOST$HTTP_REQ_PATH"
            #curl --silent --show-error --user-agent "$HTTP_UA" "$HTTP_FIRMWARE_URL"
            { printf "GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\nConnection:close\r\n\r\n"  "$HTTP_REQ_PATH" "$HTTP_REQ_HOST" "$HTTP_UA"; sleep 2; } | "$NC_CMD" "$HTTP_REQ_HOST" 80
            shift 
            ;;

        -g | --gw)

            C_HOST="$2"
            #sendPacket "$CMD_READ_MAC" >/dev/null
            sendPacket "$CMD_READ_VERSION" >/dev/null; 
            sendPacket "$CMD_READ_SYSTEM" >/dev/null;  # find sensor type WH65/WH24 - &> redirect stderr+stdout - read_system not available on EasyWeather
            #sendPacket "$CMD_READ_SENSOR_ID_NEW" >/dev/null

            shift 2
            ;;

        -l | --listen)
            #WSL2
            #open TCP 8080 in windows firewall -> add rule to open
            #add portproxy from hostos to WSL2 distro/ubuntu
            #netsh interface portproxy add v4tov4 listenport=8080 listenaddress=192.168.3.3 connectaddress=172.22.134.109 connectport=8080
            # iex "netsh interface portproxy add v4tov4 listenport=8080 listenaddress=(Get-NetIPAddress -InterfaceAlias Wi-Fi -AddressFamily IPv4).IPAddress connectaddress=$(wsl -e hostname -I) connectport=8080"
            # iex = invoke-expression cmdlet
            #https://github.com/microsoft/WSL/issues/4150#issuecomment-504209723
            
            # Wunderground
            #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
            # Ecowitt
            #PASSKEY=976D09F15C.....................7&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro

            if argEmptyOrOption "$2"; then
                >&2 echo No port specified for listen
                EXITCODE_MAIN=$ERROR_LISTEN_NOPORT
                shift 
                continue #process next option
            elif ! isNumber "$2"; then
               >&2 echo Not a valid port number
               EXITCODE_MAIN=$ERROR_LISTEN_INVALID_PORTNUMBER
               shift; continue
            fi

            setUVMode $UNIT_UV_WATTM2

            if [ -z "$LOG_CMD" ]; then
               httpServer "$2"
               EXITCODE_MAIN=$?
            else
               while true; do
                  if ! httpServer "$2"; then
                    EXITCODE_MAIN=$?
                    break
                  fi
                done
            fi 

            shift 2
            ;;
   
        -s | --scan)

            if argEmptyOrOption "$2"; then
                discovery
                shift 1
            else
                discovery "$2"
                shift 2
            fi
            
            EXITCODE_MAIN=$EXITCODE_DISCOVERY

            ;;

        *)        # unknown option
            shift # past argument
            ;;
    esac

done

#typeset +f - list all function names/ksh93
#set # list all variables

[ "$DEBUG" -eq 1 ] && echo >&2 Exit code $EXITCODE_MAIN

exit $EXITCODE_MAIN
