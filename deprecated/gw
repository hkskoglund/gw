#including checksum byte
 sendPacketdd () {
  #takes two arguments $1 - command, $2 is udp broadcast request
  typeset FD
  FD=$FD_TCP # default TCP command port

  [ -n "$2" ] && FD="$2" #may also use UDP for broadcast (ssid etc.)
  if [ ! -v FD ]; then
    echo >&2 Error connection to host not available, missing -h to host?
    exit $ERROR_CONNECTION
  fi

  [ $DEBUG -eq 1 ] && echo >&2 "Using FD $FD for sending packet"

  #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
  if [ $# -ge 1 ]; then
    newPacketBody "$1"
  fi

  # write command/read response

  createPacketTX
    # shellcheck disable=SC2059
  printf "$PACKET_TX_ECHO" >"$FILENAME_tx"
  #printf "%b" "$PACKET_TX_ECHO" >&"$FD" # echo -ne/printf "%b" splits packet at 0x0a if written directly to FD
  [ $DEBUG -eq 1 ] && unset "DEBUG_OPTIONS_dd"
  
  if dd if="$FILENAME_tx" ${DEBUG_OPTIONS_dd} >&"$FD"; then 

      if readResponseDD; then #readResponseCat

       # PACKET_TIMESTAMP=$(date)
        readHexASCII "$FILENAME_rx"

        if [ ${#PACKET_RX[@]} -eq 0 ]; then
          echo >&2 "$HOST Warning no response received from host"
        else
          parsePacket
        fi
      fi
  else
     echo >&2 Error DD failed to send packet to FD "$FD", dd status $?
  fi

}

discovery_socat () {
  typeset TIMEOUT_SCAN
  TIMEOUT_SCAN=2 #seconds
  typeset rxscan
  typeset rxscan_sorted
  typeset socat_discovery_server_pid
  typeset n
  typeset hex_escape

  [ $DEBUG -eq 0 ] && unset "DEBUG_OPTIONS_socat"

  [ $DEBUG -eq 1 ] && echo >&2 "UDP discovery on GW port $PORT_udp_discovery_client"
  [ $DEBUG -eq 1 ] && echo >&2 "UDP discovery on local port $PORT_udp_discovery_server"
  # shellcheck disable=SC2086
  socat $DEBUG_OPTIONS_socat -u UDP-RECV:"$PORT_udp_discovery_server" CREATE:$FILENAME_udp_server & # move in background
  socat_discovery_server_pid=$!
  [ $DEBUG -eq 1 ] && echo >&2 Socat discovery server PID = $socat_discovery_server_pid

  newPacketBody $CMD_broadcast
  createPacketTX
  #-R socat appends to file
  # shellcheck disable=SC2086
  {
    # shellcheck disable=SC2059
    printf "$PACKET_TX_ECHO"
    sleep $TIMEOUT_SCAN
  } | socat $DEBUG_OPTIONS_socat -R "$FILENAME_udp_client" - udp-datagram:255.255.255.255:$PORT_udp_discovery_client,broadcast >/dev/null #disable stdout echo of rx data, sleep timeout EOF on STDIN
  #(printf "\xff\xff\x12\x00\x04\x16"; sleep 3) | socat -d -d -x -R rxsocat  - udp-datagram:255.255.255.255:46000,broadcast
  kill $socat_discovery_server_pid

  cat "$FILENAME_udp_client" "$FILENAME_udp_server" >"$FILENAME_discovery" # Merge results from udp/tcp discovery
  #ff ff 12 00 27 48 3f da 54 14 ec c0 a8 03 50 af c8 17 47 57 31 30 30 30 41 2d 57 49 46 49 31 34 45 43 20 56 31 2e 36 2e 38 91
  # .  .  .  .  '  H  ?  .  T  .  .  .  .  .  P  .  .  .  G  W  1  0  0  0  A  -  W  I  F  I  1  4  E  C     V  1  .  6  .  8

  rxscan=$(od -A n -t x1 -v -w"$(stat -c %s "$FILENAME_discovery")" "$FILENAME_discovery")
  [ $DEBUG -eq 1 ] && echo Keeping files in "$PWD" "$FILENAME_discovery" "$FILENAME_udp_client" "$FILENAME_udp_server"
  ((!DEBUG)) && rm "$FILENAME_discovery" "$FILENAME_discovery_sorted" "$FILENAME_udp_client" "$FILENAME_udp_server"

  rxscan_sorted=$(printf "%s" "${rxscan//" ff ff 12"/"\nff ff 12"}" | sort -u | tail -n +3) # Skips first few lines which is a newline followed by broadcast (0x12) command

  printf "%s" "$rxscan_sorted" >"$FILENAME_discovery_sorted"

  while read -r line; do # loop through all received broadcasts and parse them
    if [ "${line:0:8}" = "ff ff 12" ]; then
      hex_escape=""
      n=0
      while [ "$n" -lt  ${#line} ]; do
        hex_escape="$hex_escape\x${line:$n:2}" # create \x escape codes for echo
         n=$(( n + 3))
      done
          # shellcheck disable=SC2059
      printf "$hex_escape" >"$FILENAME_rx"
      readHexASCII "$FILENAME_rx"
      parsePacket
    fi
  done <<<"$rxscan_sorted"

}

 readResponseDD () {
  typeset dd_result
  [ $DEBUG -eq 1 ] && unset "DEBUG_OPTIONS_dd"
  # shellcheck disable=SC2086
  timeout 0.5 dd bs=1024 count=1 ${DEBUG_OPTIONS_dd} <&"$FD" >$FILENAME_rx # timeout request, for example EasyWeather doesnt respond to rain command
  dd_result=$?
  if [ $dd_result -ne 0 ]; then
    echo >&2 Error DD failed to read response from FD "$FD", status "$dd_result"
  fi
  [ $DEBUG -eq 1 ] && echo >&2 dd_result $dd_result
  return $dd_result

}

 readResponseCat () {
  typeset timeoutCat
  timeoutCat=0.025 # Wireshark [Time delta from previous captured frame: 0.013166760 seconds]
  #   [ $DEBUG -eq 1 ] && timeoutOptions='-v'
  # cat inside while (true) { continue read }
  #https://github.com/coreutils/coreutils/blob/bbb19b18687d5572dcbe7bbb1a48c8ee0f21786b/src/cat.c#L168
  # Actually response is read in the first call to read, then a second read is started on stdin/redirected FD, so cat has to be killed...
  # timeout "$timeoutOptions"--preserve-status $timeoutCat cat <&"$FD" >$FILENAME_RESPONSE
  cat <&"$FD" >"$FILENAME_rx" &
  sleep $timeoutCat
  kill %1
}


 readHexASCII () {
  unset PACKET_RX_HEX # compact hex string without spaces ffff
  od -A n -t x1 -v -w"$(stat -c %s "$1")"  "$1" >"$FILENAME_od_hex"; 
  read -r  PACKET_RX_OD_HEX <"$FILENAME_od_hex" 
  rm "$FILENAME_od_hex"
  [ $DEBUG -eq 1 ] && echo >&2 OD HEX "$PACKET_RX_OD_HEX"
  
  convert_od_hexStringToArray "$PACKET_RX_OD_HEX" 
   #readarray -d ' ' -t PACKET_RX < <(echo -n "${PACKET_RX_OD[0]:1:-2}") # :1 substring, removes space at the beginning, -2: removes two trailing spaces
  PACKET_RX_HEX=${PACKET_RX_OD_HEX// /}                                 # strip off all spaces, just hex

}

connect () {
  # Info  from https://www.xmodulo.com/tcp-udp-socket-bash-shell.html
  typeset host
  host="$1"

  if [ -v FD_TCP ] || [ -v FD_UDP ]; then # True if the shell variable varname is set (has been assigned a value). - man bash
    [ $DEBUG -eq 1 ] && echo >&2 "$HOST_PREV closing connection"
    disconnect
  fi

  #https://www.gnu.org/software/bash/manual/bash.html - 3.6 Redirections
  if exec {FD_UDP}<>/dev/udp/"$host"/"$PORT_udp_discovery_client"; then
    [ $DEBUG -eq 1 ] && echo >&2 "$host:$PORT_udp_discovery_client Connected (UDP FD $FD_UDP)"
  else
    return $ERROR_CONNECTION
  fi

  if exec {FD_TCP}<>/dev/tcp/"$host"/"$PORT_tcp_command_server"; then
    [ $DEBUG -eq 1 ] && echo >&2 "$host:$PORT_tcp_command_server Connected (TCP FD $FD_TCP)"
  else
    return $ERROR_CONNECTION
  fi

  #Current shell PID $$

  if [ $DEBUG -eq 1 ]; then
    netstat -tunp | grep "$$"
  fi

  [ -v FD_TCP ] && [ -v FD_UDP ]

}


 disconnect () {
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
  #close sockets
  if [ -v FD_UDP ]; then

    if ! exec {FD_UDP}>&-; then echo >&2 Failed to close $FD_UDP; fi
    [ $DEBUG -eq 1 ] && echo >&2 "Closing FD $FD_UDP (UDP)"

    unset FD_UDP
  fi

  if [ -v FD_TCP ]; then

    if ! exec {FD_TCP}>&-; then echo >&2 Failed to close $FD_TCP; fi
    [ $DEBUG -eq 1 ] && echo >&2 "Closing FD $FD_TCP (TCP)"

    unset FD_TCP
  fi
}


 printPacketBody ()
{
  echo -------------------------- PACKET_BODY_LENGTH "${#PACKET_BODY[@]}"
  typeset n
  n=0
  while [ "$n" -lt ${#PACKET_BODY[@]} ]; do
     printf "%d %x\n" "$n" "${PACKET_BODY[$n]}"
     n=$(( n + 1))
  done
}

createPacketTX () {
  typeset packetLengthLSB
  typeset packetLengthMSB
  typeset n
  typeset cmd
  cmd=$(( PACKET_BODY[0] )) #make sure its an int

  #Update packet length, either 1 or 2 bytes
   
  if [  "$cmd" -eq  "$CMD_broadcast" ] || [ "$cmd" -eq $CMD_write_ssid ]; then 
          packetLengthLSB=$((   (${#PACKET_BODY[@]} + 1) & 0xff ))
          packetLengthMSB=$(( ( (${#PACKET_BODY[@]} + 1) & 0xff00 ) >> 8 ))
          
          decToHex $packetLengthMSB
          PACKET_BODY[1]=$VALUE_HEX

          decToHex $packetLengthLSB
          PACKET_BODY[2]=$VALUE_HEX
  else
          decToHex $(( ${#PACKET_BODY[@]} + 1 ))
          PACKET_BODY[1]=$VALUE_HEX # set packet length including checksum byte
  fi

  checksum

  PACKET_TX=(0xff 0xff "${PACKET_BODY[@]}" "$PACKET_CHECKSUM")
  PACKET_TX_CMD_INT=$(( PACKET_TX[2] )) # convert to decimal/integer for comparison in sendPacket

  #workaround for @(#)MIRBSD KSH R58 2020/03/27, assign array to ptx, complains about "bad subtitution"
 
  PACKET_TX_ECHO=""
  n=0
 # for n in "${!PACKET_TX[@]}"; do
  while [ "$n" -lt "${#PACKET_TX[@]}" ]; do
    PACKET_TX_ECHO+=${PACKET_TX[$n]}
    n=$(( n + 1 ))
  done
  
  PACKET_TX_ECHO=${PACKET_TX_ECHO//0x/'\x'}

   [ $DEBUG -eq 1 ] && { typeset ptx; ptx="${PACKET_TX[*]}"; echo >&2 PACKET_TX "${ptx//0x/''}" PACKET_TX_ECHO "$PACKET_TX_ECHO"; }

}

 parse_od_hex_packet ()
#$1 od hex string
{
      PACKET_RX_HEX=${1// /}                                 # strip off all spaces, just hex
      if [ ${#PACKET_RX_HEX} -eq  0 ]; then
          echo >&2 "Warning no data in response received from host"
      else
          [  "$DEBUG" -eq 1 ] && echo >&2 PACKET_RX_HEX "$PACKET_RX_HEX" length "${#PACKET_RX_HEX}"
          convert_od_hexStringToArray "$1"
          parsePacket
      fi
}

 convert_od_hexStringToArray ()
{
  typeset hexCode
 IFS=' '
 unset PACKET_RX
 for hexCode in $1; do
   PACKET_RX+=( "$hexCode" )
 done
}

checksum () {
  typeset n
  #caller 0

  PACKET_CHECKSUM=0
 # [ $DEBUG -eq 1 ] && echo >&2 checksum start PACKET_BODY "${PACKET_BODY[@]}"
  #http://mywiki.wooledge.org/BashGuide/Arrays
  #for ((n = 0; n < ${#PACKET_BODY[@]}; n++)); do
  #for n in "${!PACKET_BODY[@]}"; do
   n=0;
   while [ "$n" -lt "${#PACKET_BODY[@]}" ]; do
    PACKET_CHECKSUM=$(( (PACKET_CHECKSUM + ${PACKET_BODY[$n]}) & 0xff ))
    n=$(( n + 1))
   done
  decToHex $PACKET_CHECKSUM
  PACKET_CHECKSUM=$VALUE_HEX
  #[ $DEBUG -eq 1 ] && echo >&2 PACKET_CHECKSUM "$PACKET_CHECKSUM"
}

 



 writeUInt32BE () {
  writeUInt 32 "$1"
}

 writeUInt16BE () {
  writeUInt 16 "$1"
}

 writeUInt8 () {
  writeUInt 8 "$1"
}

writeUInt () {
  typeset hex

  case $1 in
      
       8)  #printf -v hex "%02x" "$2" 2>/dev/null ||  
           hex=$( printf "%02x" "$2")
           #VALUE_UINT8_HEX=$hex
            ;;
      
      16) #printf -v hex "%04x" "$2" 2>/dev/null ||  
          hex=$( printf  "%04x" "$2")
          #VALUE_UINT16BE_HEX=$hex
           ;;
      
      32) #printf -v hex "%08x" "$2" 2>/dev/null ||
          hex=$(  printf "%08x" "$2" )
          #VALUE_UINT32BE_HEX=$hex
          ;;
  esac
   
  n=0
  while  [ "$n" -lt ${#hex} ]; do # Convert to byte array
    PACKET_BODY+=(0x"${hex:$n:2}")
    n=$(( n + 2))
  done
}

readString () {
  typeset -i len
  len=0x${PACKET_RX[$RX_POS]}
  typeset n
  n=1
  #VALUE_STRING="${PACKET_RX_OD_ASCII:(($RX_POS + 1)):len}"
  unset VALUE_STRING
  while [ "$n" -le $(( len )) ]; do
      VALUE_STRING=$VALUE_STRING"\x${PACKET_RX[$RX_POS + $n]}"
      n=$(( n + 1 ))
  done
  # shellcheck disable=SC2059
  VALUE_STRING=$(printf "$VALUE_STRING")

  RX_POS=$(( RX_POS + len + 1 ))
}

decToHex () {
  VALUE_HEX=$( printf "0x%02x" "$1" ) 
}


#disconnect

##echo CMD_BROADCAST
#command '\x12\x00\x04\x15' $FD_UDP
#https://unix.stackexchange.com/questions/612193/socat-send-a-udp-broadcast-from-stdin-but-handling-responses-with-system
#printf "\xff\xff\x12\x00\x04\x16" | socat -d -d -x -t 1 - udp-datagram:255.255.255.255:46000,broadcast


typeset -a SENSOR_TYPE

#type:description:reportinginterval(s):max reportinterval:detection interval
SENSOR_TYPE[WH65_type]="WH65:Outdoor Solar Powered 7-in-1 Weather Sensor:16.0:"
SENSOR_TYPE[WH68_type]="WH68:Solar Powered Anemometer with Light and UV Sensor:16.5:"
SENSOR_TYPE[WH80_type]="WH80:Wind Speed/Direction, Solar Radiation/Light, Temp/Humidity:4.75:"
SENSOR_TYPE[WH40_type]="WH40:Self-Emptying Rain Collector Rainfall Sensor:49.0"
SENSOR_TYPE[WH32_type]="WH32:Outdoor Temperature and Humidity Sensor:64.0"
SENSOR_TYPE[WH57_type]="WH57:Lightning Detection Sensor:79.0:"
SENSOR_TYPE[WH45_type]="WH45:Indoor CO2 PM2.5 PM10 Temperature and Humidity:60.0:600"

#sensors with max 8 channels
typeset -i CH
CH=1
while [ "$CH" -le $WH31_max_ch ]; do 
   SENSOR_TYPE[$(( WH31_type + CH - 1 ))]="WH31:Temperature and humidity CH$CH:61.0:"
   SENSOR_TYPE[$(( WH51_type + CH - 1 ))]="WH51:Soil Moisture CH$CH:70.0:"
   SENSOR_TYPE[$(( WH34_type + CH - 1 ))]="WH34:Soil Temperature CH$CH:77.0"
   SENSOR_TYPE[$(( WH35_type + CH - 1 ))]="WH35:Leaf Wetness CH$CH:79.5"
   if [ $CH -le $WH55_max_ch ]; then
      SENSOR_TYPE[$(( WH43_type + CH - 1 ))]="WH43:PM2.5 Air Quality Indoor CH$CH:60.0:600.0"
      SENSOR_TYPE[$(( WH55_type + CH - 1 ))]="WH55:Water Leak CH$CH:60.0::3"
   fi
   CH=$((CH + 1))
done

typeset -a LIVEDATA

typeset -a LIVEDATA_FIELD
                      #name:description:unit:bytes:scaling/10:signedint
LIVEDATA_FIELD[0x01]="INTEMP:indoor temperature:C:2:1:1"
LIVEDATA_FIELD[0x02]="OUTTEMP:outdoor temperature:C:2:1:1"
LIVEDATA_FIELD[0x06]="INHUMI:indoor humidity:%:1:0"
LIVEDATA_FIELD[0x07]="OUTHUMI:outdoor humidity:%:1:0"
LIVEDATA_FIELD[0x08]="ABSBARO:absolute pressure:hpa:2:1"
LIVEDATA_FIELD[0x09]="RELBARO:relative pressure:hpa:2:1"
LIVEDATA_FIELD[0x0A]="WINDDIRECTION:wind direction:°:2:0"
LIVEDATA_FIELD[0x0B]="WINDSPEED:wind speed:m/s:2:1"
LIVEDATA_FIELD[0x19]="WINDGUSTDAILYMAX:wind gust daily max:m/s:2:1"
LIVEDATA_FIELD[0x0C]="WINDGUST:wind gust:m/s:2:1"
LIVEDATA_FIELD[0x0D]="RAINEVENT:rain event:mm:2:1"
LIVEDATA_FIELD[0x0E]="RAINRATE:rain rate:mm/h:2:1"
LIVEDATA_FIELD[0x0F]="RAINHOUR:rain hour:mm:2:1"
LIVEDATA_FIELD[0x10]="RAINDAILY:rain daily:mm:2:1"
LIVEDATA_FIELD[0x11]="RAINWEEK:rain week:mm:2:1"
LIVEDATA_FIELD[0x12]="RAINMONTH:rain month:mm:4:1"
LIVEDATA_FIELD[0x13]="RAINYEAR:rain year:mm:4:1"
LIVEDATA_FIELD[0x15]="LIGHT:light:lx:4:1" # lux=lumen/m2
LIVEDATA_FIELD[0x16]="UV:UV radiation:µW/m2:2:1"
LIVEDATA_FIELD[0x17]="UVI:UV index (0-15)::1:0"

LIVEDATA_FIELD[0x60]="LIGHTNING:lightning distance (1-40km):km:1:0"
typeset -i LDF_LIGHTNING_TIME=$(( 0x61 ))
LIVEDATA_FIELD[LDF_LIGHTNING_TIME]="LIGHTNING_TIME:lightning utc time:utc:4:0"
LIVEDATA_FIELD[0x62]="LIGHTNING_POWER:lightning power::4:0"

typeset -i LDF_SENSOR_CO2=$(( 0x70 ))
LIVEDATA_FIELD[LDF_SENSOR_CO2]="CO2:co2 pm2.5 pm10 temperature::16:0" #  parsing of livedata for this sensor 32 hexdigits

LDFT_WH43=0x2A
LDFT_WH43_24AVG=0x4D
LDFT_WH51=0x2B
LDFT_WH31_TEMP=0x1A
LDFT_WH31_HUMI=0x22
LDFT_WH55=0x58
LDFT_WH34=0x72
CH=1

while [ "$CH" -le 8 ]; do 
#for ((, CH=1;CH<=4; CH++, LDFT++,LDFT2++ )); do
  
  if [ "$CH" -le $WH43_max_ch ]; then 
        if [ "$CH" -eq 2 ]; then LDFT_WH43=$((0x51)); fi

        LIVEDATA_FIELD[$LDFT_WH43]="PM25_CH$CH:PM2.5 air quality CH$CH:μg/m3:2:1"
        LIVEDATA_FIELD[$LDFT_WH43_24AVG]="PM25_24HAVG_CH$CH:PM2.5 24h average CH$CH:μg/m3:2:1"
        LDFT_WH43=$(( LDFT_WH43 + 1))
        LDFT_WH43_24AVG=$(( LDFT_WH43_24AVG + 1))
  fi

  if [ "$CH" -le $WH51_max_ch ]; then 
   LIVEDATA_FIELD[$LDFT_WH51]="SOILTEMP_CH${CH}:soil temperature CH$CH:C:2:1:1"
   LIVEDATA_FIELD[$(( LDFT_WH51 + 1 ))]=SOILHUMI_CH$CH":soil humidity CH$CH"":%:1:0"
   LDFT_WH51=$(( LDFT_WH51 + 2))
  fi 

  if [ "$CH" -le $WH31_max_ch ]; then 
     LIVEDATA_FIELD[$LDFT_WH31_TEMP]="TEMP_CH$CH:temperature CH$CH:C:2:1:1"
     LIVEDATA_FIELD[$LDFT_WH31_HUMI]="HUMI_CH$CH:humidity CH$CH:%:1:0"
     LDFT_WH31_TEMP=$(( LDFT_WH31_TEMP + 1 ))
     LDFT_WH31_HUMI=$(( LDFT_WH31_HUMI + 1 ))
  fi

  if [ "$CH" -le $WH55_max_ch ]; then
     LIVEDATA_FIELD[$LDFT_WH55]="LEAK_CH$CH:leak CH$CH::1:0"
    LDFT_WH55=$(( LDFT_WH55 + 1 ))
  fi 

  if [ "$CH" -le $WH34_max_ch ]; then
     LIVEDATA_FIELD[$LDFT_WH34]="LEAF_WETNESS_CH$CH:leaf wetness CH$CH::1:0"
    LDFT_WH34=$(( LDFT_WH34 + 1 ))
  fi 

  CH=$(( CH + 1 ))

done

CONFIGURATION_SENSORFIELD="sensortype_"

#mapping from livedata field type/decimal to rename of description (specified in configuration file)
typeset -a LIVEDATA_FIELDRENAME
# fieldtypes discovered/parsed in livedata from host
typeset -a LDF_DISCOVERED 

#CONNECT ERRORS
ERROR_CONNECTION=1
ERROR_NO_NMCLI=2
ERROR_NC_UDP_SCAN_UNAVAILABLE=3
ERROR_RAINDATA_NOTSPECIFIED=4
ERROR_SYSTEMPARAM_NOTSPECIFIED=5
ERROR_NO_NC=6
ERROR_PACKET_HEADER=7

typeset -a CONFIGURATION
typeset -a CONFIGURATION_INDEX
#CONFIGURATION_INDEX array contains indexes to CONFIGURAITION with values
#CONFIGURATION_SENSOR[sensortype]=sensorid
typeset -a CONFIGURATION_SENSOR
typeset -a CONFIGURATION_SENSOR_INDEX
#CONFIGURATION_SENSOR_TYPE array contains indexes to CONFIGURATION_SENSOR with values
#if typeset -A ASSOCIATIVE_ARRAY 2>/dev/null; then # is easier to use, otherwise two arrays
#  SUPPORT_ASSOCIATIVE_ARRAY=1
#  unset ASSOCIATIVE_ARRAY
#fi

typeset -ir CONF_broadcast_ip=0
typeset -ir CONF_broadcast_mac=1
typeset -ir CONF_broadcast_port=2
typeset -ir CONF_broadcast_ssid=3
typeset -ir CONF_broadcast_version=4

typeset -ir CONF_customized_ecowitt_path=5
typeset -ir CONF_customized_enabled=6
typeset -ir CONF_customized_id=7
typeset -ir CONF_customized_interval=8
typeset -ir CONF_customized_password=9
typeset -ir CONF_customized_port=10
typeset -ir CONF_customized_server=11
typeset -ir CONF_customized_type=12
typeset -ir CONF_customized_wunderground_path=13

typeset -ir CONF_ecowitt_interval=14

typeset -ir CONF_host=15
typeset -ir CONF_mac=16

typeset -ir CONF_raindaily=17
typeset -ir CONF_rainmonth=18
typeset -ir CONF_rainrate=19
typeset -ir CONF_rainweek=20
typeset -ir CONF_rainyear=21

typeset -ir CONF_system_dst_status=22
typeset -ir CONF_system_dst_status_bit=23
typeset -ir CONF_system_dst_status_state=24
typeset -ir CONF_system_frequency=25
typeset -ir CONF_system_frequency_state=26
typeset -ir CONF_system_sensor_type=27
typeset -ir CONF_system_sensor_type_state=28
typeset -ir CONF_system_timezone_auto_bit=29
typeset -ir CONF_system_timezone_auto_state=30
typeset -ir CONF_system_timezone_index=31
typeset -ir CONF_system_timezone_index_state=32
typeset -ir CONF_system_utc=33
typeset -ir CONF_system_utc_state=34

typeset -ir CONF_version=35

typeset -ir CONF_weathercloud_id=36
typeset -ir CONF_weathercloud_password=37
typeset -ir CONF_wow_id=38
typeset -ir CONF_wow_password=39
typeset -ir CONF_wunderground_id=40
typeset -ir CONF_wunderground_password=41

typeset -ir CONF_calibration_intempoffset=42
typeset -ir CONF_calibration_inhumidityoffset=43
typeset -ir CONF_calibration_absoffset=44
typeset -ir CONF_calibration_reloffset=45
typeset -ir CONF_calibration_outtempoffset=46
typeset -ir CONF_calibration_outhumidityoffset=47
typeset -ir CONF_calibration_windiroffset=48

typeset -a CONFIGURATION_NAME #allow reverse mapping from property to index -> make backup file readable/editable
CONFIGURATION_NAME[CONF_broadcast_ip]="broadcast_ip"
CONFIGURATION_NAME[CONF_broadcast_mac]="broadcast_mac"
CONFIGURATION_NAME[CONF_broadcast_port]="broadcast_port"
CONFIGURATION_NAME[CONF_broadcast_ssid]="broadcast_ssid"
CONFIGURATION_NAME[CONF_broadcast_version]="broadcast_version"
CONFIGURATION_NAME[CONF_customized_ecowitt_path]="customized_ecowitt_path"
CONFIGURATION_NAME[CONF_customized_enabled]="customized_enabled"
CONFIGURATION_NAME[CONF_customized_id]="customized_id"
CONFIGURATION_NAME[CONF_customized_interval]="customized_interval"
CONFIGURATION_NAME[CONF_customized_password]="customized password"
CONFIGURATION_NAME[CONF_customized_port]="customized_port"
CONFIGURATION_NAME[CONF_customized_server]="customized_server"
CONFIGURATION_NAME[CONF_customized_type]="customized_type"
CONFIGURATION_NAME[CONF_customized_wunderground_path]="customized_wunderground_path"
CONFIGURATION_NAME[CONF_ecowitt_interval]="ecowitt_interval"
CONFIGURATION_NAME[CONF_host]="host"
CONFIGURATION_NAME[CONF_mac]="mac"
CONFIGURATION_NAME[CONF_rainrate]="rainrate"
CONFIGURATION_NAME[CONF_raindaily]="raindaily"
CONFIGURATION_NAME[CONF_rainweek]="rainweek"
CONFIGURATION_NAME[CONF_rainmonth]="rainmonth"
CONFIGURATION_NAME[CONF_rainyear]="rainyear"
CONFIGURATION_NAME[CONF_system_dst_status]="system_dst_status"
CONFIGURATION_NAME[CONF_system_dst_status_bit]="system_dst_status_bit"
CONFIGURATION_NAME[CONF_system_dst_status_state]="system_dst_status_state"
CONFIGURATION_NAME[CONF_system_frequency]="system_frequency"
CONFIGURATION_NAME[CONF_system_frequency_state]="system_frequency_state"
CONFIGURATION_NAME[CONF_system_sensor_type]="system_sensor_type"
CONFIGURATION_NAME[CONF_system_sensor_type_state]="system_sensor_type_state"
CONFIGURATION_NAME[CONF_system_timezone_auto_bit]="system_timezone_auto_bit"
CONFIGURATION_NAME[CONF_system_timezone_auto_state]="system_timezone_auto_state"
CONFIGURATION_NAME[CONF_system_timezone_index]="system_timezone_index"
CONFIGURATION_NAME[CONF_system_timezone_index_state]="system_timezone_index_state"
CONFIGURATION_NAME[CONF_system_utc]="system_utc"
CONFIGURATION_NAME[CONF_system_utc_state]="system_utc_state"
CONFIGURATION_NAME[CONF_version]="version"
CONFIGURATION_NAME[CONF_weathercloud_id]="weathercloud_id"
CONFIGURATION_NAME[CONF_weathercloud_password]="weathercloud_password"
CONFIGURATION_NAME[CONF_wow_id]="wow_id"
CONFIGURATION_NAME[CONF_wow_password]="wow_password"
CONFIGURATION_NAME[CONF_wunderground_id]="wunderground_id"
CONFIGURATION_NAME[CONF_wunderground_password]="wunderground_password"
CONFIGURATION_NAME[CONF_calibration_intempoffset]="calibration_intempoffset"
CONFIGURATION_NAME[CONF_calibration_inhumidityoffset]="calibration_intempoffset"
CONFIGURATION_NAME[CONF_calibration_absoffset]="calibration_absoffset"
CONFIGURATION_NAME[CONF_calibration_reloffset]="calibration_reloffset"
CONFIGURATION_NAME[CONF_calibration_outtempoffset]="calibration_outtempoffset"
CONFIGURATION_NAME[CONF_calibration_outhumidityoffset]="calibration_outhumidityoffset"
CONFIGURATION_NAME[CONF_calibration_windiroffset]="calibration_windiroffset"

#typeset -a CMD_NAME

#mapping to name
#CMD_NAME[$CMD_read_version]="read version"
#CMD_NAME[$CMD_reboot]="reboot"
#CMD_NAME[$CMD_read_mac]="read mac"
#CMD_NAME[$CMD_write_ssid]="write ssid"
#CMD_NAME[$CMD_broadcast]="broadcast"
#CMD_NAME[$CMD_write_reset]="reset"

#CMD_NAME[$CMD_read_ecowitt_interval]="read ecowitt intervall"
#CMD_NAME[$CMD_write_ecowitt_interval]="write ecowitt interval"
#CMD_NAME[$CMD_read_wunderground]="read wunderground"
#CMD_NAME[$CMD_write_wunderground]="write wunderground"
#CMD_NAME[$CMD_read_wow]="read wow"
#CMD_NAME[$CMD_write_wow]="write wow"
#CMD_NAME[$CMD_read_weathercloud]="read weathercloud"
#CMD_NAME[$CMD_write_weathercloud]="write weathercloud"

#CMD_NAME[$CMD_read_customized]="read customized"
#CMD_NAME[$CMD_write_customized]="write customized"
#CMD_NAME[$CMD_read_path]="read path"
#CMD_NAME[$CMD_write_path]="write path"

#CMD_NAME[$CMD_read_raindata]="read raindata"
#CMD_NAME[$CMD_write_raindata]="write raindata"

#CMD_NAME[$CMD_livedata]="livedata"

#CMD_NAME[$CMD_read_sensor_id]="read sensor id"
#CMD_NAME[$CMD_write_sensor_id]="write sensor id"
#CMD_NAME[$CMD_read_sensor_id_new]="read sensor id new"

#CMD_NAME[$CMD_read_system]="read system"
#CMD_NAME[$CMD_write_system]="write system"

#CMD_NAME[$CMD_read_calibration]="read calibration"
#CMD_NAME[$CMD_write_calibration]="write calibration"



 setConfiguration ()
#$1 - index to configuration element
#$2 - value
{
 typeset overwrite
 overwrite=0
 
  #check if index already has a value
  for i in "${CONFIGURATION_INDEX[@]}"; do
    if [ "$1" = "$i" ]; then
     overwrite=1
    fi
  done

  if [ $overwrite -eq 1 ]; then
     [ $DEBUG -eq 1 ] && >&2 echo "Overwrite value ${CONFIGURATION[$i]} index $1 with value $2"
      CONFIGURATION[$1]=$2

  else
    [ $DEBUG -eq 1 ] && >&2 echo "Setting configuration index $1 to value $2"
      CONFIGURATION[$1]=$2
      CONFIGURATION_INDEX+=( "$1" ) # keeps track of index with values, zsh doesnt have ${!arr} - keys expansion
  fi

  [ $DEBUG -eq 1 ] && >&2 echo "Indexes with values ${CONFIGURATION_INDEX[*]}"
}



 printConfiguration () {
typeset K
#typeset -i n
 #bash  for K in "${!CONFIGURATION[@]}"; do

 #n=0
 #while [ $n -lt ${#CONFIGURATION[@] ]

  if [ "${#CONFIGURATION_INDEX[@]}" -gt 0 ]; then 
    for K in  "${CONFIGURATION_INDEX[@]}"; do
      printf "%-30s %s\n" "${CONFIGURATION_NAME[$K]}" "${CONFIGURATION[$K]}" 
    done
  fi

  IFS=':'
  if [ "${#CONFIGURATION_SENSOR_INDEX[@]}" -gt 0 ]; then 
      for K in  "${CONFIGURATION_SENSOR_INDEX[@]}"; do
          read -r SNAME SDESC DISCARD <<< "${SENSOR_TYPE[$K]}"
          decToHex "${CONFIGURATION_SENSOR[$K]}"
          printf "%-30s %10s %s\n"  "$CONFIGURATION_SENSORFIELD$K" "$VALUE_HEX" "$SDESC" 
      done
  fi

}

 printStack () {
  if [ -n "$BASH_VERSION" ]; then 
    echo "${FUNCNAME[@]}"
  fi
}


 listLivedataFieldsAndDescription ()
# $1 - if non-zero list only active fields found during parsing of livedata, else list all known fields
{
  typeset fn #using typeset instead of local which isnt available in ksh https://stackoverflow.com/questions/12000949/scope-of-variables-in-ksh
  typeset fd
  typeset fk
  
  IFS=' '
  
  if [ -n "$1" ]; then
   fk="${LDF_DISCOVERED[*]}" # works for zsh
  elif [ -z "$ZSH_VERSION" ]; then
   fk=${!LIVEDATA_FIELD[*]} # !  all keys, except zsh which expands all values
  fi

  printf "%4s %-16s %s\n" "type" "name" "description"

  for k in $fk; do
    IFS=':'
   if [ -n "$1" ] || [ -z "$ZSH_VERSION" ]; then
      read -r fn fd DISCARD <<< "${LIVEDATA_FIELD[$k]}"
   elif [ -n "$ZSH_VERSION" ]; then
      read -r fn fd DISCARD <<< "$k"
   fi   
    printf "%4d %-16s %s\n" "$k" "$fn" "$fd"
  done
}

 parseLivedata ()
# $1 -pattern to match
#https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs [[ [ ((
{
  typeset fieldTypeDec
  typeset match
  typeset len
  typeset liveline

 [ $DEBUG -eq 1 ] && >&2 echo parseLivedata "SPATTERN" "$SPATTERN"

  IFS=':'
  unset LDF_DISCOVERED

  len=$((${#PACKET_RX[@]} - 1))
  match=0

  #date +"%s.%N"

  while [ "$RX_POS" -lt $len  ]; do

    [ $DEBUG -eq 1 ] && >&2 echo PACKET_RX_HEX "${PACKET_RX_HEX:(( $RX_POS * 2 ))}" RX_POS "$RX_POS" PACKET_RX_LENGTH "${#PACKET_RX[@]}"

    readUInt8
    fieldTypeDec=$VALUE_UINT8

     LDF_DISCOVERED+=( "$fieldTypeDec" ) # keep track of discovered fields

   read -r LDFNAME LDFDESC LDFUNIT LDFBYTES LDFSCALE LDFSIGNEDINT << EOF
${LIVEDATA_FIELD[$fieldTypeDec]}
EOF
    
    unset LDFDESC_RENAME
    if [ -n "${LIVEDATA_FIELDRENAME[$fieldTypeDec]}" ]; then #rename sensor description
       LDFDESC_RENAME=${LIVEDATA_FIELDRENAME[$fieldTypeDec]}
    fi

    if   [ "$LDFBYTES" -eq 1 ]; then  
          readUInt8
          LIVEDATA[$fieldTypeDec]=$VALUE_UINT8

    elif [ "$LDFBYTES" -eq 2 ] && [ -z "$LDFSIGNEDINT" ]; then 
          readUInt16BE 
          LIVEDATA[$fieldTypeDec]=$VALUE_UINT16BE
    elif [ "$LDFBYTES" -eq 2 ] && [ "$LDFSIGNEDINT" -eq 1 ]; then
          readInt16BE # temp is signed 16-bit
          LIVEDATA[$fieldTypeDec]=$VALUE_INT16BE
    elif [ "$LDFBYTES" -eq 4 ]; then
          readUInt32BE
          LIVEDATA[$fieldTypeDec]=$VALUE_UINT32BE
    else
       readHex "$LDFBYTES"
       LIVEDATA[$fieldTypeDec]=$VALUE_HEX_STRING
    fi
    
     if [ "$LDFSCALE" -eq 1 ]; then # scale: divide by 10 if neccessary
        convertScale10ToFloat "${LIVEDATA[$fieldTypeDec]}"
        LIVEDATA[$fieldTypeDec]=$VALUE_SCALE10_FLOAT
     fi

    liveline="$LDFNAME $LDFDESC $LDFDESC_RENAME"
    toLowercase "$liveline"
    liveline=$lowercase


    if [ "$SHELL_SUPPORT_TILDE_REGEX" -eq 1 ]; then
       eval 'if [[ "$liveline" =~  ${SPATTERN} ]] ; then match=1; printLivedata "$fieldTypeDec"; fi' #eval prevent ksh parser syntax error
      # ^ line starts with, ,,=to lowercase
     elif echo "$liveline" | grep -i -q -E "$SPATTERN"; then
        match=1 
        printLivedata "$fieldTypeDec"
    fi

  done

  [ $DEBUG -eq 1 ] && >&2 echo Discovered fields in packet "${LDF_DISCOVERED[@]}"
  
  if [ "$match" -eq 0 ]; then
  >&2 echo "Error Failed to match '$SPATTERN' in current livedata fields"
     listLivedataFieldsAndDescription 1 # 1 - list only active/discovered fields in parsed data
    
  fi
}


 parseSensor()
{
  typeset match # flag when pattern matches fields
  typeset printSensorHeaderFlag
  typeset n
  unset CONFIGURATION_SENSOR
  unset CONFIGURATION_SENSOR_INDEX
  unset CONFIGURATION_SENSOR_MATCH # keeps track of sensors matching search pattern
  n=0
  match=0
  printSensorHeaderFlag=0

 # echo SENSOR_SEARCH ${SENSOR_SEARCH} SENSOR_DISABLE $SENSOR_DISABLE $(( 0xffffffff ))

  [ $DEBUG -eq 1 ] && >&2 echo parseSensor "SPATTERN" "$SPATTERN"
 
     IFS=':'
    
       while [ "$RX_POS" -lt $(( ${#PACKET_RX[@]} - 1 )) ]; do
            
            typeset RX_START_POS
            RX_START_POS=$RX_POS # for listing entire record as hex

              readUInt8

              STYPE=$VALUE_UINT8
    # shellcheck disable=SC2034
              read -r SNAME SDESC SINTERVAL_MIN DISCARD << EOF
${SENSOR_TYPE[STYPE]}
EOF
              [ -z "$SNAME" ] && [ $DEBUG -eq 1 ] && >&2 echo  "Unknown SENSOR_TYPE $STYPE"

              readUInt32BE

              SID=$VALUE_UINT32BE
              SID_HEX=$VALUE_UINT32BE_HEX # for searching

              n=$(( n + 1 ))

              setConfigurationSensor "$STYPE" $SID

              if [ "$SID" -eq "$SENSOR_SEARCH" ]; then 
                  SID_STATE="searching"
              elif [ "$SID" -eq  "$SENSOR_DISABLE" ]; then
                    SID_STATE="disabled"
              else    
                    SID_STATE='enabled'
              fi

              readUInt8
              
              SBATTERY=$VALUE_UINT8
              
              unset SBATTERY_STATE
              #https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs


              if [ "$SID_STATE" = "enabled" ]; then # intepret battery levels

                  if [ "$STYPE" -ge "$WH43_type" ] && [ "$STYPE" -lt  $(( WH43_type + WH43_max_ch )) ] ||
                     [ "$STYPE" -ge "$WH55_type" ] && [ "$STYPE" -lt  $(( WH55_type + WH55_max_ch )) ] ||
                     [ "$STYPE" -eq "$WH57_type" ] ||
                     [ "$STYPE" -eq "$WH45_type" ]; then  #WH43 - PM2.5 indoor, WH41? same ID?
                  #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/CurdataGwFragment.java l 4575
                    getBatteryLevelState "$SBATTERY"
                  fi

                  #Voltage value seems to be scaled * 10 for soil moisture/rainfall sensor
                  if [ "$STYPE" -ge  $WH51_type ] && [ "$STYPE" -lt $(( WH51_type + WH51_max_ch )) ] || 
                     [ "$STYPE" -eq  $WH40_type ]; then 
                        convertScale10ToFloat "$SBATTERY"
                        SBATTERY_STATE=$VALUE_SCALE10_FLOAT"V"
                        if [ "$SBATTERY" -le 12 ]; then
                          SBATTERY_STATE+=" low"
                        fi
                  fi

                  if [  "$STYPE" -eq  $WH65_type ] || [ "$STYPE" -ge $WH31_type ] && [ "$STYPE" -lt  $(( WH31_type + WH31_max_ch )) ]; then # WH65, WH31 CH1-8 
                    getBatteryState "$SBATTERY"
                  fi
              fi

              readUInt8
              
              SSIGNAL=$VALUE_UINT8
            
            [ $DEBUG -eq 1 ] && >&2 echo "${PACKET_RX_HEX:(($RX_START_POS * 2)):14}"

          match=0
     #force external grep for testing
         # typeset bashv
         # bashv=$BASH_VERSION
         # typeset kshv
         # kshv=$KSH_VERSION
         # typeset zshv
         # zshv=$ZSH_VERSION
         # unset BASH_VERSION KSH_VERSON ZSH_VERSION
          SLINE="$STYPE $SNAME $SID_HEX $SID_STATE $SBATTERY $SBATTERY_STATE $SSIGNAL $SINTERVAL_MIN $SDESC"
          toLowercase "$SLINE"
          SLINE=$lowercase
          
          [ $DEBUG -eq 1 ] && >&2 echo SLINE "$SLINE"
          
          if [ "$SHELL_SUPPORT_TILDE_REGEX" -eq 1 ]; then
               eval 'if [[ ${SLINE,,} =~ $SPATTERN ]]; then match=1; fi' #eval prevent ksh parser syntax error
                # ^ line starts with, ,,=to lowercase
          elif  echo "$SLINE"   | grep -i -q -E "$SPATTERN"; then
               #-w option to search for word or "\<word\>" search pattern
                #https://www.networkworld.com/article/2764489/unix-tip-grepping-on-whole-words.html
                match=1
          fi
          
          #BASH_VERSION=$bashv
          #KSH_VERSION=$kshv
          #ZSH_VERSION=$zshv
       
          if [ $match -eq 1 ] && [ $printSensorHeaderFlag -eq 0 ]; then
            printSensorHeaderFlag=1
            CONFIGURATION_SENSOR_MATCH+=( "$STYPE" )
            printSensorHeader
            printSensorLine
          elif [ $match -eq 1 ];then 
            CONFIGURATION_SENSOR_MATCH+=( "$STYPE" )
            printSensorLine
          fi
            
       done

       [ $DEBUG -eq 1 ] && >&2 echo PARSED "${CONFIGURATION_SENSOR_INDEX[@]}" length "${#CONFIGURATION_SENSOR_INDEX[@]}"
       [ $DEBUG -eq 1 ] && >&2 echo MACTHED "${CONFIGURATION_SENSOR_MATCH[@]}" length "${#CONFIGURATION_SENSOR_MATCH[@]}"
     
}


parsePacket () {
  typeset -i cmd
  RX_POS=4 # current read position/after packet length byte for indexing PACKET_RX_OD[1] - ASCII string from od utility

  cmd=$(( 0x${PACKET_RX[2]} ))

  #Packet length
  if [ "$cmd" -eq  $CMD_broadcast ] || [ "$cmd" -eq $CMD_livedata ] || [ "$cmd" -eq $CMD_read_sensor_id_new ]; then

      RX_POS=5    
      #printf -v PACKET_RX_LENGTH "%u" "0x${PACKET_RX[3]}${PACKET_RX[4]}" 2>/dev/null || 
      PACKET_RX_LENGTH=$(( 0x${PACKET_RX[3]}${PACKET_RX[4]} ))
   else  
       PACKET_RX_LENGTH=$(( 0x${PACKET_RX[3]} ))
  fi

  [ $DEBUG -eq 1 ] && >&2 echo  "Parse packet ${PACKET_RX[*]} length $PACKET_RX_LENGTH"

  if  [ "$cmd" -eq $CMD_write_ecowitt_interval ] ||
   [ "$cmd" -eq $CMD_write_reset ] ||
   [ "$cmd" -eq $CMD_write_customized ] ||
   [ "$cmd" -eq $CMD_write_path ] ||
   [ "$cmd" -eq $CMD_reboot ] ||
   [ "$cmd" -eq $CMD_write_ssid ] ||
   [ "$cmd" -eq $CMD_write_raindata ] ||
   [ "$cmd" -eq $CMD_write_wunderground ] ||
   [ "$cmd" -eq $CMD_write_wow ] ||
   [ "$cmd" -eq $CMD_write_weathercloud ] ||
   [ "$cmd" -eq $CMD_write_sensor_id ] ||
   [ "$cmd" -eq $CMD_write_calibration ] ||
   [ "$cmd" -eq $CMD_write_system ]; then 

    parseResultPacket

  elif [  "$cmd" -eq $CMD_read_mac ]; then

    #setConfiguration $CONF_mac "$(printf "%02X:%02X:%02X:%02X:%02X:%02X" 0x"${PACKET_RX[4]}" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}")"
    C_MAC="$(printf "%02X:%02X:%02X:%02X:%02X:%02X" 0x"${PACKET_RX[4]}" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}")"

    echo "$C_MAC"

  elif [  "$cmd" -eq $CMD_read_version ]; then

    readString
    #setConfiguration $CONF_version "$VALUE_STRING"
    C_VERSION=$VALUE_STRING
   
    echo "$C_VERSION"

  elif [  "$cmd" -eq $CMD_read_system ]; then
  
     readUInt8
     #setConfiguration $CONF_system_frequency "$VALUE_UINT8"
     C_SYSTEM_FREQUENCY=$VALUE_UINT8
     if [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM433M ]; then
      # setConfiguration $CONF_system_frequency_state "433MHz"
       C_SYSTEM_FREQUENCY_STATE="433MHz"
     elif [ "$C_SYSTEM_FREQUENCY"  -eq $SYSTEM_FREQUENCY_RFM868M ]; then
       #setConfiguration $CONF_system_frequency_state "868MHz"
       C_SYSTEM_FREQUENCY_STATE="868MHz"
     elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM915M ]; then
       #setConfiguration $CONF_system_frequency_state "915MHz"
       C_SYSTEM_FREQUENCY_STATE="915MHz"
     elif [ "$C_SYSTEM_FREQUENCY" -eq $SYSTEM_FREQUENCY_RFM920M ]; then
       #setConfiguration $CONF_system_frequency_state "920MHz"
       C_SYSTEM_FREQUENCY_STATE="920MHz"
     fi

     readUInt8
     #setConfiguration $CONF_system_sensor_type $VALUE_UINT8 # 0=WH24, 1=WH65
     C_SYSTEM_SENSORTYPE=$VALUE_UINT8
     if [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH24 ]; then
       #setConfiguration $CONF_system_sensor_type_state "WH24"
       SENSOR_TYPE[WH24_type]="WH24:Outdoor Weather Sensor:16.0:" # overwrite default WH65_type=0
      C_SYSTEM_SENSORTYPE_STATE="WH24"
     elif [ "$C_SYSTEM_SENSORTYPE" -eq $SYSTEM_SENSOR_TYPE_WH65 ]; then
       #setConfiguration $CONF_system_sensor_type_state "WH65"
      C_SYSTEM_SENSORTYPE_STATE="WH65"
     fi

     readUInt32BE
     #setConfiguration $CONF_system_utc $VALUE_UINT32BE # UTC time (seconds)
     C_SYSTEM_UTC=$VALUE_UINT32BE
     #setConfiguration $CONF_system_utc_state "$(date -u -d @"$VALUE_UINT32BE" +'%F %T')"
     C_SYSTEM_UTC_STATE="$(date -u -d @"$VALUE_UINT32BE" +'%F %T')"
     #while true; do time ./gw  -h 192.168.3.80 -c system | grep utc; date -u; sleep 0.6; done #see time difference between machine time and device time

     readUInt8
     #setConfiguration $CONF_system_timezone_index $VALUE_UINT8 # 39 = UTC
     C_SYSTEM_TIMEZONE_INDEX=$VALUE_UINT8
     initTimezones
     #setConfiguration $CONF_system_timezone_index_state "${SYSTEM_TIMEZONE[CONFIGURATION[$CONF_system_timezone_index]]}"
      C_SYSTEM_TIMEZONE_INDEX_STATE=${SYSTEM_TIMEZONE[$C_SYSTEM_TIMEZONE_INDEX]}

     readUInt8
     #setConfiguration $CONF_system_dst_status $VALUE_UINT8
     C_SYSTEM_DST_STATUS=$VALUE_UINT8
     #setConfiguration $CONF_system_dst_status_bit "$(( ${CONFIGURATION[$CONF_system_dst_status]} & 0x1 ))"
     C_SYSTEM_DST_STATUS_BIT=$(( C_SYSTEM_DST_STATUS & 0x01 ))
     if [ "$C_SYSTEM_DST_STATUS_BIT" -eq 1 ]; then
        #setConfiguration $CONF_system_dst_status_state "on";
        C_SYSTEM_DST_STATUS_STATE="on"
      elif [ "$C_SYSTEM_DST_STATUS_BIT" -eq 0 ]; then
        #setConfiguration $CONF_system_dst_status_state "off"
        C_SYSTEM_DST_STATUS_STATE="off"
     fi  
     
     #setConfiguration $CONF_system_timezone_auto_bit $(( ( ${CONFIGURATION[$CONF_system_dst_status]} & 0x2 ) >> 1 )) # bit 2 1= off, 0=on ?
     C_SYSTEM_TIMEZONE_AUTO_BIT=$(( (C_SYSTEM_DST_STATUS & 0x2 ) >> 1 )) # bit 2 1= off, 0=on ?
     if [ "$C_SYSTEM_TIMEZONE_AUTO_BIT" -eq 0 ]; then
        #setConfiguration $CONF_system_timezone_auto_state "on";
        C_SYSTEM_TIMEZONE_AUTO_STATE="on"
      elif [  "${CONFIGURATION[$CONF_system_timezone_auto_bit]}" -eq 1 ]; then
        #setConfiguration $CONF_system_timezone_auto_state "off"
         C_SYSTEM_TIMEZONE_AUTO_STATE="off"
     fi

     printSystem

  elif [ "$cmd" -eq $CMD_read_ecowitt_interval ]; then

    readUInt8
    #setConfiguration $CONF_ecowitt_interval "$VALUE_UINT8"
    C_WS_ECOWITT_INTERVAL=$VALUE_UINT8
    echo $C_WS_ECOWITT_INTERVAL

  elif [  "$cmd" -eq $CMD_read_wunderground ]; then

    readString
    #setConfiguration $CONF_wunderground_id "$VALUE_STRING"
    C_WS_WUNDERGROUND_ID=$VALUE_STRING
    readString
    #setConfiguration $CONF_wunderground_password "$VALUE_STRING"
    C_WS_WUNDERGROUND_PASSWORD=$VALUE_STRING

    echo "$C_WS_WUNDERGROUND_ID $C_WS_WUNDERGROUND_PASSWORD" 
    
  elif [  "$cmd" -eq $CMD_read_wow ]; then

    readString
    #setConfiguration $CONF_wow_id "$VALUE_STRING"
    C_WS_WOW_ID=$VALUE_STRING

    readString
    #setConfiguration $CONF_wow_password "$VALUE_STRING"
    C_WS_WOW_PASSWORD=$VALUE_STRING

    echo "$C_WS_WOW_ID $C_WS_WOW_PASSWORD"
   
  elif [  "$cmd" -eq $CMD_read_weathercloud ]; then

    readString
    #setConfiguration $CONF_weathercloud_id "$VALUE_STRING"
    C_WS_WC_ID=$VALUE_STRING
    
    readString
    #setConfiguration $CONF_weathercloud_password "$VALUE_STRING"
    C_WS_WC_PASSWORD=$VALUE_STRING
    echo "$C_WS_WC_ID $C_WS_WC_PASSWORD"
    
  elif [  "$cmd" -eq $CMD_read_customized ]; then

    readString
    #setConfiguration $CONF_customized_id "$VALUE_STRING"
    C_WS_CUSTOMIZED_ID=$VALUE_STRING

    readString
    #setConfiguration $CONF_customized_password "$VALUE_STRING"
    C_WS_CUSTOMIZED_PASSWORD=$VALUE_STRING

    readString
    #setConfiguration $CONF_customized_server "$VALUE_STRING"
    C_WS_CUSTOMIZED_SERVER=$VALUE_STRING

    readUInt16BE
    #setConfiguration $CONF_customized_port "$VALUE_UINT16BE"
    C_WS_CUSTOMIZED_PORT=$VALUE_UINT16BE

    readUInt16BE
    #setConfiguration $CONF_customized_interval "$VALUE_UINT16BE"
    C_WS_CUSTOMIZED_INTERVAL=$VALUE_UINT16BE
    
    readUInt8
    #setConfiguration $CONF_customized_type "$VALUE_UINT8"
    C_WS_CUSTOMIZED_TYPE=$VALUE_UINT8

    if [ "$C_WS_CUSTOMIZED_TYPE" -eq 1 ]; then
      C_WS_CUSTOMIZED_TYPE_STATE="wunderground"
    elif [ "$C_WS_CUSTOMIZED_TYPE" -eq 0 ]; then
      C_WS_CUSTOMIZED_TYPE_STATE="ecowitt"
    fi
    
    readUInt8
    #setConfiguration $CONF_customized_enabled "$VALUE_UINT8"
    
    C_WS_CUSTOMIZED_ENABLED=$VALUE_UINT8
    if [ "$C_WS_CUSTOMIZED_ENABLED" -eq 1 ]; then
       C_WS_CUSTOMIZED_ENABLED_STATE="on"
    elif [ "$C_WS_CUSTOMIZED_ENABLED" -eq 0 ]; then
       C_WS_CUSTOMIZED_ENABLED_STATE="off"
    fi
    
    printCustomized

  elif [  "$cmd" -eq $CMD_read_path ]; then

    readString
    #setConfiguration $CONF_customized_ecowitt_path "$VALUE_STRING"
    C_WS_CUSTOMIZED_PATH_ECOWITT=$VALUE_STRING
    
    readString
    #setConfiguration $CONF_customized_wunderground_path "$VALUE_STRING"
    C_WS_CUSTOMIZED_PATH_WU=$VALUE_STRING

  elif [  "$cmd" -eq $CMD_broadcast ]; then
    #this is the station MAC/ip on local network, when device is reset its annoncing hotspot accesspoint/AP with first byte of MAC changed
    # shellcheck disable=SC2102
    setConfiguration $CONF_broadcast_mac "$( printf "%02X:%02X:%02X:%02X:%02X:%02X" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}" 0x"${PACKET_RX[10]}")"

    # shellcheck disable=SC2102
    setConfiguration $CONF_broadcast_ip "$(printf "%u.%u.%u.%u" 0x"${PACKET_RX[11]}" 0x"${PACKET_RX[12]}" 0x"${PACKET_RX[13]}" 0x"${PACKET_RX[14]}" )"
    
    RX_POS=17
    typeset ssid
    typeset version
    #        IFS=' '; read -r ssid version <<< "${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}" # ssid appends space+version
    readString
    IFS=' '
    read -r ssid version <<< "$VALUE_STRING" # ssid appends space+version

    setConfiguration $CONF_broadcast_ssid "$ssid"
    setConfiguration $CONF_broadcast_version "$version"
    # shellcheck disable=SC2102
    #printf -v CONFIGURATION[$CONF_broadcast_port] "%u" 0x"${PACKET_RX[15]}""${PACKET_RX[16]}" ||
    setConfiguration $CONF_broadcast_port "$(( 0x${PACKET_RX[15]}${PACKET_RX[16]} ))"

    echo "${CONFIGURATION[$CONF_broadcast_mac]} ${CONFIGURATION[$CONF_broadcast_ip]}:${CONFIGURATION[$CONF_broadcast_port]} ${CONFIGURATION[$CONF_broadcast_ssid]} ${CONFIGURATION[$CONF_broadcast_version]}"

  elif [  "$cmd" -eq $CMD_read_raindata ]; then

    # echo "${PACKET_RX_HEX}" "$RX_POS_HEX"
    readUInt32BE
    #setConfiguration $CONF_rainrate "$VALUE_UINT32BE"
    C_RAINRATE=$VALUE_UINT32BE

    readUInt32BE
    #setConfiguration $CONF_raindaily "$VALUE_UINT32BE"
    C_RAINDAILY=$VALUE_UINT32BE
    
    readUInt32BE
    #setConfiguration $CONF_rainweek "$VALUE_UINT32BE"
    C_RAINWEEK=$VALUE_UINT32BE

    readUInt32BE
    #setConfiguration $CONF_rainmonth "$VALUE_UINT32BE"
    C_RAINMONTH=$VALUE_UINT32BE

    readUInt32BE
    #setConfiguration $CONF_rainyear "$VALUE_UINT32BE"
    C_RAINYEAR=$VALUE_UINT32BE

    printRain

 elif [ "$cmd" -eq $CMD_read_calibration ]; then

   readUInt16BE
   setConfiguration $CONF_calibration_intempoffset "$VALUE_UINT16BE"
   
   readUInt8 
   setConfiguration $CONF_calibration_inhumidityoffset "$VALUE_UINT8"

   readUInt32BE ""
   setConfiguration $CONF_calibration_absoffset "$VALUE_UINT32BE"

   readUInt32BE ""
   setConfiguration $CONF_calibration_reloffset "$VALUE_UINT32BE"

   readUInt16BE
   setConfiguration $CONF_calibration_outtempoffset "$VALUE_UINT16BE" 
   
   readUInt8
   setConfiguration $CONF_calibration_outhumidityoffset "$VALUE_UINT8" 

   readUInt16BE
   setConfiguration $CONF_calibration_windiroffset "$VALUE_UINT16BE"  

   printCalibration
   
  elif [  "$cmd" -eq $CMD_livedata ]; then

    parseLivedata "$SPATTERN" # use time for performance monitoring/optimization

  elif [ "$cmd" -eq $CMD_read_sensor_id_new ] || [  "$cmd" -eq $CMD_read_sensor_id ]; then

    parseSensor 1
     
  else

    >&2 echo  "Warning unable to parse response for command $cmd $PACKET_RX_HEX " "$CMD_write_ecowitt_interval"
  fi
}


 newPacketBody () {
  # PACKET BODY STARTING AT BYTE 2 (from 0 index, first 0xff 0xff)
  typeset -i cmd
  cmd=$1

  if [ -z "$1" ]; then
      >&2 echo Error no command given to newPacketBody
      return 1
  fi
  
  #PACKET_BODY=() - ksh set array to length 1 here!?
  unset PACKET_BODY
  decToHex  $(( cmd ))
  PACKET_BODY+=("$VALUE_HEX" "0x00")
  
  if [ "$cmd" -eq $CMD_broadcast ] || [ "$cmd" -eq $CMD_write_ssid ]; then  
   # WSVIEW sends 2 byte field for size
    PACKET_BODY+=("0x00")
#    [ $DEBUG -eq 1 ] && >&2 echo  appending 0x00 for 2-byte packet length PACKET BODY "${PACKET_BODY[@]}"
  fi 

 #[ $DEBUG -eq 1 ] && >&2 echo PACKET BODY "${PACKET_BODY[@]}"
 
}

 writeString  () {
  typeset n

  [ $DEBUG -eq 1 ] && >&2 echo  "${FUNCNAME[0]} $1 len ${#1}"
  decToHex ${#1}
  PACKET_BODY+=("$VALUE_HEX")
  n=0
  while [ "$n" -lt ${#1} ]; do
    decToHex "'${1:$n:1}"
    PACKET_BODY+=("$VALUE_HEX")
    n=$(( n + 1 ))
  done
}

setConfigurationSensor ()
#$1 - STYPE sensor type
#$2 - SID sensor id
{
typeset overwrite
typeset updated
 updated=0
 overwrite=0
 
  #check if index already has a value
  for i in "${CONFIGURATION_SENSOR_INDEX[@]}"; do
    if [ "$1" = "$i" ]; then
     overwrite=1
    fi
  done

  if [ $overwrite -eq 1 ]; then
     [ $DEBUG -eq 1 ] && >&2 echo "Overwrite sensor configuration value ${CONFIGURATION_SENSOR[$i]} index $1 with value $2"
      CONFIGURATION_SENSOR[$1]=$2

      for i in "${CONFIGURATION_SENSOR_UPDATE_INDEX[@]}"; do #dont append new index if already marked for update
          if [ "$1" = "$i" ]; then
             updated=1
          fi
      done

     if [ $updated -eq 0 ]; then
      [ $DEBUG -eq 1 ] && >&2 echo "Update sensor configuration index $1"
      CONFIGURATION_SENSOR_UPDATE_INDEX+=( "$1" ) #keep track of updated sensors, for example used for writing only updated sensors to gw1000
     fi 

  else #this is a new sensor
     [ $DEBUG -eq 1 ] && >&2 echo "Setting sensor configuration index $1 to value $2"
      CONFIGURATION_SENSOR[$1]=$2
      CONFIGURATION_SENSOR_INDEX+=( "$1" ) # keeps track of sensor index with values/ids, zsh doesnt have ${!arr} - keys expansion
      CONFIGURATION_SENSOR_UPDATE_INDEX+=( "$1" )
  fi

  [ $DEBUG -eq 1 ] && >&2 echo "Indexes with values ${CONFIGURATION_INDEX[*]}"
}

 setSensorId_decprecate ()
#$1 - STYPE sensor type
#$2 - SID sensor id
{
 [ "$DEBUG" -eq 1 ] &&  >&2 echo "Setting sensor type $1 to $2"
                                                          
  CONFIGURATION_SENSOR[$1]=$(( $2 ))
  # only update when value overwritten
  CONFIGURATION_SENSOR_UPDATE_INDEX+=( "$1" )
}

 sendSensorId ()
{
  typeset type
  #debug : WSVIEW sensor overview is updated periodically to reflect current state

  if [ ${#CONFIGURATION_SENSOR_UPDATE_INDEX[@]} -eq 0 ]; then
    return 1
  fi

  newPacketBody $CMD_write_sensor_id

  for type in "${CONFIGURATION_SENSOR_UPDATE_INDEX[@]}"; do
  
    writeUInt8 "$type"                  # 1 byte packet length? (255-3)/5 bytes pr field = 50 sensor types max
    writeUInt32BE "${CONFIGURATION_SENSOR[$type]}"

    #[ $DEBUG -eq 1 ] && 
    >&2 printf "Write sensor type %3d id %8x\n" "$type" "${CONFIGURATION_SENSOR[$type]}"
  done

  sendPacket
}


connectGW () {
  typeset lan_mac
  typeset lan_mac_lc #lowercase
  typeset ap_mac
  typeset ap_all_scan
  typeset ap_scan
  typeset ap_scan_result
  typeset connect_result
  typeset connect_str
  typeset connect_attempt
  typeset connect_attempt_MAX
  typeset connected
  typeset timeout
  typeset bssid_pattern

  timeout=5
  connected=1
  connect_attempt=0
  connect_attempt_MAX=15

  #useful for debugging: sudo nmcli device monitor and  sudo iw event -r

  if ! which nmcli >/dev/null; then
    return "$ERROR_NO_NMCLI"
  fi

  sudo nmcli radio wifi on
  >&2 echo  Attempting to reconnect to device, waiting $timeout s for device to bootup after reset
  sleep $timeout # wait for reset/bootup

  # Station mode/LAN: MAC 48:3F:DA:54:14:EC, ssid/version GW1000A-WIFI14EC, AP-mode: MAC 4A:3F:DA:54:14:EC, GW1000-WIFI4EC
  # 48:3F:DA - EspressIf Inc. https://www.wireshark.org/tools/oui-lookup.html
  #  nmcli dev wifi list : 4A:3F:DA:54:14:EC  GW1000-WIFI14EC  Infra  1     54 Mbit/s   77      ▂▄▆_  --
  # observation/seldom : 4A:3F:DA:54:14:EC SSID  ESP_5414EC -> hotsport started before ssid rename in firmware v.1.6.8?
  lan_mac=${CONFIGURATION[$CONF_broadcast_mac]//:/}
  toLowercase "${CONFIGURATION[$CONF_broadcast_mac]}"
  lan_mac_lc=$lowercase
  bssid_pattern=${lan_mac:9}

  while ((connected == 1 && connect_attempt < "$connect_attempt_MAX")); do
    ((connect_attempt++))

    [ $DEBUG -eq 1 ] && >&2 echo  Connect attempt "$connect_attempt"
    if [ "$connect_attempt" -eq 1 ]; then
      ap_all_scan=$(sudo nmcli -t -e no -f BSSID,SSID,IN-USE dev wifi list --rescan yes) #use terse mode for fixed format string
    else
      ap_all_scan=$(sudo nmcli -t -e no -f BSSID,SSID,IN-USE dev wifi list --rescan auto)
    fi
    ap_scan=$(grep -F "$bssid_pattern" <<<"$ap_all_scan")
    ap_scan_result=$?

    if [ $ap_scan_result -eq 0 ] && [ -n "$ap_scan" ]; then
     
      [ $DEBUG -eq 1 ] && >&2 echo  AP scan "$ap_scan"
     
       read -r $READARRAY_OPTION  -d':' nmcli_result <<< "$ap_scan"
     
      in_use=${nmcli_result[7]}
      ap_mac=${nmcli_result[0]}${nmcli_result[1]}${nmcli_result[2]}${nmcli_result[3]}${nmcli_result[4]}${nmcli_result[5]}
      ap_mac=${ap_mac:0:-1}

      if [ "$in_use" != "*" ]; then
        [ $DEBUG -eq 1 ] && >&2 echo  Connecting to bssid "$ap_mac"
        connect_str=$(sudo nmcli -w 5 dev wifi connect "$ap_mac") #nmcli has a default timeout of 45 seconds, try just waiting 5 s
        connect_result=$?
        >&2 echo  "$connect_str"
      fi

      if [ $connect_result -eq 0 ] && [[ $connect_str != Error* ]] || [ "$in_use" == "*" ]; then
        [ $DEBUG -eq 1 ] && arp -n | grep -F "${lan_mac_lc:9}" >&2
        connected=0
        #ip -4 -o address
      fi

    fi

    ((connected == 1)) && sleep 5
  done

  ip address

}

-m | --sensor)

    if [ -n "$2" ] && [ "${2:0:1}" != '-' ]; then 

          case $2 in
           
            *=*) # parameter contains =

                      unset CONFIGURATION_SENSOR_UPDATE_INDEX #array -> contains sensortype to update

                      #sendPacket "$CMD_read_sensor_id_new" >/dev/null
                    
                        # $2 -  {sensortype}=search|disable|hexid,{st1-stn}=search|disable|hexid,...
                        IFS=","
                        if [ -n "$BASH_VERSION" ]; then
                          arrayOption='-a'
                        elif [ -n "$KSH_VERSION" ] || [ -n "$ZSH_VERSION" ]; then
                          arrayOption='-A'
                        else
                          arrayOption='-A'
                        fi
#shellcheck disable=2229
                        read -r $arrayOption SENSOR_MANAGEMENT  <<< "$2" 

                        s_disable="disable"
                        s_search="search"
                        n=0

                        while [ "$n" -lt ${#SENSOR_MANAGEMENT[@]} ];  do

                              IFS='='
                              read -r STYPE SID <<< "${SENSOR_MANAGEMENT[$n]}" # {st1-stn}=search|disable|hexid (for example 1-10=search)

                              if [ -z "$SID" ]; then
                               >&2 echo Sensor id after = empty, use search/disable/hexid
                                n=$(( n + 1 ))
                                continue
                              fi
                              
                              IFS='-'
                              read -r STYPE_MIN STYPE_MAX <<< "$STYPE" 
 
                              [ "$DEBUG" -eq 1 ] && >&2 echo "STYPE_MIN $STYPE_MIN STYPE_MAX $STYPE_MAX"
 
                              #https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash/806923
                              STYPE_INVALID=0
                              [ -z "$STYPE_MAX" ] && STYPE_MAX=$STYPE_MIN

                              if ! isNumber  "$STYPE_MIN"; then # first check for valid number, then check limits
                                 >&2 echo "$STYPE_MIN is  invalid sensor type/number"
                                STYPE_INVALID=1
                              elif ! isNumber "$STYPE_MAX"; then  
                                  >&2 echo "$STYPE_MAX is invalid sensor type/number"
                                  STYPE_INVALID=1
                              elif [ "$STYPE_MIN" -gt "$SENSORTYPE_MAX" ] || [ "$STYPE_MIN" -gt "$STYPE_MAX" ]; then
                                  >&2 echo "$STYPE_MIN is not valid, max is $SENSORTYPE_MAX"
                                  STYPE_INVALID=1
                              elif [  "$STYPE_MAX" -gt "$SENSORTYPE_MAX" ] || [ "$STYPE_MAX" -lt "$STYPE_MIN" ]; then  
                                 >&2 echo "$STYPE_MAX is invalid, max is $SENSORTYPE_MAX";
                                  STYPE_INVALID=1    
                              fi

                              if [ "$STYPE_INVALID" -eq 1 ]; then 
                                n=$(( n + 1 ))
                                continue
                              fi 

                              [ "$DEBUG" -eq  1 ] &&  >&2 echo Parsing expression $n "${SENSOR_MANAGEMENT[$n]}" STYPE "$STYPE" SID "$SID"

                              toLowercase "$SID"
                              SID=$lowercase
                              s_search=${s_search:0:${#SID}}
                              s_disable=${s_disable:0:${#SID}} # shrink search pattern for matching

                             if [ "$SID" = "$s_search" ]; then
                                 updateSensorIdRange $SENSOR_SEARCH
                             elif [ "$SID" = "$s_disable" ] && [ "$SID" != 'd' ]; then
                                 updateSensorIdRange $SENSOR_DISABLE
                             else
                                r=$STYPE_MIN
                                if [ "$r" -eq "$STYPE_MAX" ]; then 
                                #https://www.gnu.org/software/grep/manual/html_node/Regular-Expressions.html#Regular-Expressions
                                      if [ -n "$BASH_VERSION" ] ||  [ -n "$ZSH_VERSION" ]; then 
                                                #extended regular expression ^ -start of line $-end of line - {1,8} iterator/quantifier
                                          eval 'if [[ $SID =~ ^[a-fA-F0-9]{1,8}$ ]]; then 
                                                          setConfigurationSensor "$r" 0x"$SID" 
                                                else
                                                        >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                fi'
                                          #use eval to avoid syntax error in mirbsd korn shell/android
                                      elif [[ $KSH_VERSION == Version* ]]; then
                                          eval 'if [[ $SID == {1,8}([a-fA-F0-9]) ]]; then
                                                          setConfigurationSensor "$r" 0x"$SID" 
                                                else
                                                        >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                fi'
                                        #http://www.mirbsd.org/htman/i386/man1/mksh.htm
                                      elif [[ $KSH_VERSION == *MIRBSD* ]]; then #android shell
                                          eval 'if [[ $SID == +([a-f]|[A-F]|[0-9]) && ${#SID} -le 8 ]]; then 
                                                          setConfigurationSensor "$r" 0x"$SID" 
                                                else
                                                    >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                fi'
                                      elif echo "$SID" | grep -E -q "^[a-fA-F0-9]{1,8}$"; then  
                                                  setConfigurationSensor "$r" 0x"$SID"
                                      else
                                          >&2 echo  "Error shell not supported, cannot set $r to $SID"
                                      fi
                                        r=$(( r + 1 ))
                                else
                                    >&2 echo  "Error cannot set type $STYPE_MIN-$STYPE_MAX to same id $SID"
                                fi
                                #expr $SID : "\([a-fA-F0-9]\+\)" works in BASH/KSH/ZSH, but not MIRBSD KSH - \+ - one or more repetitions \() - extract substring

                              fi

                              n=$(( n + 1 ))
                          
                          done

                          if [ "${#CONFIGURATION_SENSOR_UPDATE_INDEX}" -ge 1 ] ; then sendSensorId; fi

                        shift 2
                          ;;


-m | --sensor)

    if [ -n "$2" ] && [ "${2:0:1}" != '-' ]; then 

          case $2 in
           
            *=*) # parameter contains =

                      unset CONFIGURATION_SENSOR_UPDATE_INDEX #array -> contains sensortype to update

                      #sendPacket "$CMD_read_sensor_id_new" >/dev/null
                    
                        # $2 -  {sensortype}=search|disable|hexid,{st1-stn}=search|disable|hexid,...
                        IFS=","
                        if [ -n "$BASH_VERSION" ]; then
                          arrayOption='-a'
                        elif [ -n "$KSH_VERSION" ] || [ -n "$ZSH_VERSION" ]; then
                          arrayOption='-A'
                        else
                          arrayOption='-A'
                        fi
#shellcheck disable=2229
                        read -r $arrayOption SENSOR_MANAGEMENT  <<< "$2" 

                        s_disable="disable"
                        s_search="search"
                        n=0

                        while [ "$n" -lt ${#SENSOR_MANAGEMENT[@]} ];  do

                              IFS='='
                              read -r STYPE SID <<< "${SENSOR_MANAGEMENT[$n]}" # {st1-stn}=search|disable|hexid (for example 1-10=search)

                              if [ -z "$SID" ]; then
                               >&2 echo Sensor id after = empty, use search/disable/hexid
                                n=$(( n + 1 ))
                                continue
                              fi
                              
                              IFS='-'
                              read -r STYPE_MIN STYPE_MAX <<< "$STYPE" 
 
                              [ "$DEBUG" -eq 1 ] && >&2 echo "STYPE_MIN $STYPE_MIN STYPE_MAX $STYPE_MAX"
 
                              #https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash/806923
                              STYPE_INVALID=0
                              [ -z "$STYPE_MAX" ] && STYPE_MAX=$STYPE_MIN

                              if ! isNumber  "$STYPE_MIN"; then # first check for valid number, then check limits
                                 >&2 echo "$STYPE_MIN is  invalid sensor type/number"
                                STYPE_INVALID=1
                              elif ! isNumber "$STYPE_MAX"; then  
                                  >&2 echo "$STYPE_MAX is invalid sensor type/number"
                                  STYPE_INVALID=1
                              elif [ "$STYPE_MIN" -gt "$SENSORTYPE_MAX" ] || [ "$STYPE_MIN" -gt "$STYPE_MAX" ]; then
                                  >&2 echo "$STYPE_MIN is not valid, max is $SENSORTYPE_MAX"
                                  STYPE_INVALID=1
                              elif [  "$STYPE_MAX" -gt "$SENSORTYPE_MAX" ] || [ "$STYPE_MAX" -lt "$STYPE_MIN" ]; then  
                                 >&2 echo "$STYPE_MAX is invalid, max is $SENSORTYPE_MAX";
                                  STYPE_INVALID=1    
                              fi

                              if [ "$STYPE_INVALID" -eq 1 ]; then 
                                n=$(( n + 1 ))
                                continue
                              fi 

                              [ "$DEBUG" -eq  1 ] &&  >&2 echo Parsing expression $n "${SENSOR_MANAGEMENT[$n]}" STYPE "$STYPE" SID "$SID"

                              toLowercase "$SID"
                              SID=$lowercase
                              s_search=${s_search:0:${#SID}}
                              s_disable=${s_disable:0:${#SID}} # shrink search pattern for matching

                             if [ "$SID" = "$s_search" ]; then
                                 updateSensorIdRange $SENSOR_SEARCH
                             elif [ "$SID" = "$s_disable" ] && [ "$SID" != 'd' ]; then
                                 updateSensorIdRange $SENSOR_DISABLE
                             else
                                r=$STYPE_MIN
                                if [ "$r" -eq "$STYPE_MAX" ]; then 
                                #https://www.gnu.org/software/grep/manual/html_node/Regular-Expressions.html#Regular-Expressions
                                      if [ -n "$BASH_VERSION" ] ||  [ -n "$ZSH_VERSION" ]; then 
                                                #extended regular expression ^ -start of line $-end of line - {1,8} iterator/quantifier
                                          eval 'if [[ $SID =~ ^[a-fA-F0-9]{1,8}$ ]]; then 
                                                          setConfigurationSensor "$r" 0x"$SID" 
                                                else
                                                        >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                fi'
                                          #use eval to avoid syntax error in mirbsd korn shell/android
                                      elif [[ $KSH_VERSION == Version* ]]; then
                                          eval 'if [[ $SID == {1,8}([a-fA-F0-9]) ]]; then
                                                          setConfigurationSensor "$r" 0x"$SID" 
                                                else
                                                        >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                fi'
                                        #http://www.mirbsd.org/htman/i386/man1/mksh.htm
                                      elif [[ $KSH_VERSION == *MIRBSD* ]]; then #android shell
                                          eval 'if [[ $SID == +([a-f]|[A-F]|[0-9]) && ${#SID} -le 8 ]]; then 
                                                          setConfigurationSensor "$r" 0x"$SID" 
                                                else
                                                    >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                fi'
                                      elif echo "$SID" | grep -E -q "^[a-fA-F0-9]{1,8}$"; then  
                                                  setConfigurationSensor "$r" 0x"$SID"
                                      else
                                          >&2 echo  "Error shell not supported, cannot set $r to $SID"
                                      fi
                                        r=$(( r + 1 ))
                                else
                                    >&2 echo  "Error cannot set type $STYPE_MIN-$STYPE_MAX to same id $SID"
                                fi
                                #expr $SID : "\([a-fA-F0-9]\+\)" works in BASH/KSH/ZSH, but not MIRBSD KSH - \+ - one or more repetitions \() - extract substring

                              fi

                              n=$(( n + 1 ))
                          
                          done

                          if [ "${#CONFIGURATION_SENSOR_UPDATE_INDEX}" -ge 1 ] ; then sendSensorId; fi

                        shift 2
                          ;;

             *) # assume its a search pattern if it does not contain =

                        initSearchPatternForCommand "$2"
                        sendPacket "$CMD_read_sensor_id_new"
                        shift 2
                        ;;

          esac
         
     else
         initSearchPatternForCommand
         sendPacket $CMD_read_sensor_id_new
         shift
     fi

     ;;



     #for debugging
#echo PID "$$"
#read -r -p "DEBUG - press key to continue"

#SHELLIFS=$IFS

#https://stackoverflow.com/questions/29968096/get-android-os-version-of-device-connected-via-adb
#testing purpose
#if which getprop 2>/dev/null ; then
#   ANDROID_BUILD_VERSION=$(getprop ro.build.version.release)
#   printenv
#fi

#[ -n "$ZSH_VERSION" ] && emulate ksh 
#setopt ksharrays 2>/dev/null # for zsh, force array index start at 0


 readUInt32BE () {
  VALUE_UINT32BE_HEX="0x${PACKET_RX_HEX:(($RX_POS * 2)):8}"
  VALUE_UINT32BE=$(( (0x${PACKET_RX[$RX_POS ]} << 24) | (0x${PACKET_RX[$RX_POS + 1 ]} << 16)  | (0x${PACKET_RX[$RX_POS + 2 ]} << 8) |  0x${PACKET_RX[$RX_POS + 3]} ))
  RX_POS=$(( RX_POS + 4 ))
}


 readInt32BE ()
#$1 decimal
#2's complement big endian
#msb is the sign bit
{
  typeset hexstr

  if [ -n "$1" ]; then
    hexstr=$1
  else
     hexstr="0x${PACKET_RX_HEX:(($RX_POS * 2)):8}"
  fi
  #VALUE_INT32BE_HEX=$hexstr
  VALUE_INT32BE=$(( -1* ( hexstr >> 31) * 0x80000000 +   ( hexstr & 0x7fffffff ) ))
  if [ -z "$1" ]; then
    RX_POS=$(( RX_POS + 4 ))
  fi
}


readUInt16BE () {
  #VALUE_UINT16BE_HEX="0x${PACKET_RX_HEX:(($RX_POS * 2)):4}"
  VALUE_UINT16BE=$(( (0x${PACKET_RX[$RX_POS]} << 8) |  0x${PACKET_RX[$RX_POS + 1]} ))
 
  RX_POS=$(( RX_POS + 2 ))
}

 readInt16BE ()
#$1 - decimal
#2's complement big endian
#msb is the sign bit
#test cmd: n=0; while [ "$n" -lt $(( 1 << 16 )) ]; do readInt16BE $(printf "%x" $n); echo $n $VALUE_INT16BE; n=$(( n + 1 )); done 
{
  typeset hexstr

  if [ -n "$1" ]; then
    hexstr=$1
  else
    hexstr="0x${PACKET_RX_HEX:(($RX_POS * 2)):4}"
  fi
  #VALUE_INT16BE_HEX=$hexstr
  #Converting from two's complement representation
  #https://en.wikipedia.org/wiki/Two%27s_complement
  VALUE_INT16BE=$(( -1* ( hexstr >> 15) * 0x8000 +  ( hexstr & 0x7fff ) ))
  if [ -z "$1" ]; then
     RX_POS=$(( RX_POS + 2 ))
  fi
}

 readUInt8 () {
  #VALUE_UINT8_HEX="0x${PACKET_RX_HEX:(($RX_POS * 2)):2}"
  VALUE_UINT8=$(( 0x${PACKET_RX[$RX_POS ]} ))

  RX_POS=$(( RX_POS + 1 ))
}

 readInt8 ()
#$1 - decimal
{
  typeset hexstr

  if [ -n "$1" ]; then
    hexstr=$1
  else
    hexstr="0x${PACKET_RX_HEX:(($RX_POS * 2)):2}"
  fi
  #VALUE_INT8_HEX=$hexstr
  VALUE_INT8=$(( -1 * ( hexstr >> 7) * 0x80 + ( hexstr & 0x7f ) ))

  if [ -z "$1" ]; then
    RX_POS=$(( RX_POS + 1 ))
  fi
}

 readHex ()
#$1 - length in bytes
{
  # PACKET_RX_HEX : string of hex bytes ffff...<checksum>
  VALUE_HEX_STRING=${PACKET_RX_HEX:(($RX_POS * 2)):$(( $1 * 2 ))}
  RX_POS=$(( RX_POS + $1 + 1))
}



 showRainInfoMessage () {
  which notify-send >/dev/null && notify-send -t 3000 -i dialog-warning "gw script" "$1" &
  #https://www.shell-tips.com/linux/how-to-format-date-and-time-in-linux-macos-and-bash/
  printf "%s %s\n" "$(date)" "$1" # may add bell \a
  if [ -n "$2" ]; then
    which espeak >/dev/null && espeak -p10 "$2" &
  fi
}

 runRainNotification () { 
  # $1 - number of seconds between each rain probe
  # $2 - show start/stop messages only (1 on, 0 off)
  typeset rr
  typeset rd
  typeset rainInterval # raining continously for "$1" seconds
  typeset rainDuration # minutes raining
  typeset simulation
  typeset showStartStopEventOnly
  typeset rainTimeout
  rainTimeout=$1
  showStartStopEventOnly=$2

  simulation=0 # 1 = on for testing
  [ $DEBUG -eq 1 ] && >&2 echo Rain simulation $simulation
  [ "$simulation" -eq 1 ] && {
    rainTimeout=5
    showStartStopEventOnly=1
    CONFIGURATION[$CONF_rainrate]=0
    CONFIGURATION[$CONF_raindaily]=10
  } # { list ; } run in current shell

  [ $DEBUG -eq 1 ] && >&2 echo  "Rain event interval $rainTimeout s. Show start/stop events only $showStartStopEventOnly"

  rainInterval=0
  while true; do
    [ "$simulation" -eq 0 ] && sendPacket $CMD_read_raindata >/dev/null
    [ "$simulation" -eq 1 ] && { CONFIGURATION[$CONF_rainrate]=$(("${CONFIGURATION[$CONF_rainrate]}" + 10 ))
    [ ${CONFIGURATION[$CONF_rainrate]} -eq 50 ] && CONFIGURATION[CONF_rainrate]=0; }
    convertScale10ToFloat "${CONFIGURATION[$CONF_rainrate]}"
    rr=$VALUE_SCALE10_FLOAT
    convertScale10ToFloat "${CONFIGURATION[$CONF_raindaily]}"
    rd=$VALUE_SCALE10_FLOAT
    if [ "${CONFIGURATION[$CONF_rainrate]}" -ne 0 ]; then
      rainInterval=$((rainInterval+1))
      if [ "$rainInterval" -eq 1 ]; then
        showRainInfoMessage "☂ Raining $rr mm/h.Today $rd mm" "Its raining! $rr millimeter per hour. Today $rd millimeter"
      else
        if [ "$showStartStopEventOnly" != "1" ]; then
          showRainInfoMessage "☂ Raining $rr mm/h. Today $rd mm"
        fi
      fi
    fi
    if [ "$rainInterval" -gt 0 ] && [ "${CONFIGURATION[$CONF_rainrate]}" -eq 0 ]; then
      rainDuration=$((rainInterval * rainTimeout / 60)) # integer only in bash
      showRainInfoMessage "Raining stopped! Today $rd mm. Rained for $rainDuration minutes." "Raining stopped! Today $rd millimeter. It rained for $rainDuration minutes."
      rainInterval=0
    fi
    sleep "$rainTimeout"
  done
}

printLivedata ()
#$1 field type in decimal
{
    if [ -n "${LDFDESC_RENAME}" ]; then
           LDFDESC=$LDFDESC_RENAME
        fi

   # if [ "$LDFUNIT" = "℃" ]; then
        #multibyte character/unicode requires 1 larger width and a space padding for description
   #           printf "%8s %6s %s\n" "${LIVEDATA[$1]}" "$LDFUNIT" " $LDFDESC"
    if [ "$LDFUNIT"  = "°" ]; then
              printf "%8s %6s %s\n" "${LIVEDATA[$1]}" "$LDFUNIT" "$LDFDESC"
    elif [ "$1" -eq $LDF_SENSOR_CO2 ]; then
       parseLivedata_C02_sensor "${LIVEDATA[$1]}"
    elif [ "$1" -eq $LDF_LIGHTNING_TIME ]; then
       printf "%8s %5s %s\n" "$(date -u -d @"${LIVEDATA[$1]}" +'%F %T')" "$LDFUNIT" "$LDFDESC" 
    else
            printf "%8s %5s %s\n" "${LIVEDATA[$1]}" "$LDFUNIT" "$LDFDESC"
    fi 

    if [ "$LDFNAME" = 'WINDDIRECTION' ]; then  
            convertWindDirectionToCompassDirection $(( ${LIVEDATA[$1]} ))
            #LIVEDATA_EXTRA[$fieldTypeDec]=$VALUE_COMPASS_DIRECTION_NAME
            if [ -n "${LIVEDATA_FIELDRENAME[compass_direction]}" ]; then
                LDFDESC=${LIVEDATA_FIELDRENAME[compass_direction]}
            else
              LDFDESC="wind compass direction"
            fi
              printf "%8s %5s %s\n" "$VALUE_COMPASS_DIRECTION_NAME" "" "$LDFDESC"
            
    fi

}


parseLivedata_C02_sensor ()
#$1 - hex string
{
  typeset ld_temp_co2
  typeset ld_humidity_co2
  typeset ld_pm10_co2
  typeset ld_pm10_24h_co2
  typeset ld_pm25_co2
  typeset ld_pm25_24h_co2
  typeset ld_co2
  typeset ld_co2_24h
  typeset ld_co2_batt
  
  [ "$DEBUG" -eq 1 ] && >&2 echo  parse livedata co2 hex string"$1" "${#1}"
  #testdata: parseLivedata_C02_sensor "$(printf "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x" 00 100 70 00 101 00 110 00 120 00 130 00 140 00 150 0)"

  readInt16BE "0x${1:0:4}"
  convertScale10ToFloat $VALUE_INT16BE
  ld_temp_co2=$VALUE_SCALE10_FLOAT
  
  ld_humidity_co2=$(( 0x${1:4:2} ))
  
  convertScale10ToFloat "0x${1:6:4}"
  ld_pm10_co2=$VALUE_SCALE10_FLOAT

  convertScale10ToFloat "0x${1:10:4}"
  ld_pm10_24h_co2=$VALUE_SCALE10_FLOAT

  convertScale10ToFloat "0x${1:14:4}"
  ld_pm25_co2=$VALUE_SCALE10_FLOAT

  convertScale10ToFloat "0x${1:18:4}"
  ld_pm25_24h_co2=$VALUE_SCALE10_FLOAT

  ld_co2=$(( 0x${1:22:4} ))
  ld_co2_24h=$(( 0x${1:26:4} ))
  ld_co2_batt=$(( 0x${1:30:2} ))
  
  printf "%8s %5s %s\n" "$ld_temp_co2"         "C" "temperature"
  printf "%8s %5s %s\n" "$ld_humidity_co2"     "%" "humidity"
  printf "%8s %5s %s\n" "$ld_pm10_co2"     "µg/m3" "PM10"
  printf "%8s %5s %s\n" "$ld_pm10_24h_co2" "µg/m3" "PM10 24h average"
  printf "%8s %5s %s\n" "$ld_pm25_co2"     "µg/m3" "PM25"
  printf "%8s %5s %s\n" "$ld_pm25_24h_co2" "µg/m3" "PM25 24h average"
  printf "%8s %5s %s\n" "$ld_co2"           "ppm"  "co2"
  printf "%8s %5s %s\n" "$ld_co2_24h"       "ppm"  "co2 24h average"
  printf "%8s %5s %s\n" "$ld_co2_batt"       ""    "battery level"
  
}

  printTimezones ()
{
  typeset n
  n=0
  printf "%3s %s\n" "tzi" "timezone" #tzi timezone index
  #for tz in "${SYSTEM_TIMEZONE[@]}"; do
  while [ $n -lt ${#SYSTEM_TIMEZONE[@]} ]; do
  tz=${SYSTEM_TIMEZONE[$n]}
    printf "%3d %s\n" $n "$tz"
    n=$(( n + 1))
  done
}

 getConfigurationIndexFromName ()
{
  typeset -i i

  i=0
  while [ $i -lt ${#CONFIGURATION_NAME[@]} ]; do
    if [ -n "${CONFIGURATION_NAME[$i]}" ] && [ "${CONFIGURATION_NAME[$i]}" = "$1" ]; then
       CONFIGURATION_NAME_INDEX=$i
       break;
    fi
   i=$((i + 1))
  done
}


 printSensorHeader ()
{
   printf "%4s %5s %8s %10s %7s %13s %6s %12s %s\n" type name id id_state battery battery_state signal interval_min description
}

 printSensorLine ()
{
  case "$KSH_VERSION" in 
   *MIRBSD*)
      typeset -iU SID_PRINT=$SID #force usigned int for mirbsd korn shell/android to get proper formatting 
       printf "%4s %5s %8x %10s %7s %13s %6s %12s %s\n" "$STYPE" "$SNAME" "$SID_PRINT" "$SID_STATE" "$SBATTERY" "$SBATTERY_STATE" "$SSIGNAL" "$SINTERVAL_MIN" "$SDESC"
       ;;
  *)
    printf "%4s %5s %8x %10s %7s %13s %6s %12s %s\n" "$STYPE" "$SNAME" "$SID" "$SID_STATE" "$SBATTERY" "$SBATTERY_STATE" "$SSIGNAL" "$SINTERVAL_MIN" "$SDESC"
    ;;
  esac
}


 updateSensorIdRange ()
#$1 - search or disable
{
  typeset r
  r=$STYPE_MIN
  while [ "$r" -le "$STYPE_MAX" ]; do 
    #    for (( r=STYPE_MIN; r<= STYPE_MAX; r++ )); do 
            setConfigurationSensor "$r" "$1"
            r=$(( r + 1))
  done
}


printCalibration ()
#for sensor array
{

  if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
  #shellcheck disable=SC3044
  { typeset intempoffset
    typeset inhumidityoffset
    typeset absoffset
    typeset reloffset
    typeset outtempoffset
    typeset outhumidityoffset
    typeset windiroffset; }
  else
    { local intempoffset
    local inhumidityoffset
    local absoffset
    local reloffset
    local outtempoffset
    local outhumidityoffset
    local windiroffset; }
  fi

  readInt16BE "${CONFIGURATION[$CONF_calibration_intempoffset]}" # convert to signed int intepretation
  convertScale10ToFloat "$VALUE_INT16BE"
  intempoffset=$VALUE_SCALE10_FLOAT
   
   readInt8 "${CONFIGURATION[$CONF_calibration_inhumidityoffset]}"
  inhumidityoffset=$VALUE_INT8

  readInt32BE "${CONFIGURATION[$CONF_calibration_absoffset]}"
  convertScale10ToFloat "$VALUE_INT32BE"
  absoffset=$VALUE_SCALE10_FLOAT

  readInt32BE "${CONFIGURATION[$CONF_calibration_reloffset]}"
  convertScale10ToFloat "$VALUE_INT32BE"
  reloffset=$VALUE_SCALE10_FLOAT

  readInt16BE "${CONFIGURATION[$CONF_calibration_outtempoffset]}"
  convertScale10ToFloat "$VALUE_INT16BE"
  outtempoffset=$VALUE_SCALE10_FLOAT
  
  readInt8 "${CONFIGURATION[$CONF_calibration_outhumidityoffset]}"
  outhumidityoffset=$VALUE_INT8
  
  readInt16BE "${CONFIGURATION[$CONF_calibration_windiroffset]}"
  windiroffset=$VALUE_INT16BE

  printf "%12s %16s %12s %12s %12s %12s %12s\n" intempoffset inhumidityoffset absoffset reloffset outtempoffset outhumidityoffset windiroffset

  printf "%12s %16s %12s %12s %12s %12s %12s\n" "$intempoffset" "$inhumidityoffset" "$absoffset" "$reloffset" "$outtempoffset" "$outhumidityoffset" "$windiroffset"
}

 initLivedataFieldDescriptionRenaming ()
{
  if [ ! -s "$FILENAME_livedata_description" ]; then
     [ "$DEBUG" -eq 1 ] && >&2 echo Warning "$FILENAME_livedata_description" is empty or does not exists, using default names for livedata field descriptions
     return 1
  fi

  #mapping from livedata field in decimal to names
  #26=bedroom,  #27=livingroom
  
  while IFS='=' read -r LDFTYPE LDNAME; do
    if [ -z "$LDFTYPE" ] || [[ "$LDFTYPE" = *#* ]] ; then #skip comments
      continue;
    fi
     LIVEDATA_FIELDRENAME[$LDFTYPE]=$LDNAME
     [ $DEBUG -eq 1 ] && >&2 echo Livedata field type to name "$LDFTYPE=$LDNAME"
  done < "$FILENAME_livedata_description"

}


readUInt16BEold ()
{
    local prefixDeleteSubstring
    local b1b2

    unset VALUE_UINT16BE

    if [ ${#OD_BUFFER} -ge 5 ]; then # 5 - length of two hex bytes + space

        prefixDeleteSubstring=${OD_BUFFER#?? ??}                      # # = shortest prefix delete by pattern
        b1b2=${OD_BUFFER%%$prefixDeleteSubstring}                     # %% = largest suffix delete by pattern
        OD_BUFFER=${prefixDeleteSubstring# }
        B2=${b1b2#?? }
        B1=${b1b2%% ??}
        #VALUE_UINT16BE_HEX=$B1$B2
        VALUE_UINT16BE=$(( 0x$B1$B2 ))
    else
      return "$ERROR_EOF_OD_BUFFER"
    fi
}

readUInt8old ()
{
    local prefix

 # IFS=' ' read -r B1 OD_BUFFER << EOB
#$OD_BUFFER
#EOB
prefix=${OD_BUFFER#?? }
B1=${OD_BUFFER%% $prefix}
    VALUE_UINT8_HEX=$B1
    VALUE_UINT8=$(( 0x$B1 ))
}

readUInt16BEold ()
{
    IFS=' ' read -r B1 B2 OD_BUFFER << EOF
$OD_BUFFER
EOF
VALUE_UINT16BE=$(( 0x$B1$B2 ))
}


sendPacketnc ()
#$1 - command
#$2 - host
{
    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
    #shellcheck disable=SC3044
    {
        typeset ncUDPOpt  # UDP (-u) or TCP
        typeset ncIdleOpt
        typeset port
        typeset ncStatus
        typeset host
        typeset timeout_udp_broadcast
        typeset timeout_nc
      }
    else
        local ncUDPOpt # UDP (-u) or TCP
        local ncIdleOpt
        local port
        local ncStatus
        local host
        local timeout_udp_broadcast
        local timeout_nc
    fi

    host=$2
    timeout_nc=0.05
    timeout_udp_broadcast=0.236 # timeout selected based on udp port scanning 254 hosts in 60s (60s/254=0.236s)

    if [ -n "$TIMEOUT_READ" ]; then # allow override via -x option
        timeout_nc=$TIMEOUT_READ
    fi

    if [ -z "$host" ]; then
        host=$HOST #use default host, specfied using -h option
    fi

    #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
    if [ $# -ge 1 ]; then
        newPacketBodynew "$1"
    fi

    createPacketTXnew

    if [ $PACKET_TX_CMD_INT -eq  $CMD_broadcast ]; then
        ncUDPOpt='-u'
        port=$PORT_GW_UDP #change to UDP from TCP default
        timeout_nc=$timeout_udp_broadcast
    elif [ "$PACKET_TX_CMD_INT" -eq $CMD_write_reset ] || [ "$PACKET_TX_CMD_INT" -eq $CMD_write_ssid ]; then
         # some commands needs idle timeout
           #https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching
           # man bash "When  the == and != operators are used, the string to the right of the operator
           #     is considered a pattern and matched according to the rules described below  un‐
           #     der Pattern Matching, as if the extglob shell option were enabled."
          # if ! [[ $KSH_VERSION == *Android* ]]; then
          #    ncIdleOpt='-i 100ms'
          #    [ $DEBUG -eq 1 ] && >&2 echo "${CMD_NAME["$PACKET_TX_CMD_INT"]}" Setting device idle timeout option for nc "$ncIdleOpt"
          # fi
          :
    else
       unset ncUDPOpt
       #1>&2 echo ncUDPOpt $ncUDPOpt
       port=$PORT_GW_TCP

    fi

    # TEST %b: for shell in dash mksh zsh bash; do printf "%10s %b\n" "$shell" "\0100"; done
   # set -x
   # printf "%b" "$PACKET_TX_ECHO" >"$FILENAME_tx" #print to file for debuggging purpose
    #set +x

 # { cat "$FILENAME_tx"; sleep 0.175; } |  $NC_CMD  $ncUDPOpt $ncIdleOpt -w 500ms  -4 "$host" "$port"  >"$FILENAME_rx" # wait 0.1s to disable READ KILL of nc on stdin

    # if timeout is too small, ICMP port unreachable is generated when doing udp port 46000 probing/broadcast
    # udp debugging in wireshark : udp.dstport == 46000 || udp.srcport == 46000
      # shellcheck disable=SC2086
      if [ $NC_VERSION -eq $NC_OPENBSD  ]; then

          PACKET_RX_OD_HEX=$(printf "%b" "$PACKET_TX_ECHO" | timeout $timeout_nc $NC_CMD -4 -N "$host" "$port" | od -A n -t x1 -w$MAX_16BIT_UINT) 

 #        if [ "$ncUDPOpt" != "-u" ]; then

#set -x
#            { cat "$FILENAME_tx"; sleep $timeout_nc; } | $NC_CMD -4 -N "$host" "$port" >"$FILENAME_rx" #-N shutdown socket after EOF on stdin
#             ncStatus=$?
#set +x

#         elif [ "$ncUDPOpt" = "-u" ]; then
#              # set -x
#               nc -4 -u "$host" "$port" <"$FILENAME_tx" >"$FILENAME_rx" &
              # set +x
              # jobs
               #-w only allow >=1s timeout, too slow, must move process to background and kill
#              sleep $timeout_nc
#              kill %1 2>/dev/null
#          fi

      elif [ $NC_VERSION -eq $NC_NMAP ]; then

            { cat "$FILENAME_tx"; sleep $timeout_nc; } | $NC_CMD -4  $ncUDPOpt $ncIdleOpt "$host" "$port" >"$FILENAME_rx"
             ncStatus=$?

      elif [ $NC_VERSION -eq $NC_TOYBOX ]; then

            { cat "$FILENAME_tx"; sleep $timeout_nc; } | $NC_CMD -4  $ncUDPOpt "$host" "$port" >"$FILENAME_rx"
             ncStatus=$?
      fi

    # Fedora 35: use --no-shutdown to continue even if receving EOF on stdin
    # Android : -q Quit SECONDS after EOF on stdin, even if stdout hasn't closed yet" (from nc --help)

#    if [ -s "$FILENAME_rx" ] ; then # -s file exists and not empty

#          if PACKET_RX_OD_HEX=$(od -A n -t x1 -v -w"$(stat -c %s "$FILENAME_rx")" "$FILENAME_rx"); then
             # read -r PACKET_RX_OD_HEX <"$FILENAME_od_hex"
             [ $DEBUG -eq 1 ] &&  >&2 echo  OD HEX "$PACKET_RX_OD_HEX" length "${#PACKET_RX_OD_HEX}"
             parsePacketnew "$PACKET_RX_OD_HEX"
              #parse_od_hex_packet "$PACKET_RX_OD_HEX"
#          else
#            >&2 echo  Error od failed to create hex decoding for packet, error code $?
#          fi

 #   else
 #     #[ $DEBUG -eq 1 ] &&
 #     getCommandName "$PACKET_TX_CMD_INT"
 #     >&2 echo Error nc failed to receive response or empty response for command "$COMMAND_NAME"  in "$timeout_nc" s
 #   fi

    #cleanup files

 #   if [ $DEBUG -eq 0 ]; then
 #       rm "$FILENAME_tx" "$FILENAME_rx" "$FILENAME_od_hex" 2>/dev/null
 #   fi

}

initConfigDir () {

    DIR=$HOME'/.config/gw' # .config subdirectory used for configuration on gnome/linux
    [ -n "$EXTERNAL_STORAGE" ] && DIR=$EXTERNAL_STORAGE # testing in Android 11 adb shell
    [ ! -d "$DIR" ] && mkdir -p -v "$DIR" 1>&2
    [ "$DEBUG" -eq 1 ] && >&2 echo  Configuration directory "$DIR"

    SHELLPID=$$
    FILENAME_tx=$DIR"/txpacket-$SHELLPID"
    FILENAME_rx=$DIR"/rxpacket-$SHELLPID"
    FILENAME_livedata_description=$DIR/'livedata-description.txt'
    FILENAME_od_hex=$DIR/"rxpacket-od-hex-$SHELLPID.txt"

}


 getReadArrayOption ()
{
    if [ -n "$BASH_VERSION" ]; then
           READARRAY_OPTION="-a"
        elif [ -n "$ZSH_VERSION" ] || [ -n "$KSH_VERSION" ]; then
         READARRAY_OPTION="-A"
        fi
}


 #if which socat >/dev/null; then
    #    discovery_socat
    #  else
    #    >&2 echo  Error socat not found, cannot scan for devices
    #    return "$ERROR_NO_SOCAT"
    #  fi


    decToHexnew ()
{
    VALUE_HEX=$( printf "%02x" "$1" )
}

CONVERT_HEXANDOCT_USING_SUBSHELL=0 # 1 - using $( printf "%02x" )



 #n=1
            #listenport="$2"
            #emptyLine=0
            # nc -l -i 0.1 "$listenport" | while [ -z "$http_body" ]; do
            #                                  eval "read -r http_line$n"
            #                                  echo $?
            #                                  if [ "$emptyLine" -eq 1 ]; then
            #                                    eval "http_body=\"\$http_line$n\"" 
            #                                  fi 
            #                                  eval "[ \"\${#http_line$n}\"  -eq 1 ] && emptyLine=1" 
            #                                  eval "echo \"\$http_line$n\""
            #                                  eval "set -- \$http_line$n"
            #                                  if [ "$n" -eq 1 ]; then #start line
            #                                    set -x
            #                                     http_method="$1"
            #                                     http_path="$2"
            #                                     http_version="${3##*/}"  # ## largest prefix pattern removed
            #                                    # http_version="${http_version%%$'\r'}"
            #                                     http_protocol="${3%%/*}" # %% largest suffix pattern removed  
            #                                     set +x
            #                                   fi
            #                                     
            #                                  n=$(( n + 1 ))
            ##                                  #set
            #                              done
            #                           # set +x

 # >&2 echo  Listening for http request on port "$2"
            # eval 'mapfile HTTP_REQUEST < <($NC_CMD -l "$2")'
            # n=0
            # while [ "$n" -lt  ${#HTTP_REQUEST[@]} ]; do
            #   echo "${HTTP_REQUEST[$n]}"
            #   n=$(( n + 1))
            # done
            # shift 2

#quick ecowitt parsing
            #IFS='&' read -a data <<<$(nc  -l 8080 -i 0.1 | tail -n +7) && for f in "${data[@]}"; do echo $f; done
            #set -x
           




convertBufferFromHexToOctalEscape() { #convert from ff ff to \377\377
    #strace: each $( printf ) creates a new process (strace: Process nnnn attached )
    unset VALUE_OCTAL_BUFFER_ESCAPE

    for BYTE in $1; do
        convertHexToOctal "0x$BYTE"
        VALUE_OCTAL_BUFFER_ESCAPE="$VALUE_OCTAL_BUFFER_ESCAPE\\0$VALUE_OCTAL"

    done

    [ $DEBUG -eq 1 ] && echo >&2 "Octal buffer $VALUE_OCTAL_BUFFER_ESCAPE"
}


printKey() {
# $1 - key, $2 - field size, negative for left justify, $3 - append newline

    if [ "$SHELL_SUPPORT_TYPESET" -eq 1 ]; then
    #shellcheck disable=SC3044
        typeset str whitespaceSize whitespaceStr nSpace strlen fsize ljustify
    else
        local str whitespaceSize whitespaceStr nSpace strlen fsize ljustify
    fi

    str="$1"
    strlen=${#str}

    if [ -n "$2" ]; then
    
       if  [ "$2" -lt 0 ]; then # left justify key
          ljustify=1
          fsize=$(( -1 * $2))
       else
        ljustify=0
         fsize=$2
        fi

       FIELD_SIZE_KEY="$fsize" #allow specifying default field size in "$2"
    else
        ljustify=1
        FIELD_SIZE_KEY=$(( strlen + 1 )) # use only 1 space after key
    fi

    #build padding string with spaces
    nSpace=1
    whitespaceSize=$(( FIELD_SIZE_KEY - strlen ))
    while [ "$nSpace" -le "$whitespaceSize" ]; do
        whitespaceStr="$whitespaceStr "
        nSpace=$(( nSpace + 1 ))
    done

    if [ "$ljustify" -eq 1  ]; then 
        str="$str$whitespaceStr"
    else
        str="$whitespaceStr$str"
    fi

    if [ -z "$3" ]; then
       APPEND_STRING=$APPEND_STRING"$str"
    else
        echo "$APPEND_STRING"
        unset APPEND_STRING
    fi 
    
    #[ "$DEBUG" -eq 1 ] &&
    # >&2 echo "${#str}" whitespacestr len "${#whitespaceStr}"

     if [ -n "$KSH_VERSION" ]; then
         unset str whitespaceSize whitespaceStr nSpace strlen fsize ljustify
     fi

}



#aggregated livedata in , format

    if [ -n "$LOG_LIVEDATA"  ]; then
    #IFS=, read ....
        echo "$LIVEDATA_INTEMP,$LIVEDATA_INHUMI,$LIVEDATA_ABSBARO,$LIVEDATA_RELBARO,$LIVEDATA_OUTTEMP,$LIVEDATA_OUTHUMI" > "$DIR_LIVEDATA/baro.csv"
        echo "$LIVEDATA_WINDDIRECTION,$LIVEDATA_WINDDIRECTION_COMPASS,$LIVEDATA_WINDSPEED,$LIVEDATA_WINDGUSTSPEED,$LIVEDATA_WINDDAILYMAX"  > "$DIR_LIVEDATA/wind.csv"
        echo "$LIVEDATA_RAINRATE,$LIVEDATA_RAINEVENT,$LIVEDATA_RAINDAY,$LIVEDATA_RAINWEEK,$LIVEDATA_RAINMONTH,$LIVEDATA_RAINYEAR"  > "$DIR_LIVEDATA/rain.csv"
        echo "$LIVEDATA_LIGHT,$LIVEDATA_UV,$LIVEDATA_UVI" > "$DIR_LIVEDATA/solar.csv"
        echo "$LIVEDATA_TEMP1,$LIVEDATA_HUMI1,$LIVEDATA_TEMP2,$LIVEDATA_HUMI2,$LIVEDATA_TEMP3,$LIVEDATA_HUMI3,$LIVEDATA_TEMP4,$LIVEDATA_HUMI4\
$LIVEDATA_TEMP5,$LIVEDATA_HUMI5,$LIVEDATA_TEMP6,$LIVEDATA_HUMI6,$LIVEDATA_TEMP7,$LIVEDATA_HUMI7,$LIVEDATA_TEMP8,$LIVEDATA_HUMI8" > "$DIR_LIVEDATA/temp.csv"
#shellcheck disable=SC2153
        echo "$LIVEDATA_SOILMOISTURE1,$LIVEDATA_SOILMOISTURE2,$LIVEDATA_SOILMOISTURE3,$LIVEDATA_SOILMOISTURE4\
$LIVEDATA_SOILMOISTURE5,$LIVEDATA_SOILMOISTURE6,$LIVEDATA_SOILMOISTURE7,$LIVEDATA_SOILMOISTURE8" >"$DIR_LIVEDATA/soilmoisture.csv"
        echo "$LIVEDATA_SOILTEMP1,$LIVEDATA_SOILTEMP2,$LIVEDATA_SOILTEMP3,$LIVEDATA_SOILTEMP4\
$LIVEDATA_SOILTEMP5,$LIVEDATA_SOILTEMP6,$LIVEDATA_SOILTEMP7,$LIVEDATA_SOILTEMP8" >"$DIR_LIVEDATA/soiltemp.csv"
        echo "$LIVEDATA_LEAK1,$LIVEDATA_LEAK2,$LIVEDATA_LEAK3,$LIVEDATA_LEAK4" >"$DIR_LIVEDATA/leak.csv"
        #shellcheck disable=SC2153
        echo "$LIVEDATA_PM25_CH1,$LIVEDATA_PM25_24HAVG1,$LIVEDATA_PM25_CH2,$LIVEDATA_PM25_24HAVG2,$LIVEDATA_PM25_CH3,$LIVEDATA_PM25_24HAVG3,$LIVEDATA_PM25_CH4,$LIVEDATA_PM25_24HAVG4" >"$DIR_LIVEDATA/pm25.csv"
        echo "$LIVEDATA_CO2_TEMPF,$LIVEDATA_CO2_HUMI,$LIVEDATA_CO2_PM10,$LIVEDATA_CO2_PM10_24HAVG,$LIVEDATA_CO2_PM25,$LIVEDATA_CO2_PM25_24HAVG,$LIVEDATA_CO2_CO2,$LIVEDATA_CO2_CO2_BATTERYLEVEL" >"$DIR_LIVEDATA/co2.csv"
        echo "$LIVEDATA_LIGHTNING_DISTANCE,$LIVEDATA_LIGHTNING_TIME,$LIVEDATA_LIGHTNING_TIME_UTC,$LIVEDATA_LIGHTNING_POWER" >"$DIR_LIVEDATA/lightning.csv" 
         echo "$LIVEDATA_LEAF_WETNESS_CH1,$LIVEDATA_LEAF_WETNESS_CH2,$LIVEDATA_LEAF_WETNESS_CH3,$LIVEDATA_LEAF_WETNESS_CH4,\
$LIVEDATA_LEAF_WETNESS_CH5,$LIVEDATA_LEAF_WETNESS_CH6,$LIVEDATA_LEAF_WETNESS_CH7,$LIVEDATA_LEAF_WETNESS_CH8" >"$DIR_LIVEDATA/leaf_wetness.csv"
   
    fi




initSearchPatternForCommand() {
    if argEmptyOrOption "$1" || [ "$1" = "*" ]; then
        SPATTERN='.*' #add default search for any pattern
    else
        toLowercase "$1"
        SPATTERN=$LOWERCASE
    fi
}
    
 -r | --restore)

            # unset CONFIGURATION
            # unset CONFIGURAITION_INDEX
            # unset CONFIGURATION_SENSOR
            # unset CONFIGURATION_SENSOR_UPDATE_INDEX
            # unset CONFIGURATION_SENSOR_INDEX
            # typeset -a CONFIGURATION
            # typeset -a CONFIGURATION_SENSOR
            # typeset -a CONFIGURATION_SENSOR_UPDATE_INDEX # sensor types that needs update/write
            # typeset -a CONFIGURATION_SENSOR_INDEX

            # if [ -s "$2" ]; then
            #   IFS=' '
            #   #shellcheck disable=SC2034
            #   while read -r K V DISCARD; do
            #     unset CONFIGURATION_INDEX
            #     STYPE=$(expr "$K" : "$CONFIGURATION_SENSORFIELD\([0-9]*\)" ) # extracts number part from sensortype_{number}
            #     if [ -n "$STYPE" ]; then
            ##       setConfigurationSensor "$STYPE" "$V"
            #     else
            #        getConfigurationIndexFromName "$K"
            #        if [ -n "$CONFIGURATION_NAME_INDEX" ]; then
            #         [ "$DEBUG" -eq 1 ] && >&2 echo  "$K" "Configuration[$CONFIGURATION_NAME_INDEX]=$V"
            #          setConfiguration $CONFIGURATION_NAME_INDEX "$V"
            #        fi
            #     fi
            #
            #   done < "$2"

            #   printConfiguration >&2

            #   sendEcowittInterval "${CONFIGURATION[$CONF_ecowitt_interval]}"
            #   sendWeatherservice "$CMD_WRITE_WUNDERGROUND" "${CONFIGURATION[$CONF_wunderground_id]}" "${CONFIGURATION[$CONF_wunderground_password]}"
            #   sendWeatherservice "$CMD_WRITE_WOW"          "${CONFIGURATION[$CONF_wow_id]}"          "${CONFIGURATION[$CONF_wow_password]}"
            ##   sendWeatherservice "$CMD_WRITE_WEATHERCLOUD" "${CONFIGURATION[$CONF_weathercloud_id]}" "${CONFIGURATION[$CONF_weathercloud_password]}"
            #  sendCustomized
            #   sendRaindata "${CONFIGURATION[$CONF_raindaily]}" "${CONFIGURATION[$CONF_rainweek]}" \
            #                 "${CONFIGURATION[$CONF_rainmonth]}" "${CONFIGURATION[$CONF_rainyear]}"
            #   sendSensorId
            #   sendCalibration "${CONFIGURATION[$CONF_calibration_intempoffset]}" "${CONFIGURATION[$C_CALIBRATION_INHUMIDITYOFFSET]}" \
            #                   "${CONFIGURATION[$CONF_calibration_absoffset]}" "${CONFIGURATION[$CONF_calibration_reloffset]}" \
            #                   "${CONFIGURATION[$CONF_calibration_outtempoffset]}" "${CONFIGURATION[$CONF_calibration_outhumidityoffset]}" \
            #                   "${CONFIGURATION[$CONF_calibration_windiroffset]}"

            #     shift 2

            # elif [ -z "$2" ]; then

            #   >&2 echo Error no backup file specified
            #    shift
            # else
            #   >&2 echo Error "$2 does not exists or is empty";
            #   shift 2
            # fi

            ;;



    
        -n | --notifyrain)
            runRainNotification "$2" "$3" #tested on GNOME
            shift 3
            ;;



 -b | --backup)

            #https://tldp.org/LDP/abs/html/x17974.html
             "$FD_STDOUT_DUP">&1
            exec >/dev/null

            sendPacket $CMD_READ_MAC
            sendPacket $CMD_READ_VERSION
            sendPacket $CMD_BROADCAST

            printWeatherServices

            sendPacket $CMD_READ_PATH
            sendPacket $CMD_READ_RAINDATA
            sendPacket $CMD_READ_SENSOR_ID_NEW
            sendPacket $CMD_READ_CALIBRATION

            exec 1>&"$FD_STDOUT_DUP" "$FD_STDOUT_DUP">&-

            # some data probably saved to device EEPROM
            # TODO? calibration data?
            if [ -n "$2" ]; then #save to file
                printConfiguration >"$2"
                shift 2
            else
                printConfiguration #or just stdout
                shift 
            fi
            ;;



            


    