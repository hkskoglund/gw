#!/bin/bash
# example ./gw -s 
# scan for devices
# example ./gw -h 10.42.0.180 -c mac
# read mac
# Info  from https://www.xmodulo.com/tcp-udp-socket-bash-shell.html
# Writing CMD_BROADCAST 0x12 to HOST port 46000
# https://brendanzagaeski.appspot.com/0006.html - hexdump examples
#Protocol documentation : https://osswww.ecowitt.net/uploads/20210716/WN1900%20GW1000,1100%20WH2680,2650%20telenet%20v1.6.0%20.pdf (https://www.ecowitt.com/shop/forum/forumDetails/255)
#https://devhints.io/bash

#for debugging
#echo PID "$$"
#read -r -p "DEBUG - press key to continue"

HTTP_UA_NAME="gw ShellScript"
HTTP_FIRMWARE="http://download.ecowitt.net/down/filewave?v=FirwaveReadme.txt"

declare -i DEBUG
DEBUG=0

declare -A DEBUG_OPTIONS
DEBUG_OPTIONS[socat]='-d -d -x'
DEBUG_OPTIONS[dd]='status=none'

declare -A PORT

PORT[tcp_command_server]=45000
PORT[udp_discovery_server]=59387
PORT[udp_discovery_client]=46000

declare -A CMD

CMD[read_version]=0x50
CMD[reboot]=0x40
CMD[read_mac]=0x26
CMD[read_wunderground]=0x20
CMD[read_ecowitt]=0x1e

CMD[read_customized]=0x2a
CMD[write_customized]=0x2b
CMD[read_path]=0x51
CMD[write_path]=0x52

CMD[write_ssid]=0x11
CMD[broadcast]=0x12
CMD[write_reset]=0x41

CMD[read_raindata]=0x34
CMD[write_raindata]=0x35

# PACKET BODY STARTING AT BYTE 2
PACKET_BODY=()

#CONNECT ERRORS
ERROR_CONNECTION=1
#ERROR_READ_RESPONSE=3

declare -A FILENAME

DIR=$HOME'/.config/gw'
mkdir "$DIR" 2>/dev/null

FILENAME[tx]=$DIR'/txpacket'
FILENAME[rx]=$DIR'/rxpacket'
FILENAME[discovery]=$DIR'/rxsocat'
FILENAME[discovery_sorted]=$DIR/'rxsocat_sorted'
FILENAME[udp_server]="${FILENAME[discovery]}"_UDP_"${PORT[udp_discovery_server]}"
FILENAME[udp_client]="${FILENAME[discovery]}"_UDP_"${PORT[udp_discovery_client]}"

declare -A CONFIGURATION


function connect {

local host="$1"

 if [ -v FD_TCP ] || [ -v FD_UDP ]; then # True if the shell variable varname is set (has been assigned a value). - man bash
    (( DEBUG )) && echo >&2 "$HOST_PREV closing connection"
    disconnect
  fi

  #https://www.gnu.org/software/bash/manual/bash.html - 3.6 Redirections
   if exec {FD_UDP}<>/dev/udp/"$host"/"${PORT[udp_discovery_client]}"; then
     (( DEBUG )) && echo  >&2 "$host:${PORT[udp_discovery_client]} Connected (UDP FD $FD_UDP)"
   else
     return $ERROR_CONNECTION
   fi

  if exec {FD_TCP}<>/dev/tcp/"$host"/"${PORT[tcp_command_server]}"; then
    (( DEBUG )) && echo >&2 "$host:${PORT[tcp_command_server]} Connected (TCP FD $FD_TCP)"
  else
    return $ERROR_CONNECTION
  fi

  #Current shell PID $$

  if (( DEBUG ));  then
    netstat -tunp | grep "$$"; 
  fi

  [ -v FD_TCP ] &&  [ -v FD_UDP ]

}

function disconnect {
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
  #close sockets
   if [ -v FD_UDP ]; then 

     if ! exec {FD_UDP}>&-; then >&2 echo Failed to close $FD_UDP; fi
     (( DEBUG )) && >&2 echo "Closing FD $FD_UDP (UDP)"

     unset FD_UDP
   fi

  if [ -v FD_TCP ]; then

    if ! exec {FD_TCP}>&-; then >&2 echo Failed to close $FD_TCP; fi
    (( DEBUG )) && >&2 echo "Closing FD $FD_TCP (TCP)"

    unset FD_TCP
  fi
}

function getCommandName
{
  for name in "${!CMD[@]}"; do # ${!array} iterate over keys
    if (( ${CMD[$name]} == $1 )); then
      echo $name
      #return 0
    fi
  done
  return 1
}

function parseResultPacket {
  local cmd="0x${PACKET_RX[2]}"
  
  STATUS=0x${PACKET_RX[4]}
  echo -n >&2 "$(getCommandName "$cmd")" "$STATUS"
  if ((STATUS == 0)); then
    echo >&2 " OK"
  elif ((STATUS == 1)); then
    echo >&2 " FAIL"
  else
    echo >&2 -e '\n'
  fi
}

function printCustomized {
  echo "customized_id ${CONFIGURATION[customized_id]}"
  echo "customized_password ${CONFIGURATION[customized_password]}"
  echo "customized_server ${CONFIGURATION[customized_server]}"
  echo "customized_port ${CONFIGURATION[customized_port]}"
  echo "customized_interval ${CONFIGURATION[customized_interval]}"

  if ((CONFIGURATION[customized_type] == 1)); then
    echo "customized_type 1 Wunderground"
  elif ((CONFIGURATION[customized_type] == 0)); then
    echo "customized_type 0 Ecowitt "
  else
    echo "customized_type ${CONFIGURATION[customized_type]}" "UNKNOWN"
  fi

  if ((CONFIGURATION[customized_enabled] == 1)); then
    echo "customized_enabled 1 ON"
  elif ((CONFIGURATION[customized_enabled] == 0)); then
    echo "customized_enabled 0 OFF"
  else
    echo "customized_enabled ${CONFIGURATION[customized_enabled]} UNKNOWN"
  fi

  echo "customized_ecowitt_path ${CONFIGURATION[customized_ecowitt_path]}"
   
  echo "customized_wunderground path ${CONFIGURATION[customized_wunderground_path]}"
}

function dumpConfiguration
{
  #echo "${!CONFIGURATION[@]}"
  #https://www.artificialworlds.net/blog/2012/10/17/bash-associative-array-examples/
  for K in "${!CONFIGURATION[@]}"; do printf "%-30s %s\n" "$K" "${CONFIGURATION[$K]}"; done
}

function echoBroadcastConfiguration
{
    echo "${CONFIGURATION[broadcast_mac]} ${CONFIGURATION[broadcast_ip]}:${CONFIGURATION[broadcast_port]} ${CONFIGURATION[broadcast_ssid]} ${CONFIGURATION[broadcast_version]}"
}

function readUInt32BE
{
#  echo Parameter $1 "0x${PACKET_RX_HEX:$1:8}" 
  printf "%d" "0x${PACKET_RX_HEX:$1:8}"
}


function printRain
{
   echo -n rainrate "${CONFIGURATION[rainrate]} "
   echo -n rainday "${CONFIGURATION[rainday]} "
   echo -n rainweek "${CONFIGURATION[rainweek]} "
   echo -n rainmonth "${CONFIGURATION[rainmonth]} "
   echo  rainyear "${CONFIGURATION[rainyear]}"
   
}

function parsePacket {
  local cmd
  local pos=4

  cmd=0x${PACKET_RX[2]}

  #Packet length
  case $cmd in
  "${CMD[broadcast]}")
    lsb=${PACKET_RX[4]}
    msb=${PACKET_RX[3]}
    PACKET_LENGTH=$(((0x$msb << 8) | 0x$lsb))
    ;;
  *)
    PACKET_LENGTH=${PACKET_RX[3]}
    ;;
  esac

  (( DEBUG )) && echo >&2 "Parse packet ${PACKET_RX[*]} length $PACKET_LENGTH"

  case $cmd in
  "${CMD[write_reset]}" | "${CMD[write_customized]}" | "${CMD[reboot]}" | "${CMD[write_path]}" | "${CMD[write_ssid]}" | "${CMD[write_raindata]}")
    parseResultPacket
    ;;
  "${CMD[read_mac]}")
    CONFIGURATION[mac]=$(printf "%02X:%02X:%02X:%02X:%02X:%02X"  0x"${PACKET_RX[4]}" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}")
    echo  "${CONFIGURATION[mac]}"
    ;;
  "${CMD[read_version]}")
    CONFIGURATION[version]=${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}
    echo "${CONFIGURATION[version]}"
    ;;
  "${CMD[read_ecowitt]}")
    CONFIGURATION[ecowitt_interval]=$(( "${PACKET_RX[$pos]}" ))
    echo  "ecowitt_interval ${CONFIGURATION[ecowitt_interval]} minutes"
    ;;
  "${CMD[read_wunderground]}")
    CONFIGURATION[wunderground_id]=${PACKET_RX_OD[1]:(( $pos + 1 )):0x${PACKET_RX[$pos]}};      (( pos=pos+${#CONFIGURATION[wunderground_id]}+1 ))
    CONFIGURATION[wunderground_password]=${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}; (( pos=pos+${#CONFIGURATION[wunderground_password]}+1 ))
    echo  "wunderground_id ${CONFIGURATION[wunderground_id]}"
    echo  "wunderground_password ${CONFIGURATION[wunderground_password]}"
    ;;
  "${CMD[read_customized]}")
    
    CONFIGURATION[customized_id]=${PACKET_RX_OD[1]:(( $pos + 1 )):0x${PACKET_RX[$pos]}};      (( pos=pos+${#CONFIGURATION[customized_id]}+1 ))
    CONFIGURATION[customized_password]=${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}; (( pos=pos+${#CONFIGURATION[customized_password]}+1 ))
    CONFIGURATION[customized_server]=${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}};   (( pos=pos+${#CONFIGURATION[customized_server]}+1 ))
    #http://mywiki.wooledge.org/ArithmeticExpression

    CONFIGURATION[customized_port]=$((     ( 0x${PACKET_RX[-7]} << 8) | 0x${PACKET_RX[-6]} ))
    CONFIGURATION[customized_interval]=$(( ( 0x${PACKET_RX[-5]} << 8) | 0x${PACKET_RX[-4]} ))
    CONFIGURATION[customized_type]=$((       0x${PACKET_RX[-3]} ))
    CONFIGURATION[customized_enabled]=$((    0x${PACKET_RX[-2]} ))

    printCustomized
    ;;
  "${CMD[read_path]}")
   
    CONFIGURATION[customized_ecowitt_path]=${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}; (( pos=pos+${#CONFIGURATION[customized_ecowitt_path]}+1 ))
    CONFIGURATION[customized_wunderground_path]=${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}; (( pos=pos+${#CONFIGURATION[customized_wunderground_path]}+1 ))
     ;;

  "${CMD[broadcast]}")

        CONFIGURATION[broadcast_mac]=$(printf "%02X:%02X:%02X:%02X:%02X:%02X\n" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}" 0x"${PACKET_RX[10]}")
        CONFIGURATION[broadcast_ip]=$(printf "%d.%d.%d.%d" 0x"${PACKET_RX[11]}" 0x"${PACKET_RX[12]}" 0x"${PACKET_RX[13]}" 0x"${PACKET_RX[14]}")
        pos=17
        local ssid
        local version
        IFS=' '; read -r ssid version <<< "${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}" # ssid appends space+version
        CONFIGURATION[broadcast_ssid]=$ssid
        CONFIGURATION[broadcast_version]=$version
        CONFIGURATION[broadcast_port]=$(printf "%d" 0x"${PACKET_RX[15]}""${PACKET_RX[16]}")
        echoBroadcastConfiguration

    ;;

    "${CMD[read_raindata]}")
      CONFIGURATION[rainrate]=$(readUInt32BE 8)
      CONFIGURATION[rainday]=$(readUInt32BE  8*2)
      CONFIGURATION[rainweek]=$(readUInt32BE 8*3)
      CONFIGURATION[rainmonth]=$(readUInt32BE 8*4)
      CONFIGURATION[rainyear]=$(readUInt32BE 8*5)
      
      printRain
      ;;
  *)
    >&2 echo Warning unable to parse command "$cmd"
    ;;

  esac
}

function newPacketBody {
  PACKET_BODY=()
  PACKET_BODY+=("$1" "0x00")
  case "$1" in
  "${CMD[broadcast]}"|"${CMD[write_ssid]}") # WSVIEW sends 2 byte field for size
    PACKET_BODY+=("0x00")
    ;;
  esac

  # [ -n "$1" ] &&  PACKET_BODY+=("0x00")  # Append for two byte packet length
}
function createPacketTX {
  local packetLengthLSB
  local packetLengthMSB
  local n

  #Update packet length, either 1 or 2 bytes
  case ${PACKET_BODY[0]} in 
  "${CMD[write_ssid]}" | "${CMD[broadcast]}")
    packetLengthLSB=$(((${#PACKET_BODY[@]} + 1) & 0xff))
    packetLengthMSB=$((((${#PACKET_BODY[@]} + 1) & 0xff00) >> 8))
    PACKET_BODY[1]=$(decToHex $packetLengthMSB)
    PACKET_BODY[2]=$(decToHex $packetLengthLSB)
    ;;
  *)
    PACKET_BODY[1]=$(decToHex $((${#PACKET_BODY[@]} + 1))) # set packet length including checksum byte
    ;;
  esac

  checksum

  PACKET_TX=(0xff 0xff "${PACKET_BODY[@]}" "$CHECKSUM")

  (( DEBUG )) && echo >&2 PACKET_TX "${PACKET_TX[@]//0x/''}"

  PACKET_TX_ECHO=''
  for n in "${!PACKET_TX[@]}"; do
    PACKET_TX_ECHO+=${PACKET_TX[$n]}
  done
  PACKET_TX_ECHO=${PACKET_TX_ECHO//0x/'\x'}

   (( DEBUG )) && echo >&2 PACKET_TX_ECHO "$PACKET_TX_ECHO"

}

function readResponseCat
{
   local timeoutCat=0.025 # Wireshark [Time delta from previous captured frame: 0.013166760 seconds]
#   (( DEBUG )) && timeoutOptions='-v'
# cat inside while (true) { continue read }
#https://github.com/coreutils/coreutils/blob/bbb19b18687d5572dcbe7bbb1a48c8ee0f21786b/src/cat.c#L168
# Actually response is read in the first call to read, then a second read is started on stdin/redirected FD, so cat has to be killed...
 # timeout "$timeoutOptions"--preserve-status $timeoutCat cat <&"$FD" >$FILENAME_RESPONSE
 cat <&"$FD" >"${FILENAME[rx]}" &
 sleep $timeoutCat
 kill %1
}

function readResponseDD
{
  (( DEBUG )) && unset "DEBUG_OPTIONS[dd]"
    # shellcheck disable=SC2086
  if ! dd bs=1024 count=1 ${DEBUG_OPTIONS[dd]} <&"$FD" >${FILENAME[rx]}; then
    echo >&2 Error DD failed to read response from FD "$FD"
  fi

}

#including checksum byte
function sendPacket {
   local n
   local i
   local hex_od
  #local response_hexdump
  
  local FD=$FD_TCP # default TCP command port

  [ -n "$2" ] && FD="$2" #may also use UDP for broadcast (ssid etc.)
  if [ ! -v FD ]; then
   >&2 echo Error connection to host not available, missing -h to host? 
    exit $ERROR_CONNECTION
  fi

  (( DEBUG )) && echo >&2 "Using FD $FD for sending packet"

  #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
  if [  $# -ge 1 ] ; then
    newPacketBody "$1"
  fi

  # write command/read response

  createPacketTX
  echo -ne "$PACKET_TX_ECHO" >"${FILENAME[tx]}"
  cat "${FILENAME[tx]}" >&"$FD" # echo -ne splits packet at 0x0a

  #readResponseCat
  unset PACKET_RX
  unset PACKET_RX_HEX
  unset PACKET_RX_OD
  readResponseDD
  

  #Copy response to byte array in hex ff ff .. .. ..
  #response_hexdump=$(hexdump -v -e '/1 "%02x "' ${FILENAME[rx]}) #a NUL termination is inserted for string, must be deleted
  #PACKET_RX_HEX=$(hexdump -v -e '/1 "%02x"' "${FILENAME[rx]}")
  SHELLIFS=$IFS
  IFS='>'; read -r -a PACKET_RX_OD  < <(od -A n -t x1z -v -w"$(stat -c %s "${FILENAME[rx]}")" "${FILENAME[rx]}")
  (( DEBUG )) && >&2 echo OD 0 "${PACKET_RX_OD[0]}"
  (( DEBUG )) && >&2 echo OD 1 "${PACKET_RX_OD[1]}"
  hex_od=${PACKET_RX_OD[0]}
  PACKET_RX_HEX=${hex_od// /} # remove all spaces
 
  if (( ${#PACKET_RX_HEX} == 0 )); then
  
     >&2 echo "$HOST Warning no response received from host" 
  else
    {
      #(( ! DEBUG)) && rm "${FILENAME[rx]}"
      #response_hexdump=${response_hexdump::-1}
      #mapfile -d ' ' -t PACKET_RX <<< "$response_hexdump"
      for ((n=0,i=0;n<${#PACKET_RX_HEX}; n=n+2,i++)); do
       PACKET_RX[$i]=${PACKET_RX_HEX:$n:2}
      done

      (( DEBUG )) && echo >&2 PACKET RX OD && od -t x1z -v "${FILENAME[rx]}"

       parsePacket
    }
  fi

}

function discovery {
  local TIMEOUT_SCAN=1 #seconds

  local rxscan
  local rxscan_sorted
  local n
  local socat_discovery_server_pid

  (( ! DEBUG)) && unset "DEBUG_OPTIONS[socat]"

  (( DEBUG )) && echo >&2 "UDP discovery on GW port "${PORT[udp_discovery_client]}
  (( DEBUG )) && echo >&2 "UDP discovery on local port "${PORT[udp_discovery_server]}
  # shellcheck disable=SC2086
  socat $SOCAT_DEBUG_OPTIONS -u UDP-RECV:"${PORT[udp_discovery_server]}" CREATE:${FILENAME[udp_server]} &
  socat_discovery_server_pid=$!
  (( DEBUG )) && echo  >&2 Socat discovery server PID = $socat_discovery_server_pid

  newPacketBody ${CMD[broadcast]}
  createPacketTX
   #-R socat appends to file
   # shellcheck disable=SC2086
   { echo -ne "$PACKET_TX_ECHO"; sleep $TIMEOUT_SCAN; } | socat $SOCAT_DEBUG_OPTIONS -R "${FILENAME[udp_client]}"  - udp-datagram:255.255.255.255:${PORT[udp_discovery_client]},broadcast >/dev/null #disable stdout echo of rx data, sleep timeout EOF on STDIN
  # $PACKET_TX_ECHO is also copied over to $filename_udp, strange behavior of socat?
  #(echo -ne "\xff\xff\x12\x00\x04\x16"; sleep 3) | socat -d -d -x -R rxsocat  - udp-datagram:255.255.255.255:46000,broadcast
  kill $socat_discovery_server_pid

  cat "${FILENAME[udp_client]}" "${FILENAME[udp_server]}" >"${FILENAME[discovery]}" # Merge results from udp/tcp discovery
  rxscan=$(hexdump -v -e '/1 "%02x"' "${FILENAME[discovery]}")
  (( DEBUG )) && echo Keeping files in "$PWD" "${FILENAME[discovery]}" "${FILENAME[udp_client]}" "${FILENAME[udp_server]}"
  (( ! DEBUG )) && rm "${FILENAME[discovery]}" "${FILENAME[discovery_sorted]}" "${FILENAME[udp_client]}" "${FILENAME[udp_server]}"

  #result_sorted=$(echo -en ${result//"ff ff"/"\nff ff"} | sort -u)
  rxscan_sorted=$(echo -en "${rxscan//"ffff"/"\nffff"}" | sort -u)
  (( DEBUG )) && echo -n "$rxscan_sorted" >"${FILENAME[discovery_sorted]}"

  while read -r line; do
    if [[ "${line:0:4}" == ffff && ${line:0:12} != "ffff12000416" ]]; then # Skips first line which is a broadcast (0x12) command
      for ((n = 0, i=0; n < ${#line}; n = n + 2, i++)); do
        PACKET_RX[$i]=${line:$n:2}
      done
      parsePacket
    fi
  done <<< "$rxscan_sorted"
  
}

function checksum {
  local n
  #caller 0
  CHECKSUM=0
  (( DEBUG )) && echo >&2 CHECKSUM PACKET_BODY "${PACKET_BODY[@]}"
  #http://mywiki.wooledge.org/BashGuide/Arrays
  #for ((n = 0; n < ${#PACKET_BODY[@]}; n++)); do
   for n in  "${!PACKET_BODY[@]}"; do
    CHECKSUM=$(( (CHECKSUM + ${PACKET_BODY[$n]}) & 0xff ))
  done
   CHECKSUM=$(decToHex $CHECKSUM)
  (( DEBUG )) && echo >&2 CHECKSUM "$CHECKSUM"
}

function writeString {
  local n

  PACKET_BODY+=("$(decToHex ${#1})")
  for ((n = 0; n < ${#1}; n++)); do
    PACKET_BODY+=("$(decToHex "'${1:$n:1}")")
  done
}

function writeUInt32BE {
  writeUInt 32 "$1"
}
function writeUInt16BE {
  writeUInt 16 "$1"
}

function writeUInt8 {
 writeUInt 8 "$1"
}

function writeUInt {
  local hex

  case $1 in
     8) hex=$(printf "%02x" "$2") ;;
    16) hex=$(printf "%04x" "$2") ;;
    32) hex=$(printf "%08x" "$2") ;;
  esac

  for ((n=0;n<${#hex};n=n+2)); do
    PACKET_BODY+=( 0x"${hex:$n:2}" )
  done;
}

function decToHex {
  printf "0x%02x" "$1"
}

function newCustomizedPacket {
  newPacketBody ${CMD[write_customized]}
  writeString "${CONFIGURATION[customized_id]}"
  writeString "${CONFIGURATION[customized_password]}"
  writeString  "${CONFIGURATION[customized_server]}"
  writeUInt16BE "${CONFIGURATION[customized_port]}"
  writeUInt16BE "${CONFIGURATION[customized_interval]}"
  writeUInt8    "${CONFIGURATION[customized_type]}"
  writeUInt8    "${CONFIGURATION[customized_enabled]}"
}

function newPathPacket {
  newPacketBody ${CMD[write_path]}
  writeString "${CONFIGURATION[customized_wunderground_path]}"
  writeString "${CONFIGURATION[customized_ecowitt_path]}"
}

function updateCustomized {
  local needUpdate
  local key_value
  local value
  local key
  local n

  newPacketBody ${CMD[read_customized]} # read previous configuration
  sendPacket

  newPacketBody ${CMD[read_path]}
  sendPacket

  #format enabled=1,port=8000,server=test.no
  readarray -d ',' -t OPTION_CUSTOMIZED <<< "$1"

  for n in "${!OPTION_CUSTOMIZED[@]}"; do

    readarray -d '=' -t key_value <<< "${OPTION_CUSTOMIZED[$n]}"

    key=${key_value[0]}
    value=${key_value[1]}

    case "$key" in

    id)
       if [ "${CONFIGURATION[customized_id]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_id from "${CONFIGURATION[customized_id]} to $value"
         CONFIGURATION[customized_id]=$value
         needUpdate=1
      fi
      ;;
    password)
       if [ "${CONFIGURATION[customized_password]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_password from "${CONFIGURATION[customized_password]} to $value"
         CONFIGURATION[customized_password]=$value
         needUpdate=1
      fi
      ;;

    server)
      if [ "${CONFIGURATION[customized_server]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_server from "${CONFIGURATION[customized_server]} to $value"
         CONFIGURATION[customized_server]=$value
         needUpdate=1
      fi
      ;;

    port)
     
      if [ "${CONFIGURATION[customized_port]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_type from "${CONFIGURATION[customized_port]} to $value"
         CONFIGURATION[customized_port]=$value
         needUpdate=1
      fi
      ;;

    type)
      if [ "${CONFIGURATION[customized_type]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_type from "${CONFIGURATION[customized_type]} to $value"
         CONFIGURATION[customized_type]=$value
         needUpdate=1
      fi
      ;;

    enabled)
      if [ "${CONFIGURATION[customized_enabled]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_enabled from "${CONFIGURATION[customized_enabled]} to $value"
         CONFIGURATION[customized_enabled]=$value
         needUpdate=1
      fi
      ;;

    interval)
      if [ "${CONFIGURATION[customized_interval]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_interval from "${CONFIGURATION[customized_interval]} to $value"
         CONFIGURATION[customized_interval]=$value
         needUpdate=1
      fi
      ;;
    wunderground_path)
      if [ "${CONFIGURATION[customized_wunderground_path]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_wunderground_path from "${CONFIGURATION[customized_wunderground_path]} to $value"
         CONFIGURATION[customized_wunderground_path]=$value
         needUpdate=1
      fi
       ;;
    ecowitt_path)
      if [ "${CONFIGURATION[customized_ecowitt_path]}" != "$value" ]; then
         (( DEBUG )) && echo >&2 Update customized_ecowitt_path from "${CONFIGURATION[customized_ecowitt_path]} to $value"
         CONFIGURATION[customized_ecowitt_path]=$value
         needUpdate=1
      fi
       ;;
     
    *)
      echo updateCustomized: unknown key "$key" value: "$value"
      ;;
    esac

  done

  #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash
  if ((needUpdate == 1)); then
    newCustomizedPacket
    sendPacket

    newPathPacket
    sendPacket
    
    printCustomized
  fi
}


#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
POSITIONAL=()

while [[ $# -gt 0 ]]; do
  key="$1"
  
  case $key in
  -a | --rain)
      newPacketBody ${CMD[write_raindata]}
      (( DEBUG )) && >&2 echo rainday "$2" rainweek "$3" rainmonth "$4" rainyear "$5"
      writeUInt32BE "$2" #rainday
      writeUInt32BE "$3" #rainweek
      writeUInt32BE "$4" #rainmonth
      writeUInt32BE "$5" #rainmonth
      sendPacket
      shift
      shift
      shift
      shift
      shift
      ;;
  -b | --backup)
      sendPacket ${CMD[read_mac]} >/dev/null
      sendPacket ${CMD[read_version]} >/dev/null
      sendPacket ${CMD[read_ecowitt]} >/dev/null
      sendPacket ${CMD[read_wunderground]} >/dev/null
      sendPacket ${CMD[read_customized]} >/dev/null
      sendPacket ${CMD[read_path]} >/dev/null
      dumpConfiguration
      shift
     ;;
  -d | --debug)
    DEBUG=1
    echo >&2 "${FILENAME[@]}"
    shift
    ;;
  -h | --host)
    HOST_PREV=$HOST
    HOST="$2" # this arg must come first to open socketsopen file descriptors to UDP/TCP port on HOST
    
    if ! connect "$2"; then
      >&2 echo "$HOST" "Error Failed to connect host $2, exiting"
      disconnect
      exit $ERROR_CONNECTION 
    fi
    CONFIGURATION[host]=$HOST
    shift
    shift 
    ;;
  -c | --command)
    COMMAND="$2"
  
    shift
    shift
    ;;
  -s | --scan)
    discovery
    shift
    ;;
  -u | --update)
    updateCustomized "$2"
    shift
    shift
    ;;
   -w | --wifi)
    newPacketBody ${CMD[write_ssid]}
    #ssid packet has two byte length
    # TEST wsview android app, wireshark: ffff | 11 |001b| 08536b6f676c756e640d6c756775626572313934322d2e | a9
    #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/ConfigrouterFragment.java - SaveData
    writeString "$2" # ssid
    writeString "$3" # password
    sendPacket
    shift
    shift
    ;;
  -f | --firmware)
    curl --silent --show-error --user-agent "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
    shift
    shift
    ;;
  -l | --listen)
    >&2 echo  Listening on port "$2"
    mapfile HTTP_RESPONSE <<<"$(nc -l "$2")"
    for ((n = 0; n < ${#HTTP_RESPONSE[@]}; n++)); do
      echo "${HTTP_RESPONSE[$n]}"
    done
    shift
    shift
    ;;
    # Wunderground
    #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
    #Accept: */*
    #Host: 192.168.3.174
    #Connection: Close

    # Ecowitt
    #POST /ecowitt HTTP/1.1
    #HOST: 192.168.3.174
    #Connection: Close
    #Content-Type: application/x-www-form-urlencoded
    #Content-Length:591
    #
    #PASSKEY=976D09F15C41FD8DC6E9A9E8C4F39707&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro
    #
  *)                   # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift              # past argument
    ;;
  esac

  case $COMMAND in
  reset)

    sendPacket ${CMD[broadcast]} $FD_UDP
    read  -r -p "Are you sure to reset ${CONFIGURATION[broadcast_mac]} ${CONFIGURATION[broadcast_ip]}, maybe perform configuration backup first (Y/N)? "
    case $REPLY in 
      Y) sendPacket ${CMD[write_reset]}
      #BROADCAST annoncing GW1000A-WIFI4EC, but after reset GW1000-WIFI4EC is annonced (without A?)
      echo 'Fedora sudo nmcli dev wifi rescan; sudo nmcli dev wifi list | grep '"${CONFIGURATION[broadcast_ssid]:0:4}"
      echo "Fedora sudo nmcli connect {ssid}"
      ;;
    esac
    ;;
  reboot)
    sendPacket "${CMD[reboot]}"
    ;;
  mac)
    sendPacket "${CMD[read_mac]}"
    ;;
  version)
    sendPacket ${CMD[read_version]}
    ;;
  ecowitt)
    sendPacket ${CMD[read_ecowitt]}
    ;;
  wunderground)
    sendPacket ${CMD[read_wunderground]}
    ;;
  customized)
    sendPacket ${CMD[read_path]}
    sendPacket ${CMD[read_customized]}
    ;;
  broadcast)
    sendPacket ${CMD[broadcast]} $FD_UDP
    ;;
  rain)
    sendPacket ${CMD[read_raindata]}
    ;;
  esac

  unset COMMAND

done

set -- "${POSITIONAL[@]}" # restore positional parameters

disconnect

##echo CMD_BROADCAST
#command '\x12\x00\x04\x15' $FD_UDP
#https://unix.stackexchange.com/questions/612193/socat-send-a-udp-broadcast-from-stdin-but-handling-responses-with-system
#echo -ne "\xff\xff\x12\x00\x04\x16" | socat -d -d -x -t 1 - udp-datagram:255.255.255.255:46000,broadcast
