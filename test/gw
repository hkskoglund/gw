#!/bin/bash
#!/usr/bin/ksh
#!/usr/bin/zsh
#setopt KSH_ZERO_SUBSCRIPT 2>/dev/null
emulate ksh 2>/dev/null # for zsh
# Utility for administration of GW-1000 configuration
# example ./gw -s
# scan for devices
# example ./gw -h 10.42.0.180 -c mac
# read mac

#Protocol documentation : https://osswww.ecowitt.net/uploads/20210716/WN1900%20GW1000,1100%20WH2680,2650%20telenet%20v1.6.0%20.pdf (https://www.ecowitt.com/shop/forum/forumDetails/255)
#https://devhints.io/bash

#for debugging
#echo PID "$$"
#read -r -p "DEBUG - press key to continue"

SHELLIFS=$IFS

#https://stackoverflow.com/questions/29968096/get-android-os-version-of-device-connected-via-adb
#testing purpose
#if which getprop 2>/dev/null ; then
#   ANDROID_BUILD_VERSION=$(getprop ro.build.version.release)
#   printenv
#fi

typeset -i DEBUG
DEBUG=0

DEBUG_OPTIONS_dd='status=none'

typeset -ir PORT_tcp_command_server=45000
typeset -ir PORT_udp_discovery_server=59387
typeset -ir PORT_udp_discovery_client=46000

typeset -a CMD_NAME

typeset -ir CMD_read_version=0x50; 
typeset -ir CMD_reboot=0x40;
typeset -ir CMD_read_mac=0x26; 
typeset -ir CMD_write_ssid=0x11; 
typeset -ir CMD_broadcast=0x12; 
typeset -ir CMD_write_reset=0x41; 

#weather services
typeset -ir CMD_read_ecowitt_interval=0x1e; 
typeset -ir CMD_write_ecowitt_interval=0x1f; 

typeset -ir CMD_read_wunderground=0x20; 
typeset -ir CMD_write_wunderground=0x21; 

typeset -ir CMD_read_wow=0x22; 
typeset -ir CMD_write_wow=0x23; 

typeset -ir CMD_read_weathercloud=0x24; 
typeset -ir CMD_write_weathercloud=0x25; 

#customized server for ecowitt/wunderground http requests
typeset -ir CMD_read_customized=0x2a; 
typeset -ir CMD_write_customized=0x2b; 
typeset -ir CMD_read_path=0x51; 
typeset -ir CMD_write_path=0x52; 

typeset -ir CMD_read_raindata=0x34; 
typeset -ir CMD_write_raindata=0x35; 

typeset -ir CMD_livedata=0x27; 

#sensors
typeset -ir CMD_read_sensor_id=0x3a; 
typeset -ir CMD_write_sensor_id=0x3b; 
typeset -ir CMD_read_sensor_id_new=0x3c;  # for new sensors

typeset -ir CMD_read_system=0x30; 
typeset -ir CMD_write_system=0x31; 

#mapping to name
CMD_NAME[$CMD_read_version]="read version"
CMD_NAME[$CMD_reboot]="reboot"
CMD_NAME[$CMD_read_mac]="read mac"
CMD_NAME[$CMD_write_ssid]="write ssid"
CMD_NAME[$CMD_broadcast]="broadcast"
CMD_NAME[$CMD_write_reset]="reset"

CMD_NAME[$CMD_read_ecowitt_interval]="read ecowitt intervall"
CMD_NAME[$CMD_write_ecowitt_interval]="write ecowitt interval"
CMD_NAME[$CMD_read_wunderground]="read wunderground"
CMD_NAME[$CMD_write_wunderground]="write wunderground"
CMD_NAME[$CMD_read_wow]="read wow"
CMD_NAME[$CMD_write_wow]="write wow"
CMD_NAME[$CMD_read_weathercloud]="read weathercloud"
CMD_NAME[$CMD_write_weathercloud]="write weathercloud"

CMD_NAME[$CMD_read_customized]="read customized"
CMD_NAME[$CMD_write_customized]="write customized"
CMD_NAME[$CMD_read_path]="read path"
CMD_NAME[$CMD_write_path]="write path"

CMD_NAME[$CMD_read_raindata]="read raindata"
CMD_NAME[$CMD_write_raindata]="write raindata"

CMD_NAME[$CMD_livedata]="livedata"

CMD_NAME[$CMD_read_sensor_id]="read sensor id"
CMD_NAME[$CMD_write_sensor_id]="write sensor id"
CMD_NAME[$CMD_read_sensor_id_new]="read sensor id new"

CMD_NAME[$CMD_read_system]="read system"
CMD_NAME[$CMD_write_system]="write system"

typeset -ir SYSTEM_FREQUENCY_RFM433M=0 # 433MHz
typeset -ir SYSTEM_FREQUENCY_RFM868M=1 # 868Mhz
typeset -ir SYSTEM_FREQUENCY_RFM915M=2 # 915MHz
typeset -ir SYSTEM_FREQUENCY_RFM920M=4 # 920Mhz

typeset -ir SYSTEM_SENSOR_TYPE_WH24=0
typeset -ir SYSTEM_SENSOR_TYPE_WH65=1

typeset -a SYSTEM_TIMEZONE #initTimezones

#sensors
#typedef enum
#{
# //eWH24_SENSOR = 0x00,
# eWH65_SENSOR = 0x00,
# //eWH69_SENSOR,
# eWH68_SENSOR,
# eWH80_SENSOR, //80H（
# eWH40_SENSOR,
# eWH25_SENSOR,
# eWH26_SENSOR,
# eWH31_SENSORCH1, // 6
# eWH31_SENSORCH2,
# eWH31_SENSORCH3,
# eWH31_SENSORCH4,
# eWH31_SENSORCH5,
# eWH31_SENSORCH6,
# eWH31_SENSORCH7,
# eWH31_SENSORCH8,
# eWH51_SENSORCH1, // 14 - 0x0e
# eWH51_SENSORCH2,
# eWH51_SENSORCH3,
# eWH51_SENSORCH4,
# eWH51_SENSORCH5,
# eWH51_SENSORCH6,
# eWH51_SENSORCH7, 
# eWH51_SENSORCH8, // 22
# eWH41_SENSORCH1, // 23 - 0x17
#eWH41_SENSORCH2,
# eWH41_SENSORCH3,
# eWH41_SENSORCH4,
# //-------------
# eWH57_SENSOR,    // 26? - 0x1a - lightning detector
# eWH55_SENSORCH1, // 27  - 0x1b - water leak ch1
# eWH55_SENSORCH2,
# eWH55_SENSORCH3,
#eWH55_SENSORCH4,
# eWH34_SENSORCH1 = 31,
# eWH34_SENSORCH2 = 32,
# eWH34_SENSORCH3 = 33,
# eWH34_SENSORCH4 = 34,
# eWH34_SENSORCH5 = 35,
# eWH34_SENSORCH6 = 36,
# eWH34_SENSORCH7 = 37,
#eWH34_SENSORCH8 = 38,
#eWH45_SENSOR = 39,
#// GW1000 Firmware V1.5.6 之后加入的
#eWH35_SENSORCH1 = 40,
#eWH35_SENSORCH2 = 41,
#eWH35_SENSORCH3 = 42,
#eWH35_SENSORCH4 = 43,
#eWH35_SENSORCH5 = 44,
#eWH35_SENSORCH6 = 45,
#eWH35_SENSORCH7 = 46,
#eWH35_SENSORCH8 = 47,
# // the SENSOR_TYPE sequence can not be altered!!
#//-------------
# eMAX_SENSOR
#}SENSOR_IDT
#https://www.wxforum.net/index.php?topic=40730.0
SENSOR_SEARCH=$(( 0xffffffff ))
SENSOR_DISABLE=$(( 0xfffffffe ))
SENSOR_SEARCH_STRING=ffffffff
SENSOR_DISABLE_STRING=fffffffe
#typeset -i SENSOR_SEARCH=4294967295
#typeset -i SENSOR_DISABLE=4294967294

typeset -ir WH24_type=0x00
typeset -ir WH65_type=0x00
typeset -ir WH68_type=0x01
typeset -ir WH80_type=0x02
typeset -ir WH40_type=0x03

typeset -ir WH32_type=0x05

typeset -ir WH31_type=0x06
typeset -ir WH31_max_ch=8

typeset -ir WH51_type=0x0e
typeset -ir WH51_max_ch=8

#Probably: cmd sensor_id up to 0x1e sensors type, and sensor_id_new from 0x1f (31)
typeset -ir WH55_type=0x1b
typeset -ir WH55_max_ch=4

typeset -ir WH43_type=0x16
typeset -ir WH43_max_ch=4

typeset -ir WH57_type=0x1a

typeset -ir WH34_type=0x1f
typeset -ir WH34_max_ch=8

typeset -ir WH35_type=0x28
typeset -ir WH35_max_ch=8

typeset -ir WH45_type=0x27

typeset -a SENSOR_TYPE

#type:description:reportinginterval(s):max reportinterval:detection interval
SENSOR_TYPE[WH65_type]="WH65:Outdoor Solar Powered 7-in-1 Weather Sensor:16.0:"
SENSOR_TYPE[WH68_type]="WH68:Solar Powered Anemometer with Light and UV Sensor:16.5:"
SENSOR_TYPE[WH80_type]="WH80:Wind Speed/Direction, Solar Radiation/Light, Temp/Humidity:4.75:"
SENSOR_TYPE[WH40_type]="WH40:Self-Emptying Rain Collector Rainfall Sensor:49.0"
SENSOR_TYPE[WH32_type]="WH32:Outdoor Temperature and Humidity Sensor:64.0"
SENSOR_TYPE[WH57_type]="WH57:Lightning Detection Sensor:79.0:"
SENSOR_TYPE[WH45_type]="WH45:Indoor CO2 PM2.5 PM10 Temperature and Humidity:60.0:600"


#sensors with max 8 channels
typeset -i CH
CH=1
while [ "$CH" -le $WH31_max_ch ]; do 
   SENSOR_TYPE[$(( WH31_type + CH - 1 ))]="WH31:Temperature and humidity CH$CH:61.0:"
   SENSOR_TYPE[$(( WH51_type + CH - 1 ))]="WH51:Soil Moisture CH$CH:70.0:"
   SENSOR_TYPE[$(( WH34_type + CH - 1 ))]="WH34:Soil Temperature Sensor CH$CH:77.0"
   SENSOR_TYPE[$(( WH35_type + CH - 1 ))]="WH35:Leaf Wetness Sensor for Garden and Farm CH$CH:79.5"
   if [ $CH -le $WH55_max_ch ]; then
      SENSOR_TYPE[$(( WH43_type + CH - 1 ))]="WH43:PM2.5 Air Quality Indoor CH$CH:60.0:600.0"
      SENSOR_TYPE[$(( WH55_type + CH - 1 ))]="WH55:Water Leak CH$CH:60.0::3"
   fi
   CH=$((CH + 1))
done

typeset -a LIVEDATA

typeset -a LDFIELD
LDFIELD[0x01]="INTEMP:indoor temperature:℃:2:1"
LDFIELD[0x02]="OUTTEMP:outdoor temperature:℃:2:1"
LDFIELD[0x06]="INHUMI:indoor humidity:%:1:0"
LDFIELD[0x07]="OUTHUMI:outdoor humidity:%:1:0"
LDFIELD[0x08]="ABSBARO:absolute pressure:hpa:2:1"
LDFIELD[0x09]="RELBARO:relative pressure:hpa:2:1"
LDFIELD[0x0A]="WINDDIRECTION:wind direction:°:2:0"
LDFIELD[0x0B]="WINDSPEED:wind speed:m/s:2:1"
LDFIELD[0x19]="WINDGUSTDAILYMAX:wind gust daily max:m/s:2:1"
LDFIELD[0x0C]="WINDGUST:wind gust:m/s:2:1"
LDFIELD[0x0D]="RAINEVENT:rain event:mm:2:1"
LDFIELD[0x0E]="RAINRATE:rain rate:mm/h:2:1"
LDFIELD[0x0F]="RAINHOUR:rain hour:mm:2:1"
LDFIELD[0x10]="RAINDAILY:rain daily:mm:2:1"
LDFIELD[0x11]="RAINWEEK:rain week:mm:2:1"
LDFIELD[0x12]="RAINMONTH:rain month:mm:4:1"
LDFIELD[0x13]="RAINYEAR:rain year:mm:4:1"
LDFIELD[0x15]="LIGHT:light:lx:4:1" # lux=lumen/m2]
LDFIELD[0x16]="UV:UV radiation:µW/m2:2:1"
LDFIELD[0x17]="UVI:UV index (0-15)::1:0"

CH=1
LDFT_WH43=0x2A
LDFT_WH43_24AVG=0x4D
LDFT_WH51=0x2B
LDFT_WH31_TEMP=0x1A
LDFT_WH31_HUMI=0x22
LDFT_WH55=0x58

while [ "$CH" -le 8 ]; do 
#for ((, CH=1;CH<=4; CH++, LDFT++,LDFT2++ )); do
  
  if [ "$CH" -le $WH43_max_ch ]; then 
        if [ "$CH" -eq 2 ]; then LDFT_WH43=$((0x51)); fi

        LDFIELD[$LDFT_WH43]="PM25_CH$CH:PM2.5 air quality CH$CH:μg/m3:2:1"
        LDFIELD[$LDFT_WH43_24AVG]="PM25_24HAVG_CH$CH:PM2.5 24h average CH$CH:μg/m3:2:1"
        LDFT_WH43=$(( LDFT_WH43 + 1))
        LDFT_WH43_24AVG=$(( LDFT_WH43_24AVG + 1))
  fi

  if [ "$CH" -le $WH51_max_ch ]; then 
   LDFIELD[$LDFT_WH51]="SOILTEMP_CH${CH}:soil temperature CH$CH:℃:2:1"
   LDFIELD[$(( LDFT_WH51 + 1 ))]=SOILHUMI_CH$CH":soil humidity CH$CH"":%:1:0"
   LDFT_WH51=$(( LDFT_WH51 + 2))
  fi 

  if [ "$CH" -le $WH31_max_ch ]; then 
     LDFIELD[$LDFT_WH31_TEMP]="TEMP_CH$CH:temperature CH$CH:℃:2:1"
     LDFIELD[$LDFT_WH31_HUMI]="HUMI_CH$CH:humidity CH$CH:%:1:0"
     LDFT_WH31_TEMP=$(( LDFT_WH31_TEMP + 1 ))
     LDFT_WH31_HUMI=$(( LDFT_WH31_HUMI + 1 ))
  fi

  if [ "$CH" -le $WH55_max_ch ]; then
     LDFIELD[$LDFT_WH55]="LEAK_CH$CH:leak CH$CH::1:0"
    LDFT_WH55=$(( LDFT_WH55 + 1 ))
  fi 
  CH=$(( CH + 1 ))
done

#for ((LDFT=0x2B, CH=1;CH<=16; CH++, LDFT=LDFT+2 )); do
#   LDFIELD[$LDFT]="SOILTEMP_CH${CH}:soil temperature CH$CH:℃:2:1"
#   LDFIELD[(( LDFT + 1 ))]=SOILHUMI_CH$CH":soil humidity CH$CH"":%:1:0"
#done
#for ((LDFT=0x1A, LDFT2=0x22, CH=1;CH<=8; CH++, LDFT++,LDFT2++ )); do
#   LDFIELD[$LDFT]="TEMP_CH$CH:temperature CH$CH:℃:2:1"
#   LDFIELD[$LDFT2]="HUMI_CH$CH:humidity CH$CH:%:1:0"
#done
#for ((LDFT=0x58, CH=1;CH<=4; CH++, LDFT++ )); do
#   LDFIELD[$LDFT]="LEAK_CH$CH:leak CH$CH::1:0"
#done

CONFIGURATION_SENSORFIELD="sensortype_"

#mapping from livedata field type/decimal to rename of description (specified in configuration file)
typeset -a LIVEDATA_FIELDRENAME
# fieldtypes discovered/parsed in livedata from host
typeset -a LDF_DISCOVERED 

#CONNECT ERRORS
ERROR_CONNECTION=1
ERROR_NO_NMCLI=2
ERROR_NO_SOCAT=3
ERROR_RAINDATA_NOTSPECIFIED=4
ERROR_SYSTEMPARAM_NOTSPECIFIED=5
#ERROR_READ_RESPONSE=3

typeset -a CONFIGURATION
#CONFIGURATION_DISCOVER array contains indexes to CONFIGURAITION with values
typeset -a CONFIGURATION_SENSOR
#CONFIGURATION_SENSOR_TYPE array contains indexes to CONFIGURATION_SENSOR with values
if typeset -A ASSOCIATIVE_ARRAY 2>/dev/null; then # is easier to use, otherwise two arrays
  SUPPORT_ASSOCIATIVE_ARRAY=1
fi

#CONF_$CONFIGURATION_SENSORFIELD$STYPE]
typeset -ir CONF_broadcast_ip=0
typeset -ir CONF_broadcast_mac=1
typeset -ir CONF_broadcast_port=2
typeset -ir CONF_broadcast_ssid=3
typeset -ir CONF_broadcast_version=4
typeset -ir CONF_customized_ecowitt_path=5
typeset -ir CONF_customized_enabled=6
typeset -ir CONF_customized_id=7
typeset -ir CONF_customized_interval=8
typeset -ir CONF_customized_password=9
typeset -ir CONF_customized_port=10
typeset -ir CONF_customized_server=11
typeset -ir CONF_customized_type=12
typeset -ir CONF_customized_wunderground_path=13
typeset -ir CONF_ecowitt_interval=14
typeset -ir CONF_host=15
typeset -ir CONF_mac=16
typeset -ir CONF_raindaily=17
typeset -ir CONF_rainmonth=18
typeset -ir CONF_rainrate=19
typeset -ir CONF_rainweek=20
typeset -ir CONF_rainyear=21
typeset -ir CONF_system_dst_status=22
typeset -ir CONF_system_dst_status_bit=23
typeset -ir CONF_system_dst_status_state=24
typeset -ir CONF_system_frequency=25
typeset -ir CONF_system_frequency_state=26
typeset -ir CONF_system_sensor_type=27
typeset -ir CONF_system_sensor_type_state=28
typeset -ir CONF_system_timezone_auto_bit=29
typeset -ir CONF_system_timezone_auto_state=30
typeset -ir CONF_system_timezone_index=31
typeset -ir CONF_system_timezone_index_state=32
typeset -ir CONF_system_utc=33
typeset -ir CONF_system_utc_state=34
typeset -ir CONF_version=35
typeset -ir CONF_weathercloud_id=36
typeset -ir CONF_weathercloud_password=37
typeset -ir CONF_wow_id=38
typeset -ir CONF_wow_password=39
typeset -ir CONF_wunderground_id=40
typeset -ir CONF_wunderground_password=41

typeset -a CONFIGURATION_NAME #allow reverse mapping from property to index -> make backup file readable/editable
CONFIGURATION_NAME[CONF_broadcast_ip]="broadcast_ip"
CONFIGURATION_NAME[CONF_broadcast_mac]="broadcast_mac"
CONFIGURATION_NAME[CONF_broadcast_port]="broadcast_port"
CONFIGURATION_NAME[CONF_broadcast_ssid]="broadcast_ssid"
CONFIGURATION_NAME[CONF_broadcast_version]="broadcast_version"
CONFIGURATION_NAME[CONF_customized_ecowitt_path]="customized_ecowitt_path"
CONFIGURATION_NAME[CONF_customized_enabled]="customized_enabled"
CONFIGURATION_NAME[CONF_customized_id]="customized_id"
CONFIGURATION_NAME[CONF_customized_interval]="customized_interval"
CONFIGURATION_NAME[CONF_customized_password]="customized password"
CONFIGURATION_NAME[CONF_customized_port]="customized_port"
CONFIGURATION_NAME[CONF_customized_server]="customized_server"
CONFIGURATION_NAME[CONF_customized_type]="customized_type"
CONFIGURATION_NAME[CONF_customized_wunderground_path]="customized_wunderground_path"
CONFIGURATION_NAME[CONF_ecowitt_interval]="ecowitt_interval"
CONFIGURATION_NAME[CONF_host]="host"
CONFIGURATION_NAME[CONF_mac]="mac"
CONFIGURATION_NAME[CONF_rainrate]="rainrate"
CONFIGURATION_NAME[CONF_raindaily]="raindaily"
CONFIGURATION_NAME[CONF_rainweek]="rainweek"
CONFIGURATION_NAME[CONF_rainmonth]="rainmonth"
CONFIGURATION_NAME[CONF_rainyear]="rainyear"
CONFIGURATION_NAME[CONF_system_dst_status]="system_dst_status"
CONFIGURATION_NAME[CONF_system_dst_status_bit]="system_dst_status_bit"
CONFIGURATION_NAME[CONF_system_dst_status_state]="system_dst_status_state"
CONFIGURATION_NAME[CONF_system_frequency]="system_frequency"
CONFIGURATION_NAME[CONF_system_frequency_state]="system_frequency_state"
CONFIGURATION_NAME[CONF_system_sensor_type]="system_sensor_type"
CONFIGURATION_NAME[CONF_system_sensor_type_state]="system_sensor_type_state"
CONFIGURATION_NAME[CONF_system_timezone_auto_bit]="system_timezone_auto_bit"
CONFIGURATION_NAME[CONF_system_timezone_auto_state]="system_timezone_auto_state"
CONFIGURATION_NAME[CONF_system_timezone_index]="system_timezone_index"
CONFIGURATION_NAME[CONF_system_timezone_index_state]="system_timezone_index_state"
CONFIGURATION_NAME[CONF_system_utc]="system_utc"
CONFIGURATION_NAME[CONF_system_utc_state]="system_utc_state"
CONFIGURATION_NAME[CONF_version]="version"
CONFIGURATION_NAME[CONF_weathercloud_id]="weathercloud_id"
CONFIGURATION_NAME[CONF_weathercloud_password]="weathercloud_password"
CONFIGURATION_NAME[CONF_wow_id]="wow_id"
CONFIGURATION_NAME[CONF_wow_password]="wow_password"
CONFIGURATION_NAME[CONF_wunderground_id]="wunderground_id"
CONFIGURATION_NAME[CONF_wunderground_password]="wunderground_password"

function listLivedataFieldsAndDescription
# $1 - if non-zero list only active fields found during parsing of livedata, else list all known fields
{
  local fn
  local fd
  local fk
  
  IFS=' '

  fk="${!LDFIELD[*]}" # !  all keys
  [ -n "$1" ] && fk="${LDF_DISCOVERED[*]}"
  
  printf "%4s %-16s %s\n" "type" "name" "description"
  for k in $fk; do
    IFS=':'
    read -r fn fd DISCARD <<< "${LDFIELD[$k]}"  
    printf "%4d %-16s %s\n" "$k" "$fn" "$fd"
  done
}

function connect {
  # Info  from https://www.xmodulo.com/tcp-udp-socket-bash-shell.html
  local host
  host="$1"

  if [ -v FD_TCP ] || [ -v FD_UDP ]; then # True if the shell variable varname is set (has been assigned a value). - man bash
    [ $DEBUG -eq 1 ] && echo >&2 "$HOST_PREV closing connection"
    disconnect
  fi

  #https://www.gnu.org/software/bash/manual/bash.html - 3.6 Redirections
  if exec {FD_UDP}<>/dev/udp/"$host"/"$PORT_udp_discovery_client"; then
    [ $DEBUG -eq 1 ] && echo >&2 "$host:$PORT_udp_discovery_client Connected (UDP FD $FD_UDP)"
  else
    return $ERROR_CONNECTION
  fi

  if exec {FD_TCP}<>/dev/tcp/"$host"/"$PORT_tcp_command_server"; then
    [ $DEBUG -eq 1 ] && echo >&2 "$host:$PORT_tcp_command_server Connected (TCP FD $FD_TCP)"
  else
    return $ERROR_CONNECTION
  fi

  #Current shell PID $$

  if [ $DEBUG -eq 1 ]; then
    netstat -tunp | grep "$$"
  fi

  [ -v FD_TCP ] && [ -v FD_UDP ]

}

function disconnect {
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
  #close sockets
  if [ -v FD_UDP ]; then

    if ! exec {FD_UDP}>&-; then echo >&2 Failed to close $FD_UDP; fi
    [ $DEBUG -eq 1 ] && echo >&2 "Closing FD $FD_UDP (UDP)"

    unset FD_UDP
  fi

  if [ -v FD_TCP ]; then

    if ! exec {FD_TCP}>&-; then echo >&2 Failed to close $FD_TCP; fi
    [ $DEBUG -eq 1 ] && echo >&2 "Closing FD $FD_TCP (TCP)"

    unset FD_TCP
  fi
}

function parseResultPacket {
  local cmd
  cmd="0x${PACKET_RX[2]}"
  local result

  result=$(( 0x${PACKET_RX[4]} ))
  echo -n "${CMD_NAME[cmd]}" "$result" >&2
  
  if [[ $result -eq  0 ]]; then
   >&2  echo " OK"
    return 0 
  elif [[ $result  -eq 1 ]]; then
    >&2 echo " FAIL"
    return 1
  fi
}

function printStack {
  echo "${FUNCNAME[@]}"
}

function printCustomized {

  echo "customized_id ${CONFIGURATION[$CONF_customized_id]}"
  echo "customized_password ${CONFIGURATION[$CONF_customized_password]}"
  echo "customized_server ${CONFIGURATION[$CONF_customized_server]}"
  echo "customized_port ${CONFIGURATION[$CONF_customized_port]}"
  echo "customized_interval ${CONFIGURATION[$CONF_customized_interval]}"

  if [ "${CONFIGURATION[$CONF_customized_type]}" -eq 1 ]; then
    echo "customized_type 1 wunderground"
  elif [ "${CONFIGURATION[$CONF_customized_type]}" -eq 0 ]; then
    echo "customized_type 0 ecowitt "
  else
    echo "customized_type ${CONFIGURATION[$CONF_customized_type]}" "UNKNOWN"
  fi

  if [ "${CONFIGURATION[$CONF_customized_enabled]}" -eq 1 ]; then
    echo "customized_enabled 1 ON"
  elif [ "${CONFIGURATION[$CONF_customized_enabled]}" -eq 0 ]; then
    echo "customized_enabled 0 OFF"
  else
    echo "customized_enabled ${CONFIGURATION[$CONF_customized_enabled]} UNKNOWN"
  fi

  echo "customized_ecowitt_path ${CONFIGURATION[$CONF_customized_ecowitt_path]}"
  echo "customized_wunderground path ${CONFIGURATION[$CONF_customized_wunderground_path]}"
}

function printConfiguration {
  
 #bash  for K in "${!CONFIGURATION[@]}"; do

 for K in  "${CONFIGURATION_DISCOVER[@]}"; do
  printf "%-30s %s\n" "${CONFIGURATION_NAME[$K]}" "${CONFIGURATION[$K]}" 
 done

  IFS=':'
  for K in  "${CONFIGURATION_SENSOR_DISCOVER[@]}"; do
      read -r SNAME SDESC DISCARD <<< "${SENSOR_TYPE[$K]}"
      decToHex "${CONFIGURATION_SENSOR[$K]}" 
      printf "%-30s %10s %s\n"  "$CONFIGURATION_SENSORFIELD$K" "$VALUE_HEX" "$SDESC" 
  done

}

function readUInt8 {
  VALUE_HEX="0x${PACKET_RX_HEX:(($RX_POS * 2)):2}"
#  printf -v VALUE_UINT8 "%u" "$VALUE_HEX" 2>/dev/null || VALUE_UINT8=$( printf "%u" "$VALUE_HEX")
 # VALUE_UINT8=$( printf "%u" "$VALUE_HEX")
   VALUE_UINT8=$(( 0x${PACKET_RX[$RX_POS ]} ))
 #  echo "readUInt8 RX_POS $RX_POS VALUE_HEX  $VALUE_HEX"
  ((RX_POS = RX_POS + 1))
}

function readUInt16BE {
  VALUE_UINT16BE_HEX="0x${PACKET_RX_HEX:(($RX_POS * 2)):4}"
 # printf -v VALUE_UINT16BE "%u" "$VALUE_UINT16BE_HEX" 2>/dev/null || VALUE_UINT16BE=$( printf "%u" "$VALUE_UINT16BE_HEX" )
 # VALUE_UINT16BE=$( printf "%u" "$VALUE_UINT16BE_HEX" )
  VALUE_UINT16BE=$(( (0x${PACKET_RX[$RX_POS]} << 8) |  0x${PACKET_RX[$RX_POS + 1]} ))
  # "echo readUInt16BE RX_POS $RX_POS VALUE_UINT16BE_HEX  $VALUE_UINT16BE_HEX ${PACKET_RX[$RX_POS + 1]} ${PACKET_RX[$RX_POS]}"
 
  ((RX_POS = RX_POS + 2))
}

function readUInt32BE {
  VALUE_UINT32BE_HEX="0x${PACKET_RX_HEX:(($RX_POS * 2)):8}"
  #printf -v VALUE_UINT32BE "%u" "$VALUE_UINT32BE_HEX" 2>/dev/null || VALUE_UINT32BE=$( printf "%u" "$VALUE_UINT32BE_HEX" )
 # VALUE_UINT32BE=$( printf "%u" "$VALUE_UINT32BE_HEX" )
 VALUE_UINT32BE=$(( (0x${PACKET_RX[$RX_POS ]} << 24) | (0x${PACKET_RX[$RX_POS + 1 ]} << 16)  | (0x${PACKET_RX[$RX_POS + 2 ]} << 8) |  0x${PACKET_RX[$RX_POS + 3]} ))
  
  ((RX_POS = RX_POS + 4))
}

function readString {
  local len
  len=0x${PACKET_RX[$RX_POS]}
  local n
  n=1
  #VALUE_STRING="${PACKET_RX_OD_ASCII:(($RX_POS + 1)):len}"
  unset VALUE_STRING
  while [[ "$n" -le $(( len )) ]]; do
      VALUE_STRING=$VALUE_STRING"\x${PACKET_RX[$RX_POS + $n]}"
      n=$(( n + 1 ))
  done
  # shellcheck disable=SC2059
  VALUE_STRING=$(printf "$VALUE_STRING")

  RX_POS=$(( RX_POS + len + 1 ))
}

function printRain {
  local rr
  local rd
  local rw
  local rm
  local ry
  convertScale10ToFloat "${CONFIGURATION[$CONF_rainrate]}"
  rr=$VALUE_SCALE10_FLOAT
  convertScale10ToFloat "${CONFIGURATION[$CONF_raindaily]}"
  rd=$VALUE_SCALE10_FLOAT
  convertScale10ToFloat "${CONFIGURATION[$CONF_rainweek]}"
  rw=$VALUE_SCALE10_FLOAT
  convertScale10ToFloat "${CONFIGURATION[$CONF_rainmonth]}"
  rm=$VALUE_SCALE10_FLOAT
  convertScale10ToFloat "${CONFIGURATION[$CONF_rainyear]}"
  ry=$VALUE_SCALE10_FLOAT
  #echo rainrate "${CONFIGURATION[$CONF_rainrate]} "
  #echo rainday "${CONFIGURATION[$CONF_raindaily]} "
  #echo rainweek "${CONFIGURATION[$CONF_rainweek]} "
  #echo rainmonth "${CONFIGURATION[$CONF_rainmonth]} "
  #echo  rainyear "${CONFIGURATION[$CONF_rainyear]}"
  #echo "rainrate $rr rainday $rd rainweek $rw rainmonth $rm rainyear $ry"
  printf "%9s %9s %9s %9s %9s\n" rainrate rainday rainweek rainmonth rainyear
  printf "%9s %9s %9s %9s %9s\n" "$rr" "$rd" "$rw" "$rm" "$ry"
}

function convertWindDirectionToCompassDirection
#$1 - direction in degrees
#http://snowfence.umn.edu/Components/winddirectionanddegrees.htm
{
  VALUE_COMPASS_DIRECTION_NAME=""
  if   [[ "$1" -le 11 ]] || [[ "$1" -gt 349 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="N"
  elif [[ "$1" -gt 11 ]] && [[  "$1" -lt 34 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="NNE"
  elif [[ "$1" -ge 34 ]] && [[  "$1" -le 56 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="NE";
  elif [[ "$1" -gt 56 ]] && [[  "$1" -le  79 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="ENE";
  elif [[ "$1" -gt  79 ]] && [[  "$1" -le  101 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="E"
  elif [[ "$1" -gt  101 ]] && [[  "$1" -le  124 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="ESE"
  elif [[ "$1" -gt  124 ]] && [[ "$1" -le  146 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="SE"
  elif [[ "$1" -gt  146 ]] && [[  "$1" -le  169 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="SSE"
  elif [[ "$1" -gt  169 ]] && [[  "$1" -le  191 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="S"
  elif [[ "$1" -gt  191 ]] && [[  "$1" -le  214 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="SSW"
  elif [[ "$1" -gt  214 ]] && [[  "$1" -le  236 ]]; then
    VALUE_COMPASS_DIRECTION_NAME="SW"
  elif [[ "$1" -gt  236 ]] && [[  "$1" -le  259 ]]; then
     VALUE_COMPASS_DIRECTION_NAME="WSW"
  elif [[ "$1" -gt  259 ]] && [[  "$1" -le  281 ]]; then
     VALUE_COMPASS_DIRECTION_NAME="W"
  elif [[ "$1" -gt  281 ]] && [[  "$1" -le  304 ]]; then
     VALUE_COMPASS_DIRECTION_NAME="WNW"
  elif [[ "$1" -gt  304 ]] && [[  "$1" -le  326 ]]; then
     VALUE_COMPASS_DIRECTION_NAME="NW"
  elif [[ "$1" -gt  326 ]] && [[  "$1" -le  349 ]]; then
     VALUE_COMPASS_DIRECTION_NAME="NNW"
  fi
}

function getBatteryLevelState
# $1 - battery level 0-6, 6 = dc, <=1 low
{
  unset SBATTERY_STATE
    #set -- 0     #debug  set $1 to 0 
    if [ "$1" -eq 6 ]; then
      SBATTERY_STATE="dc"; # for example PM 2.5 indoor
    else
      SBATTERY_STATE=""
      local l
      l=1
      while [ "$l" -le "$1" ]; do
          SBATTERY_STATE+="+";
          l=$(( l + 1 ))
      done
      if [ "$1" -le 1 ]; then
        SBATTERY_STATE+=" low"
      fi
    fi
}

function getBatteryState
{
  unset SBATTERY_STATE
  if [ "$1" -eq 0 ]; then
      SBATTERY_STATE="normal" #ok
  elif [  "$1" -eq 1 ]; then
    SBATTERY_STATE="low"
  fi
}

function printLivedata
{
    if [ -n "${LDFDESC_RENAME}" ]; then
           LDFDESC=$LDFDESC_RENAME
        fi

    if [ "$LDFUNIT" = "℃" ]; then
        #multibyte character/unicode requires 1 larger width and a space padding for description
              printf "%8s %6s %s\n" "${LIVEDATA[$fieldTypeDec]}" "$LDFUNIT" " $LDFDESC"
    elif [ "$LDFUNIT"  = "°" ]; then
              printf "%8s %6s %s\n" "${LIVEDATA[$fieldTypeDec]}" "$LDFUNIT" "$LDFDESC"
    else
            printf "%8s %5s %s\n" "${LIVEDATA[$fieldTypeDec]}" "$LDFUNIT" "$LDFDESC"
    fi 

    if [ "$LDFNAME" = 'WINDDIRECTION' ]; then  
            convertWindDirectionToCompassDirection "${LIVEDATA[$fieldTypeDec]}"
            #LIVEDATA_EXTRA[$fieldTypeDec]=$VALUE_COMPASS_DIRECTION_NAME
            if [ -n "${LIVEDATA_FIELDRENAME[compass_direction]}" ]; then
                LDFDESC=${LIVEDATA_FIELDRENAME[compass_direction]}
            else
              LDFDESC="wind compass direction"
            fi
              printf "%8s %5s %s\n" "$VALUE_COMPASS_DIRECTION_NAME" "" "$LDFDESC"
            
    fi

}

function parseLivedata
# $1 -pattern to match
#https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs [[ [ ((
{
  local fieldTypeDec
  local match
  local len

 [ $DEBUG -eq 1 ] && >&2 echo parseLivedata "SPATTERN" "$SPATTERN"

  IFS=':'
  unset LDF_DISCOVERED

  len=$((${#PACKET_RX[@]} - 1))

  #date +"%s.%N"

  while [ "$RX_POS" -lt $len  ]; do

    [ $DEBUG -eq 1 ]&& >&2 echo PACKET_RX_HEX "${PACKET_RX_HEX:(( $RX_POS * 2 ))}" RX_POS "$RX_POS" PACKET_RX_LENGTH "${#PACKET_RX[@]}"

    readUInt8
    fieldTypeDec=$VALUE_UINT8

     LDF_DISCOVERED+=( "$fieldTypeDec" ) # keep track of discovered fields

   read -r LDFNAME LDFDESC LDFUNIT LDFBYTES LDFSCALE <<< "${LDFIELD[$fieldTypeDec]}"
    
    unset LDFDESC_RENAME
    if [ -n "${LIVEDATA_FIELDRENAME[$fieldTypeDec]}" ]; then #rename sensor description
       LDFDESC_RENAME=${LIVEDATA_FIELDRENAME[$fieldTypeDec]}
    fi

    if   [ "$LDFBYTES" -eq 1 ]; then  
          readUInt8
          LIVEDATA[$fieldTypeDec]=$VALUE_UINT8

    elif [ "$LDFBYTES" -eq 2 ]; then 
          readUInt16BE
          LIVEDATA[$fieldTypeDec]=$VALUE_UINT16BE

    elif [ "$LDFBYTES" -eq 4 ]; then
          readUInt32BE
          LIVEDATA[$fieldTypeDec]=$VALUE_UINT32BE
    fi
    
     if [ "$LDFSCALE" -eq 1 ]; then # scale: divide by 10 if neccessary
        convertScale10ToFloat "${LIVEDATA[$fieldTypeDec]}"
        LIVEDATA[$fieldTypeDec]=$VALUE_SCALE10_FLOAT
     fi

    if [[ -n "$BASH_VERSION"  ]]; then
       eval 'if [[ ${LDFNAME,,} =~ ^${SPATTERN} || ${LDFDESC,,} =~ ${SPATTERN} || ${LDFDESC_RENAME,,} =~  ${SPATTERN} ]] ; then match=1; printLivedata; fi' #eval prevent ksh parser syntax error
      # ^ line starts with, ,,=to lowercase
    elif [[ -n "$ZSH_VERSION" ]]; then
        eval 'if [[ ${LDFNAME:l} =~ ^${SPATTERN} || ${LDFDESC:l} =~ ${SPATTERN} || ${LDFDESC_RENAME:l} =~  ${SPATTERN} ]] ; then match=1; printLivedata; fi'
    elif [[ "${KSH_VERSION:7}" == "Version" ]]; then 
       toLowercase "$LDFNAME"
       LDFNAME=$lowercase
       toLowercase "$LDFDESC"
       LDFDESC=$lowercase
       toLowercase "$LDFDESC_RENAME"
       LDFDESC_RENAME=$lowercase
       eval 'if [[ "$LDFNAME" =~ ^${SPATTERN} || "$LDFDESC" =~ ${SPATTERN} || "$LDFDESC_RENAME" =~  ${SPATTERN} ]] ; then match=1; printLivedata; fi'
     elif  echo "$LDFNAME" | grep -i -q -E "$SPATTERN" || echo "$LDFDESC" | grep -i -q -E "$SPATTERN" || echo "$LDFDESC_RENAME" | grep -i -q -E "$SPATTERN"; then
        match=1; printLivedata;
    fi

  done

  [ $DEBUG -eq 1 ] && >&2 echo Discovered fields in packet "${LDF_DISCOVERED[@]}"

  if [ "$match" -eq 0 ]; then
  >&2 echo "Error Failed to match '$SPATTERN' in current livedata fields"
     listLivedataFieldsAndDescription 1 # 1 - list only active/discovered fields in parsed data
    
  fi
}

function printSensorHeader
{
   printf "%5s %5s %8s %10s %7s %13s %6s %12s %s\n" type name id id_state battery battery_state signal interval_min description
}

function printSensorLine
{
  case "$KSH_VERSION" in 
   *MIRBSD*)
      typeset -iU SID_PRINT=$SID #force usigned int for mirbsd korn shell/android to get proper formatting 
       printf "%5s %5s %8x %10s %7s %13s %6s %12s %s\n" "$STYPE" "$SNAME" "$SID_PRINT" "$SID_STATE" "$SBATTERY" "$SBATTERY_STATE" "$SSIGNAL" "$SINTERVAL_MIN" "$SDESC"
       ;;
  *)
    printf "%5s %5s %8x %10s %7s %13s %6s %12s %s\n" "$STYPE" "$SNAME" "$SID" "$SID_STATE" "$SBATTERY" "$SBATTERY_STATE" "$SSIGNAL" "$SINTERVAL_MIN" "$SDESC"
    ;;
  esac
}

function toLowercase
{
  typeset -l lowcasestr # -l option -> lowercase on assignment/or ignored
  if [[ -n "$BASH_VERSION" ]]; then
    eval 'lowercase=${1,,}' #eval prevents ksh from stopping parsing on syntax error
  elif [[ -n "$ZSH_VERSION" ]]; then
    lowercase=${1:l}
  elif [[ -n "$KSH_VERSION" ]]; then
  # Android 11 runds mir bsd korn shell http://www.mirbsd.org/mksh.htm
    lowcasestr=$1
    lowercase=$lowcasestr
  else
     lowercase=$(echo "$1" | tr '[:upper:]' '[:lower:]')
  fi
 
}

function parseSensor
 # echo "$PACKET_RX_HEX"
   # for s in "${!SENSOR_TYPE[@]}"; do # ! - keys in SENSOR_TYPE
   #   echo "$s" "${SENSOR_TYPE[$s]}"
   # done

#   29) Read Sensors ID parameter:
#typedef enum
# {
# eWH65_SENSOR = 0x00,// 1: BATT low, 0: normal # //eWH24_SENSOR = 0x00,
# eWH68_SENSOR,// voltage=val*0.02V if <=1.2V BAT is low   # //eWH69_SENSOR,
# eWH80_SENSOR,// 0.02V * val(received val) = wh80;
# eWH40_SENSOR,// 1: BATT low, 0: normal
# eWH25_SENSOR,// 1: BATT low, 0: normal
# eWH26_SENSOR,// 1: BATT low, 0: normal
# eWH31_SENSORCH1,// 1: BATT low, 0: normal
# eWH31_SENSORCH2,// 1: BATT low, 0: normal
# eWH31_SENSORCH3,// 1: BATT low, 0: normal
# eWH31_SENSORCH4,// 1: BATT low, 0: normal
# eWH31_SENSORCH5,// 1: BATT low, 0: normal
# eWH31_SENSORCH6,// 1: BATT low, 0: normal
# eWH31_SENSORCH7,// 1: BATT low, 0: normal
# eWH31_SENSORCH8,// 1: BATT low, 0: normal
# eWH51_SENSORCH1,// 1: BATT low, 0: normal
# eWH51_SENSORCH2,// 1: BATT low, 0: normal
# eWH51_SENSORCH3,// 1: BATT low, 0: normal
# eWH51_SENSORCH4,// 1: BATT low, 0: normal
# eWH51_SENSORCH5,// 1: BATT low, 0: normal
# eWH51_SENSORCH6,// 1: BATT low, 0: normal
# eWH51_SENSORCH7,// 1: BATT low, 0: normal
# eWH51_SENSORCH8,// 1: BATT low, 0: normal
# eWH41_SENSORCH1,// level0~5，<=1 for BATT low
# eWH41_SENSORCH2,// level0~5，<=1 for BATT low
# eWH41_SENSORCH3,// level0~5，<=1 for BATT low
# eWH41_SENSORCH4,// level0~5，<=1 for BATT low
# eWH57_SENSOR = 26, // level0~5，<=1 for BATT low
# eWH55_SENSORCH1,// level0~5，<=1 for BATT low
# eWH55_SENSORCH2,// level0~5，<=1 for BATT low
# eWH55_SENSORCH3,// level0~5，<=1 for BATT low
# eWH55_SENSORCH4,// level0~5，<=1 for BATT low
# eWH34_SENSORCH1 = 31,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH2 = 32,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH3 = 33,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH4 = 34,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH5 = 35,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH6 = 36,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH7 = 37,// v=val*0.02V if v<=1.2V BATT low
# eWH34_SENSORCH8 = 38,// v=val*0.02V if v<=1.2V BATT low
# eWH45_SENSOR = 39,// 0~5
# eWH35_SENSORCH1 = 40,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH2 = 41,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH3 = 42,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH4 = 43,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH5 = 44,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH6 = 45,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH7 = 46,//电压=val*0.02V 当<=1.2V 时显示低电压
# eWH35_SENSORCH8 = 47,//电压=val*0.02V 当<=1.2V 时显示低电压
  

{
  local match # flag when pattern matches fields
  local printSensorHeaderFlag
  local n
  unset CONFIGURATION_SENSOR_DISCOVER
  unset CONFIGURATION_SENSOR_MATCH # keeps track of sensors matching search pattern
  n=0
  match=0
  printSensorHeaderFlag=0

 # echo SENSOR_SEARCH ${SENSOR_SEARCH} SENSOR_DISABLE $SENSOR_DISABLE $(( 0xffffffff ))
 # ksh - sets 0xffffffff to -1!? if typeset -i SENSOR_SEARCH=0xffffffff - its using 32-bit signed integer by default unless typeset -iU is used

  [ $DEBUG -eq 1 ] && >&2 echo parseSensor "SPATTERN" "$SPATTERN"
 
     IFS=':'
     unset CONFIGURATION_SENSOR
    
       while [ "$RX_POS" -lt $(( ${#PACKET_RX[@]} - 1 )) ]; do
            
            local RX_START_POS
            RX_START_POS=$RX_POS # for listing entire record as hex

              readUInt8

              STYPE=$VALUE_UINT8

              read -r SNAME SDESC SINTERVAL_MIN DISCARD <<< "${SENSOR_TYPE[STYPE]}"
              [ -z "$SNAME" ] && [ $DEBUG -eq 1 ] && echo >&2 "Unknown SENSOR_TYPE $STYPE"

              readUInt32BE
              
              SID=$VALUE_UINT32BE
              SID_HEX=$VALUE_UINT32BE_HEX # for searching

              n=$(( n + 1 ))
              CONFIGURATION_SENSOR_DISCOVER+=( "$STYPE" )

              CONFIGURATION_SENSOR[STYPE]=$SID
              
              if [[ "$SID" -eq "$SENSOR_SEARCH" ]]; then 
                  SID_STATE="searching"
              elif [[ "$SID" -eq  "$SENSOR_DISABLE" ]]; then
                    SID_STATE="disabled"
              else    
                    SID_STATE='enabled'
              fi

              readUInt8
              
              SBATTERY=$VALUE_UINT8
              
              unset SBATTERY_STATE
              #https://unix.stackexchange.com/questions/306111/what-is-the-difference-between-the-bash-operators-vs-vs-vs


              if [[ "$SID_STATE" = "enabled" ]]; then # intepret battery levels

                  if [[ "$STYPE" -ge $WH43_type ]] && [[ "$STYPE" -lt  $(( WH43_type + WH43_max_ch )) ]] ||
                     [[ "$STYPE" -ge $WH55_type ]] && [[ "$STYPE" -lt  $(( WH55_type + WH55_max_ch )) ]] ||
                     [[ "$STYPE" -eq $WH57_type ]]; then  #WH43 - PM2.5 indoor, WH41? same ID?
                  #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/CurdataGwFragment.java l 4575
                    getBatteryLevelState "$SBATTERY"
                  fi

                  #Voltage value seems to be scaled * 10 for soil moisture/rainfall sensor
                  if [[ "$STYPE" -ge  $WH51_type ]] && [[ "$STYPE" -lt $(( WH51_type + WH51_max_ch )) ]] || 
                     [[ "$STYPE" -eq  $WH40_type ]]; then 
                        convertScale10ToFloat "$SBATTERY"
                        SBATTERY_STATE=$VALUE_SCALE10_FLOAT"V"
                        if [ "$SBATTERY" -le 12 ]; then
                          SBATTERY_STATE+=" low"
                        fi
                  fi

                  if [[  "$STYPE" -eq  $WH65_type ]] || [[ "$STYPE" -ge $WH31_type ]] && [[ "$STYPE" -lt  $(( WH31_type + WH31_max_ch )) ]]; then # WH65, WH31 CH1-8 
                    getBatteryState "$SBATTERY"
                  fi
              fi

              readUInt8
              
              SSIGNAL=$VALUE_UINT8
            
            [ $DEBUG -eq 1 ] && >&2 echo "${PACKET_RX_HEX:(($RX_START_POS * 2)):14}"

          match=0
          if [[ -n "$BASH_VERSION"  ]]; then
            eval 'if [[ ${SNAME,,} =~ ^$SPATTERN || ${SDESC,,} =~ $SPATTERN || ${SID_STATE,,} =~  $SPATTERN || ${SID_HEX,,} =~  $SPATTERN ]] ; then match=1; fi' #eval prevent ksh parser syntax error
                # ^ line starts with, ,,=to lowercase
          elif [[ -n "$ZSH_VERSION" ]]; then
             eval 'if [[ ${SNAME:l} =~ ^$SPATTERN || ${SDESC:l} =~ $SPATTERN || ${SID_STATE:l} =~  $SPATTERN || ${SID_HEX:l} =~  $SPATTERN  ]] ; then match=1; fi'
          elif expr "$KSH_VERSION" : "Version" >/dev/null; then 
              toLowercase "$SNAME"
              SNAME=$lowercase
              toLowercase "$SDESC"
              SDESC=$lowercase
              toLowercase "$SID_STATE"
              SID_STATE=$lowercase
              toLowercase "$SID_HEX"
              SID_HEX=$lowercase
              eval 'if [[ $SNAME =~ ^$SPATTERN || $SDESC =~ $SPATTERN || $SID_STATE =~  $SPATTERN || $SID_HEX =~  $SPATTERN  ]] ; then match=1; fi'
          elif echo "$SNAME" | grep -i -q -E "$SPATTERN" || echo "$SDESC" | grep -i -q -E "$SPATTERN" || echo "$SID_STATE" | grep -i -q -E "$SPATTERN" || echo "$SID_HEX" | grep -i -q -E "$SPATTERN"; then 
             match=1   
          fi
       
          if [[ match -eq 1 && printSensorHeaderFlag -eq 0 ]]; then
            printSensorHeaderFlag=1
            CONFIGURATION_SENSOR_MATCH+=( "$STYPE" )
            printSensorHeader
            printSensorLine
          elif [[ match -eq 1 ]];then 
            CONFIGURATION_SENSOR_MATCH+=( "$STYPE" )
            printSensorLine
          fi
            
       done

       [ $DEBUG -eq 1 ] && >&2 echo PARSED "${CONFIGURATION_SENSOR_DISCOVER[@]}" length "${#CONFIGURATION_SENSOR_DISCOVER[@]}"
       [ $DEBUG -eq 1 ] && >&2 echo MACTHED "${CONFIGURATION_SENSOR_MATCH[@]}" length "${#CONFIGURATION_SENSOR_MATCH[@]}"
     
}

function initTimezones
{
  #zsh read -A assigns to array, #bash -a assigns to array ?! -> do a while loop over heredoc
  #https://stackoverflow.com/questions/2337616/can-i-read-line-from-a-heredoc-in-bash
  #echo "(UTC-12:00)International Date Line West", "(UTC-11:00)Samoa", "(UTC-11:00)Coordinated Universal Time-11", "(UTC-10:00)Aleutian Islands", "(UTC-10:00)Hawaii", "(UTC-09:30)Marquesas Islands", "(UTC-09:00)Alaska", "(UTC-09:00)Coordinated Universal Time-9", "(UTC-08:00)Pacific Time (US & Canada)", "(UTC-08:00)Baja California", "(UTC-08:00)Coordinated Universal Time-8", "(UTC-07:00)Chihuahua,La Paz,Mazatlan", "(UTC-07:00)Mountain Time (US & Canada)", "(UTC-07:00)Arizona", "(UTC-06:00)Guadalajara,Mexico City,Monterrey", "(UTC-06:00)Saskatchewan", "(UTC-06:00)Central Time (US & Canada)", "(UTC-06:00)Central America", "(UTC-05:00)Bogota,Lima,Quito", "(UTC-05:00)Eastern Time (US & Canada)", "(UTC-05:00)Havana", "(UTC-05:00)Hayti", "(UTC-05:00)Chetumal", "(UTC-05:00)Indiana (East)", "(UTC-04:30)Caracas", "(UTC-04:00)Atlantic Time (Canada)", "(UTC-04:00)Cuiaba", "(UTC-04:00)Georgetown,La Paz,Manaus,San Juan", "(UTC-04:00)Santiago", "(UTC-04:00)Asuncion", "(UTC-03:30)Newfoundland", "(UTC-03:00)Brasilia", "(UTC-03:00)Buenos Aires", "(UTC-03:00)Greenland", "(UTC-03:00)Cayenne,Fortaleza", "(UTC-03:00)Montevideo", "(UTC-02:00)Coordinated Universal Time-02", "(UTC-01:00)Cape Verde Is.", "(UTC-01:00)Azores", "(UTC)Dublin,Edinburgh,Lisbon,London", "(UTC)Casablanca", "(UTC)Monrovia,Reykjavik", "(UTC)Coordinated Universal Time", "(UTC+01:00)Amsterdam,Berlin,Bern,Rome,Stockholm,Vienna", "(UTC+01:00)Belgrade,Bratislava,Budapest,Ljubljana,Prague", "(UTC+01:00)Brussels,Copenhagen,Madrid,Paris", "(UTC+01:00)Sarajevo,Skopje,Warsaw,Zagreb", "(UTC+01:00)Windhoek", "(UTC+01:00)West Central Africa", "(UTC+02:00)Amman", "(UTC+02:00)Beirut", "(UTC+02:00)Damascus", "(UTC+02:00)Harare,Pretoria", "(UTC+02:00)Helsinki,Kyiv,Riga,Sofia,Talinn,Vilnius", "(UTC+02:00)Cairo", "(UTC+02:00)Athens,Bucharest,Istanbul", "(UTC+02:00)Jerusalem", "(UTC+03:00)Baghdad", "(UTC+03:00)Kuwait,Riyadh", "(UTC+03:00)Minsk", "(UTC+03:00)Moscow,St.Petersburg,Volgograd", "(UTC+03:00)Nairobi", "(UTC+03:30)Tehran", "(UTC+04:00)Abu Dhabi,Muscat", "(UTC+04:00)Yerevan", "(UTC+04:00)Baku", "(UTC+04:00)Tbilisi", "(UTC+04:00)Port Louis", "(UTC+04:30)Kabul", "(UTC+05:00)Tashkent", "(UTC+05:00)Ekaterinburg", "(UTC+05:00)Islamabad,Karachi", "(UTC+05:30)Chennai,Kolkata,Mumbai,New Delhi", "(UTC+05:30)Sri Jayawardenepura", "(UTC+05:45)Kathmandu", "(UTC+06:00)Astana", "(UTC+06:00)Dhaka", "(UTC+06:00)Novosibirsk", "(UTC+06:30)Yangon (Rangoon)", "(UTC+07:00)Kobdo", "(UTC+07:00)Krasnoyarsk", "(UTC+07:00)Bangkok,Hanoi,Jakarta", "(UTC+08:00)Beijing,Chongqing,Hong Kong,Urumqi", "(UTC+08:00)Kuala Lumpur,Singapore", "(UTC+08:00)Perth", "(UTC+08:00)Taipei", "(UTC+08:00)Ulaanbaatar", "(UTC+08:00)Irkutsk", "(UTC+09:00)Pyongyang", "(UTC+09:00)Osaka,Sapporo,Tokyo", "(UTC+09:00)Seoul", "(UTC+09:00)Yakutsk", "(UTC+09:30)Adelaide", "(UTC+09:30)Darwin", "(UTC+10:00)Brisbane", "(UTC+10:00)Vladivostok", "(UTC+10:00)Guam,Port Moresby", "(UTC+10:00)Hobart", "(UTC+10:00)Canberra,Melbourne,Sydney", "(UTC+10:30)Lord Howe Island", "(UTC+11:00)Magadan", "(UTC+11:00)Solomon Is.,New Caledonia", "(UTC+12:00)Auckland,Wellington", "(UTC+12:00)Fiji", "(UTC+12:00)Coordinated Universal Time+12", "(UTC+12:45)Chatham Islands", "(UTC+13:00)Nuku'alofa", "(UTC+14:00)Christmas Island" | cut -d ',' -f 1- --output-delimiter=$'\n'
#Based on decompiled /WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/SystemFragment.java
unset SYSTEM_TIMEZONE
while read -r line; do
 SYSTEM_TIMEZONE+=( "$line" )
 done <<EOF
(UTC-12:00) International Date Line West
(UTC-11:00) Samoa
(UTC-11:00) Coordinated Universal Time-11
(UTC-10:00) Aleutian Islands
(UTC-10:00) Hawaii
(UTC-09:30) Marquesas Islands
(UTC-09:00) Alaska
(UTC-09:00) Coordinated Universal Time-9
(UTC-08:00) Pacific Time (US & Canada)
(UTC-08:00) Baja California
(UTC-08:00) Coordinated Universal Time-8
(UTC-07:00) Chihuahua, La Paz, Mazatlan
(UTC-07:00) Mountain Time (US & Canada)
(UTC-07:00) Arizona
(UTC-06:00) Guadalajara, Mexico City,Monterrey
(UTC-06:00) Saskatchewan
(UTC-06:00) Central Time (US & Canada)
(UTC-06:00) Central America
(UTC-05:00) Bogota, Lima, Quito
(UTC-05:00) Eastern Time (US & Canada)
(UTC-05:00) Havana
(UTC-05:00) Hayti
(UTC-05:00) Chetumal
(UTC-05:00) Indiana (East)
(UTC-04:30) Caracas
(UTC-04:00) Atlantic Time (Canada)
(UTC-04:00) Cuiaba
(UTC-04:00) Georgetown, La Paz, Manaus, San Juan
(UTC-04:00) Santiago
(UTC-04:00) Asuncion
(UTC-03:30) Newfoundland
(UTC-03:00) Brasilia
(UTC-03:00) Buenos Aires
(UTC-03:00) Greenland
(UTC-03:00) Cayenne, Fortaleza
(UTC-03:00) Montevideo
(UTC-02:00) Coordinated Universal Time-02
(UTC-01:00) Cape Verde Is.
(UTC-01:00) Azores
(UTC) Dublin, Edinburgh, Lisbon, London
(UTC) Casablanca
(UTC) Monrovia, Reykjavik
(UTC) Coordinated Universal Time
(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna
(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague
(UTC+01:00) Brussels, Copenhagen, Madrid, Paris
(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb
(UTC+01:00) Windhoek
(UTC+01:00) West Central Africa
(UTC+02:00) Amman
(UTC+02:00) Beirut
(UTC+02:00) Damascus
(UTC+02:00) Harare, Pretoria
(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Talinn, Vilnius
(UTC+02:00) Cairo
(UTC+02:00) Athens, Bucharest, Istanbul
(UTC+02:00) Jerusalem
(UTC+03:00) Baghdad
(UTC+03:00) Kuwait, Riyadh
(UTC+03:00) Minsk
(UTC+03:00) Moscow, St.Petersburg, Volgograd
(UTC+03:00) Nairobi
(UTC+03:30) Tehran
(UTC+04:00) Abu Dhabi, Muscat
(UTC+04:00) Yerevan
(UTC+04:00) Baku
(UTC+04:00) Tbilisi
(UTC+04:00) Port Louis
(UTC+04:30) Kabul
(UTC+05:00) Tashkent
(UTC+05:00) Ekaterinburg
(UTC+05:00) Islamabad, Karachi
(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi
(UTC+05:30) Sri Jayawardenepura
(UTC+05:45) Kathmandu
(UTC+06:00) Astana
(UTC+06:00) Dhaka
(UTC+06:00) Novosibirsk
(UTC+06:30) Yangon (Rangoon)
(UTC+07:00) Kobdo
(UTC+07:00) Krasnoyarsk
(UTC+07:00) Bangkok, Hanoi, Jakarta
(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi
(UTC+08:00) Kuala Lumpur, Singapore
(UTC+08:00) Perth
(UTC+08:00) Taipei
(UTC+08:00) Ulaanbaatar
(UTC+08:00) Irkutsk
(UTC+09:00) Pyongyang
(UTC+09:00) Osaka, Sapporo, Tokyo
(UTC+09:00) Seoul
(UTC+09:00) Yakutsk
(UTC+09:30) Adelaide
(UTC+09:30) Darwin
(UTC+10:00) Brisbane
(UTC+10:00) Vladivostok
(UTC+10:00) GuamPort Moresby
(UTC+10:00) Hobart
(UTC+10:00) Canberra, Melbourne, Sydney
(UTC+10:30) Lord Howe Island
(UTC+11:00) Magadan
(UTC+11:00) Solomon Is., New Caledonia
(UTC+12:00) Auckland, Wellington
(UTC+12:00) Fiji
(UTC+12:00) Coordinated Universal Time+12
(UTC+12:45) Chatham Islands
(UTC+13:00) Nuku'alofa
(UTC+14:00) Christmas Island
EOF
}

function printTimezones
{
  local n
  n=0
  printf "%3s %s\n" "tzi" "timezone" #tzi timezone index
  for tz in "${SYSTEM_TIMEZONE[@]}"; do
    printf "%3d %s\n" $n "$tz"
    (( n++ ))
  done
}

function parsePacket {
  typeset -i cmd
  RX_POS=4 # current read position/after packet length byte for indexing PACKET_RX_OD[1] - ASCII string from od utility

  cmd=0x${PACKET_RX[2]}

  #Packet length
  if [[ "$cmd" -eq  $CMD_broadcast ]] || [[ "$cmd" -eq $CMD_livedata ]] || [[ "$cmd" -eq $CMD_read_sensor_id_new ]]; then

      RX_POS=5    
      #printf -v PACKET_RX_LENGTH "%u" "0x${PACKET_RX[3]}${PACKET_RX[4]}" 2>/dev/null || 
      PACKET_RX_LENGTH=$(( 0x${PACKET_RX[3]}${PACKET_RX[4]} ))
   else  
       PACKET_RX_LENGTH=$(( 0x${PACKET_RX[3]} ))
  fi

  [ $DEBUG -eq 1 ] && echo >&2 "Parse packet ${PACKET_RX[*]} length $PACKET_RX_LENGTH"

  if [[  "$cmd" -eq $CMD_write_reset ]]            ||
     [[  "$cmd" -eq $CMD_write_customized ]]       || 
     [[  "$cmd" -eq $CMD_write_path ]]             || 
     [[  "$cmd" -eq $CMD_reboot ]]                 || 
     [[  "$cmd" -eq $CMD_write_ssid ]]             ||
     [[  "$cmd" -eq $CMD_write_raindata ]]         ||
     [[  "$cmd" -eq $CMD_write_ecowitt_interval ]] ||
     [[  "$cmd" -eq $CMD_write_wunderground ]]     ||
     [[  "$cmd" -eq $CMD_write_wow ]]              ||
     [[  "$cmd" -eq $CMD_write_weathercloud ]]     || 
     [[  "$cmd" -eq $CMD_write_sensor_id ]]        || 
     [[  "$cmd" -eq $CMD_write_system ]]; then 
    parseResultPacket

  elif [[  "$cmd" -eq $CMD_read_mac ]]; then

    CONFIGURATION[$CONF_mac]=$(printf "%02X:%02X:%02X:%02X:%02X:%02X" 0x"${PACKET_RX[4]}" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}")
    CONFIGURATION_DISCOVER+=("$CONF_mac")
    echo "${CONFIGURATION[$CONF_mac]}"

  elif [[  "$cmd" -eq $CMD_read_version ]]; then

    readString
    CONFIGURATION[$CONF_version]=$VALUE_STRING
    CONFIGURATION_DISCOVER+=("$CONF_version")

    echo "${CONFIGURATION[$CONF_version]}"

  elif [[  "$cmd" -eq $CMD_read_system ]]; then
  
     readUInt8
     CONFIGURATION[$CONF_system_frequency]=$VALUE_UINT8
     if [[ "${CONFIGURATION[$CONF_system_frequency]}"  -eq $SYSTEM_FREQUENCY_RFM433M ]]; then
       CONFIGURATION[$CONF_system_frequency_state]="433MHz"
     elif [[ "${CONFIGURATION[$CONF_system_frequency]}"  -eq $SYSTEM_FREQUENCY_RFM868M ]]; then
       CONFIGURATION[$CONF_system_frequency_state]="868MHz"
     elif [[ "${CONFIGURATION[$CONF_system_frequency]}"  -eq $SYSTEM_FREQUENCY_RFM915M ]]; then
       CONFIGURATION[$CONF_system_frequency_state]="915MHz"
     elif [[ "${CONFIGURATION[$CONF_system_frequency]}"  -eq $SYSTEM_FREQUENCY_RFM920M ]]; then
       CONFIGURATION[$CONF_system_frequency_state]="920MHz"
     fi
     echo System Frequency "${CONFIGURATION[$CONF_system_frequency]}" "${CONFIGURATION[$CONF_system_frequency_state]}"

     readUInt8
     CONFIGURATION[$CONF_system_sensor_type]=$VALUE_UINT8 # 0=WH24, 1=WH65

     if [[ "${CONFIGURATION[$CONF_system_sensor_type]}" -eq $SYSTEM_SENSOR_TYPE_WH24 ]]; then
       CONFIGURATION[$CONF_system_sensor_type_state]="WH24"
     elif [[  "${CONFIGURATION[$CONF_system_sensor_type]}" -eq $SYSTEM_SENSOR_TYPE_WH65 ]]; then
       CONFIGURATION[$CONF_system_sensor_type_state]="WH65"
      
     fi
     echo System type "${CONFIGURATION[$CONF_system_sensor_type]}" "${CONFIGURATION[$CONF_system_sensor_type_state]}"

     readUInt32BE
     CONFIGURATION[$CONF_system_utc]=$VALUE_UINT32BE # UTC time (seconds)
     CONFIGURATION[$CONF_system_utc_state]=$(date -u -d @"$VALUE_UINT32BE" +'%F %T')
     echo "${CONFIGURATION[$CONF_system_utc_state]}" System utc "$VALUE_UINT32BE" 
     #while true; do time ./gw  -h 192.168.3.80 -c system | grep utc; date -u; sleep 0.6; done #see time difference between machine time and device time

     readUInt8
     CONFIGURATION[$CONF_system_timezone_index]=$VALUE_UINT8 # 39 = UTC
     initTimezones
     CONFIGURATION[$CONF_system_timezone_index_state]=${SYSTEM_TIMEZONE[CONFIGURATION[$CONF_system_timezone_index]]}
     echo System timezone index "${CONFIGURATION[$CONF_system_timezone_index]}" "${CONFIGURATION[$CONF_system_timezone_index_state]}" 

     
     readUInt8
     CONFIGURATION[$CONF_system_dst_status]=$VALUE_UINT8
      CONFIGURATION[$CONF_system_dst_status_bit]=$(( ${CONFIGURATION[$CONF_system_dst_status]} & 0x1 ))
     if [[  "${CONFIGURATION[$CONF_system_dst_status_bit]}" -eq 1 ]]; then
        CONFIGURATION[$CONF_system_dst_status_state]="on";
      elif [[ "${CONFIGURATION[$CONF_system_dst_status_bit]}" -eq 0 ]]; then
        CONFIGURATION[$CONF_system_dst_status_state]="off"
     fi  
     CONFIGURATION[$CONF_system_timezone_auto_bit]=$(( ( ${CONFIGURATION[$CONF_system_dst_status]} & 0x2 ) >> 1 )) # bit 2 1= off, 0=on ?
     if [[  "${CONFIGURATION[$CONF_system_timezone_auto_bit]}" -eq 0 ]]; then
        CONFIGURATION[$CONF_system_timezone_auto_state]="on";
      elif [[  "${CONFIGURATION[$CONF_system_timezone_auto_bit]}" -eq 1 ]]; then
        CONFIGURATION[$CONF_system_timezone_auto_state]="off"
     fi

     CONFIGURATION_DISCOVER+=("$CONF_system_frequency" "$CONF_system_frequency_state" "$CONF_system_sensor_type" "$CONF_system_sensor_type_state"
      "$CONF_system_utc" "$CONF_system_utc_state" "$CONF_system_timezone_index" "$CONF_system_timezone_index_state" 
      "$CONF_system_dst_status" "$CONF_system_dst_status_bit" "$CONF_system_dst_status_state" "$CONF_system_timezone_auto_bit" "$CONF_system_timezone_auto_state"  )

     echo System DST status "$VALUE_UINT8" dst "${CONFIGURATION[$CONF_system_dst_status_state]}" auto timezone "${CONFIGURATION[$CONF_system_timezone_auto_state]}"

  elif [[  "$cmd" -eq $CMD_read_ecowitt_interval ]]; then

    readUInt8
    CONFIGURATION[$CONF_ecowitt_interval]=$VALUE_UINT8
    CONFIGURATION_DISCOVER+=("$CONF_ecowitt_interval")
    echo "ecowitt_interval ${CONFIGURATION[$CONF_ecowitt_interval]} minutes"

  elif [[  "$cmd" -eq $CMD_read_wunderground ]]; then

    readString
    CONFIGURATION[$CONF_wunderground_id]=$VALUE_STRING
    
    readString
    CONFIGURATION[$CONF_wunderground_password]=$VALUE_STRING

    CONFIGURATION_DISCOVER+=("$CONF_wunderground_id" "$CONF_wunderground_password")

    echo "wunderground_id ${CONFIGURATION[$CONF_wunderground_id]}"
    echo "wunderground_password ${CONFIGURATION[$CONF_wunderground_password]}"
  
  elif [[  "$cmd" -eq $CMD_read_wow ]]; then

    readString
    CONFIGURATION[$CONF_wow_id]=$VALUE_STRING

    readString
    CONFIGURATION[$CONF_wow_password]=$VALUE_STRING

    CONFIGURATION_DISCOVER+=("$CONF_wow_id" "$CONF_wow_password")


    echo "wow_id ${CONFIGURATION[$CONF_wow_id]}"
    echo "wow_password ${CONFIGURATION[$CONF_wow_password]}"

  elif [[  "$cmd" -eq $CMD_read_weathercloud ]]; then

    readString
    CONFIGURATION[$CONF_weathercloud_id]=$VALUE_STRING
    
    readString
    CONFIGURATION[$CONF_weathercloud_password]=$VALUE_STRING
    
    CONFIGURATION_DISCOVER+=("$CONF_weathercloud_id" "$CONF_weathercloud_password")

    echo "weathercloud_id ${CONFIGURATION[$CONF_weathercloud_id]}"
    echo "weathercloud_password ${CONFIGURATION[$CONF_weathercloud_password]}"
  
  elif [[  "$cmd" -eq $CMD_read_customized ]]; then

    readString
    CONFIGURATION[$CONF_customized_id]=$VALUE_STRING

    readString
    CONFIGURATION[$CONF_customized_password]=$VALUE_STRING

    readString
    CONFIGURATION[$CONF_customized_server]=$VALUE_STRING

    readUInt16BE
    CONFIGURATION[$CONF_customized_port]=$VALUE_UINT16BE

    readUInt16BE
    CONFIGURATION[$CONF_customized_interval]=$VALUE_UINT16BE

    readUInt8
    CONFIGURATION[$CONF_customized_type]=$VALUE_UINT8
    
    readUInt8
    CONFIGURATION[$CONF_customized_enabled]=$VALUE_UINT8

    CONFIGURATION_DISCOVER+=("$CONF_customized_id" "$CONF_customized_password" "$CONF_customized_server" "$CONF_customized_port" 
        "$CONF_customized_interval" "$CONF_customized_type" "$CONF_customized_enabled" )


    printCustomized

  elif [[  "$cmd" -eq $CMD_read_path ]]; then

    readString
    CONFIGURATION[$CONF_customized_ecowitt_path]=$VALUE_STRING
    readString
    CONFIGURATION[$CONF_customized_wunderground_path]=$VALUE_STRING
    CONFIGURATION_DISCOVER+=("$CONF_customized_ecowitt_path" "$CONF_customized_wunderground_path")
  
  elif [[  "$cmd" -eq $CMD_broadcast ]]; then
    #this is the station MAC/ip on local network, when device is reset its annoncing hotspot accesspoint/AP with first byte of MAC changed
    # shellcheck disable=SC2102
   # echo PACKET RX "${PACKET_RX[@]}" "${!PACKET_RX[@]}"
    #printf -v CONFIGURATION[$CONF_broadcast_mac] "%02X:%02X:%02X:%02X:%02X:%02X" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}" 0x"${PACKET_RX[10]}" ||
    CONFIGURATION[$CONF_broadcast_mac]=$( printf "%02X:%02X:%02X:%02X:%02X:%02X" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}" 0x"${PACKET_RX[10]}")

    # shellcheck disable=SC2102
    #printf -v CONFIGURATION[$CONF_broadcast_ip] "%u.%u.%u.%u" 0x"${PACKET_RX[11]}" 0x"${PACKET_RX[12]}" 0x"${PACKET_RX[13]}" 0x"${PACKET_RX[14]}" ||
    CONFIGURATION[$CONF_broadcast_ip]=$(printf "%u.%u.%u.%u" 0x"${PACKET_RX[11]}" 0x"${PACKET_RX[12]}" 0x"${PACKET_RX[13]}" 0x"${PACKET_RX[14]}" )
    
    RX_POS=17
    local ssid
    local version
    #        IFS=' '; read -r ssid version <<< "${PACKET_RX_OD[1]:(( $pos + 1)):0x${PACKET_RX[$pos]}}" # ssid appends space+version
    readString
    IFS=' '
    read -r ssid version <<<"$VALUE_STRING" # ssid appends space+version

    CONFIGURATION[$CONF_broadcast_ssid]=$ssid
    CONFIGURATION[$CONF_broadcast_version]=$version
    # shellcheck disable=SC2102
    #printf -v CONFIGURATION[$CONF_broadcast_port] "%u" 0x"${PACKET_RX[15]}""${PACKET_RX[16]}" ||
    CONFIGURATION[$CONF_broadcast_port]=$(( 0x${PACKET_RX[15]}${PACKET_RX[16]} ))

    CONFIGURATION_DISCOVER+=("$CONF_broadcast_mac" "$CONF_broadcast_ip" "$CONF_broadcast_ssid" "$CONF_broadcast_version" "$CONF_broadcast_port")

    echo "${CONFIGURATION[$CONF_broadcast_mac]} ${CONFIGURATION[$CONF_broadcast_ip]}:${CONFIGURATION[$CONF_broadcast_port]} ${CONFIGURATION[$CONF_broadcast_ssid]} ${CONFIGURATION[$CONF_broadcast_version]}"

  elif [[  "$cmd" -eq $CMD_read_raindata ]]; then

    # echo "${PACKET_RX_HEX}" "$RX_POS_HEX"
    readUInt32BE
    CONFIGURATION[$CONF_rainrate]=$VALUE_UINT32BE
    readUInt32BE
    CONFIGURATION[$CONF_raindaily]=$VALUE_UINT32BE
    readUInt32BE
    CONFIGURATION[$CONF_rainweek]=$VALUE_UINT32BE
    readUInt32BE
    CONFIGURATION[$CONF_rainmonth]=$VALUE_UINT32BE
    readUInt32BE
    CONFIGURATION[$CONF_rainyear]=$VALUE_UINT32BE

    CONFIGURATION_DISCOVER+=("$CONF_rainrate" "$CONF_raindaily" "$CONF_rainweek" "$CONF_rainmonth" "$CONF_rainyear")

    printRain

  elif [[  "$cmd" -eq $CMD_livedata ]]; then

    parseLivedata "$SPATTERN" # use time for performance monitoring/optimization

  elif [[  "$cmd" -eq $CMD_read_sensor_id_new ]] || [[  "$cmd" -eq $CMD_read_sensor_id ]]; then

    time parseSensor 1
     
  else

    echo >&2 "Warning unable to parse response for command $cmd $PACKET_RX_HEX"
  fi
}

function newPacketBody {
  # PACKET BODY STARTING AT BYTE 2 (from 0 index, first 0xff 0xff)

  if [ -z "$1" ]; then
      >&2 echo Error no command given to newPacketBody
      return 1
  fi
  
  #PACKET_BODY=() - ksh set array to length 1 here!?
  unset PACKET_BODY
  decToHex  $(( $1 ))
  PACKET_BODY+=("$VALUE_HEX" "0x00")
  [ $DEBUG -eq 1 ] && >&2 echo PACKET BODY "${PACKET_BODY[@]}"
  
  if [[ "$1" -eq $CMD_broadcast ]] || [[ "$1" -eq $CMD_write_ssid ]]; then  
   # WSVIEW sends 2 byte field for size
    PACKET_BODY+=("0x00")
    [ $DEBUG -eq 1 ] && echo >&2 appending 0x00 for 2-byte packet length PACKET BODY "${PACKET_BODY[@]}"
  fi 
}

function printPacketBody
{
  echo -------------------------- PACKET_BODY_LENGTH "${#PACKET_BODY[@]}"
  local n
  n=0
  while [ "$n" -lt ${#PACKET_BODY[@]} ]; do
     printf "%d %x\n" "$n" "${PACKET_BODY[$n]}"
     n=$(( n + 1))
  done
}
function createPacketTX {
  local packetLengthLSB
  local packetLengthMSB
  local n


  #Update packet length, either 1 or 2 bytes
  case ${PACKET_BODY[0]} in
  
        "$CMD_write_ssid" | "$CMD_broadcast")

          packetLengthLSB=$((   (${#PACKET_BODY[@]} + 1) & 0xff ))
          packetLengthMSB=$(( ( (${#PACKET_BODY[@]} + 1) & 0xff00 ) >> 8 ))
          decToHex $packetLengthMSB
          PACKET_BODY[1]=$VALUE_HEX
          decToHex $packetLengthLSB
          PACKET_BODY[2]=$VALUE_HEX
          ;;
        
        *)
          decToHex $(( ${#PACKET_BODY[@]} + 1 ))
          PACKET_BODY[1]=$VALUE_HEX # set packet length including checksum byte

          ;;
  esac

  checksum

  PACKET_TX=(0xff 0xff "${PACKET_BODY[@]}" "$CHECKSUM")
  PACKET_TX_COMMAND=$(( PACKET_TX[2] )) # convert to decimal/integer for comparison in sendPacket

  [ $DEBUG -eq 1 ] && echo >&2 PACKET_TX "${PACKET_TX[@]//0x/''}"

  unset PACKET_TX_ECHO
  
  n=0
 # for n in "${!PACKET_TX[@]}"; do
  while [ "$n" -lt "${#PACKET_TX[@]}" ]; do
    PACKET_TX_ECHO+=${PACKET_TX[$n]}
    n=$(( n + 1 ))
  done
  
  PACKET_TX_ECHO=${PACKET_TX_ECHO//0x/'\x'}

  [ $DEBUG -eq 1 ] && echo >&2 PACKET_TX_ECHO "$PACKET_TX_ECHO"

}

function readResponseCat {
  local timeoutCat
  timeoutCat=0.025 # Wireshark [Time delta from previous captured frame: 0.013166760 seconds]
  #   [ $DEBUG -eq 1 ] && timeoutOptions='-v'
  # cat inside while (true) { continue read }
  #https://github.com/coreutils/coreutils/blob/bbb19b18687d5572dcbe7bbb1a48c8ee0f21786b/src/cat.c#L168
  # Actually response is read in the first call to read, then a second read is started on stdin/redirected FD, so cat has to be killed...
  # timeout "$timeoutOptions"--preserve-status $timeoutCat cat <&"$FD" >$FILENAME_RESPONSE
  cat <&"$FD" >"$FILENAME_rx" &
  sleep $timeoutCat
  kill %1
}

function readResponseDD {
  local dd_result
  [ $DEBUG -eq 1 ] && unset "DEBUG_OPTIONS_dd"
  # shellcheck disable=SC2086
  timeout 0.5 dd bs=1024 count=1 ${DEBUG_OPTIONS_dd} <&"$FD" >$FILENAME_rx # timeout request, for example EasyWeather doesnt respond to rain command
  dd_result=$?
  if [ $dd_result -ne 0 ]; then
    echo >&2 Error DD failed to read response from FD "$FD", status "$dd_result"
  fi
  [ $DEBUG -eq 1 ] && echo >&2 dd_result $dd_result
  return $dd_result

}

function readHexASCII {
  unset PACKET_RX_HEX # compact hex string without spaces ffff
  od -A n -t x1 -v -w"$(stat -c %s "$1")"  "$1" >"$FILENAME_od_hex"; 
  read -r  PACKET_RX_OD_HEX <"$FILENAME_od_hex" 
  [ $DEBUG -eq 1 ] && echo >&2 OD HEX "$PACKET_RX_OD_HEX"
  
  convert_od_hexStringToArray "$PACKET_RX_OD_HEX" 
   #readarray -d ' ' -t PACKET_RX < <(echo -n "${PACKET_RX_OD[0]:1:-2}") # :1 substring, removes space at the beginning, -2: removes two trailing spaces
  PACKET_RX_HEX=${PACKET_RX_OD_HEX// /}                                 # strip off all spaces, just hex

}

function convert_od_hexStringToArray 
{
  local hexCode
 IFS=' '
 unset PACKET_RX
 for hexCode in $1; do
   PACKET_RX+=( "$hexCode" )
 done
}

function sendPacket
{
  sendPacketnc "$@"
  #sendPacketdd "$@"
}

function sendPacketnc
{
  local ncUDPOpt 
  local ncIdle
  local port
  local ncStatus

  #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
  if [ $# -ge 1 ]; then
    newPacketBody "$1"
  fi

  createPacketTX

  if [[ $PACKET_TX_COMMAND -eq  $CMD_broadcast ]]; then
            ncUDPOpt='-u'
            port=$PORT_udp_discovery_client #change to UDP from TCP default
  elif [[ "$PACKET_TX_COMMAND" -eq $CMD_write_reset || "$PACKET_TX_COMMAND" -eq $CMD_write_ssid ]]; then
       # some commands needs idle timeout
         [ $DEBUG -eq 1 ] && >&2 echo "${CMD_NAME["$PACKET_TX_COMMAND"]}" Setting device idle timeout for nc
         ncIdle='-i 100ms'
  else
     unset ncUDPOpt
     #1>&2 echo ncUDPOpt $ncUDPOpt
     port=$PORT_tcp_command_server
  
  fi
  #  ncIdle='-i 25ms'
  # shellcheck disable=SC2059
  printf "$PACKET_TX_ECHO" >"$FILENAME_tx"
  rm "$FILENAME_rx" 2>/dev/null
  rm "$FILENAME_nc_hex" 2>/dev/null

  # shellcheck disable=SC2086
 #{ cat "$FILENAME_tx"; sleep 0.1; } |  nc  $ncUDPOpt $ncIdle -w 500ms -x "$FILENAME_nc_hex" -4 "$HOST" "$port"  >"$FILENAME_rx" # wait 0.1s to disable READ KILL of nc on stdin
  { cat "$FILENAME_tx"; sleep 0.1; } |  nc $DEBUG_OPTIONS_nc $ncUDPOpt $ncIdle -w 500ms  -4 "$HOST" "$port"  >"$FILENAME_rx" # wait 0.1s to disable READ KILL of nc on stdin

  ncStatus=$?
  
  if [ -s "$FILENAME_rx" ] && [ $ncStatus -eq 0 ] ; then # -s file exists and not empty

        if od -A n -t x1 -v -w"$(stat -c %s "$FILENAME_rx")" "$FILENAME_rx" >"$FILENAME_od_hex"; then
            read -r PACKET_RX_OD_HEX <"$FILENAME_od_hex"
           [ $DEBUG -eq 1 ] && { cat "$FILENAME_nc_hex"; echo >&2 OD HEX "$PACKET_RX_OD_HEX" length "${#PACKET_RX_OD_HEX}"; }
            PACKET_RX_HEX=${PACKET_RX_OD_HEX// /}                                 # strip off all spaces, just hex
            if [ ${#PACKET_RX_HEX} -eq  0 ]; then
                echo >&2 "Warning no data in response received from host"
            else
                [  "$DEBUG" -eq 1 ] && echo >&2 PACKET_RX_HEX "$PACKET_RX_HEX" length "${#PACKET_RX_HEX}"
                convert_od_hexStringToArray "$PACKET_RX_OD_HEX"
               parsePacket
            fi
        else
          echo >&2 Error od failed to create hex decoding for packet, error code $?
        fi

  else
   >&2 echo  "$(date)" Error nc failed to receive response or empty response for command "${CMD_NAME["$PACKET_TX_COMMAND"]}", nc error code $ncStatus, "$FILENAME_rx"
  fi
}

#including checksum byte
function sendPacketdd {
  #takes two arguments $1 - command, $2 is udp broadcast request
  local FD
  FD=$FD_TCP # default TCP command port

  [ -n "$2" ] && FD="$2" #may also use UDP for broadcast (ssid etc.)
  if [ ! -v FD ]; then
    echo >&2 Error connection to host not available, missing -h to host?
    exit $ERROR_CONNECTION
  fi

  [ $DEBUG -eq 1 ] && echo >&2 "Using FD $FD for sending packet"

  #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
  if [ $# -ge 1 ]; then
    newPacketBody "$1"
  fi

  # write command/read response

  createPacketTX
    # shellcheck disable=SC2059
  printf "$PACKET_TX_ECHO" >"$FILENAME_tx"
  #printf "%b" "$PACKET_TX_ECHO" >&"$FD" # echo -ne/printf "%b" splits packet at 0x0a if written directly to FD
  [ $DEBUG -eq 1 ] && unset "DEBUG_OPTIONS_dd"
  
  if dd if="$FILENAME_tx" ${DEBUG_OPTIONS_dd} >&"$FD"; then 

      if readResponseDD; then #readResponseCat

        PACKET_TIMESTAMP=$(date)
        readHexASCII "$FILENAME_rx"

        if [ ${#PACKET_RX[@]} -eq 0 ]; then
          echo >&2 "$HOST Warning no response received from host"
        else
          parsePacket
        fi
      fi
  else
     echo >&2 Error DD failed to send packet to FD "$FD", dd status $?
  fi

}

function discovery {
  local TIMEOUT_SCAN
  TIMEOUT_SCAN=2 #seconds
  local rxscan
  local rxscan_sorted
  local socat_discovery_server_pid
  local n
  local hex_escape

  [ $DEBUG -eq 0 ] && unset "DEBUG_OPTIONS_socat"

  [ $DEBUG -eq 1 ] && echo >&2 "UDP discovery on GW port $PORT_udp_discovery_client"
  [ $DEBUG -eq 1 ] && echo >&2 "UDP discovery on local port $PORT_udp_discovery_server"
  # shellcheck disable=SC2086
  socat $DEBUG_OPTIONS_socat -u UDP-RECV:"$PORT_udp_discovery_server" CREATE:$FILENAME_udp_server & # move in background
  socat_discovery_server_pid=$!
  [ $DEBUG -eq 1 ] && echo >&2 Socat discovery server PID = $socat_discovery_server_pid

  newPacketBody $CMD_broadcast
  createPacketTX
  #-R socat appends to file
  # shellcheck disable=SC2086
  {
    # shellcheck disable=SC2059
    printf "$PACKET_TX_ECHO"
    sleep $TIMEOUT_SCAN
  } | socat $DEBUG_OPTIONS_socat -R "$FILENAME_udp_client" - udp-datagram:255.255.255.255:$PORT_udp_discovery_client,broadcast >/dev/null #disable stdout echo of rx data, sleep timeout EOF on STDIN
  #(printf "\xff\xff\x12\x00\x04\x16"; sleep 3) | socat -d -d -x -R rxsocat  - udp-datagram:255.255.255.255:46000,broadcast
  kill $socat_discovery_server_pid

  cat "$FILENAME_udp_client" "$FILENAME_udp_server" >"$FILENAME_discovery" # Merge results from udp/tcp discovery
  #ff ff 12 00 27 48 3f da 54 14 ec c0 a8 03 50 af c8 17 47 57 31 30 30 30 41 2d 57 49 46 49 31 34 45 43 20 56 31 2e 36 2e 38 91
  # .  .  .  .  '  H  ?  .  T  .  .  .  .  .  P  .  .  .  G  W  1  0  0  0  A  -  W  I  F  I  1  4  E  C     V  1  .  6  .  8

  rxscan=$(od -A n -t x1 -v -w"$(stat -c %s "$FILENAME_discovery")" "$FILENAME_discovery")
  [ $DEBUG -eq 1 ] && echo Keeping files in "$PWD" "$FILENAME_discovery" "$FILENAME_udp_client" "$FILENAME_udp_server"
  ((!DEBUG)) && rm "$FILENAME_discovery" "$FILENAME_discovery_sorted" "$FILENAME_udp_client" "$FILENAME_udp_server"

  rxscan_sorted=$(echo -en "${rxscan//" ff ff 12"/"\nff ff 12"}" | sort -u | tail -n +3) # Skips first few lines which is a newline followed by broadcast (0x12) command

  echo -n "$rxscan_sorted" >"$FILENAME_discovery_sorted"

  while read -r line; do # loop through all received broadcasts and parse them
    if expr "$line" : "ff ff 12"; then
      hex_escape=""
      n=0
      while [ "$n" -lt  ${#line} ]; do
        hex_escape="$hex_escape\x${line:$n:2}" # create \x escape codes for echo
         n=$(( n + 3))
      done
          # shellcheck disable=SC2059
      printf "$hex_escape" >"$FILENAME_rx"
      readHexASCII "$FILENAME_rx"
      parsePacket
    fi
  done <<<"$rxscan_sorted"

}

function checksum {
  local n
  #caller 0

  CHECKSUM=0
  [ $DEBUG -eq 1 ] && echo >&2 checksum start PACKET_BODY "${PACKET_BODY[@]}"
  #http://mywiki.wooledge.org/BashGuide/Arrays
  #for ((n = 0; n < ${#PACKET_BODY[@]}; n++)); do
  #for n in "${!PACKET_BODY[@]}"; do
   n=0;
   while [ "$n" -lt "${#PACKET_BODY[@]}" ]; do
    CHECKSUM=$(( (CHECKSUM + ${PACKET_BODY[$n]}) & 0xff ))
    n=$(( n + 1))
   done
  decToHex $CHECKSUM
  CHECKSUM=$VALUE_HEX
  [ $DEBUG -eq 1 ] && echo >&2 CHECKSUM "$CHECKSUM"
}

function writeString {
  local n

  [ $DEBUG -eq 1 ] && echo >&2 "${FUNCNAME[0]} $1 len ${#1}"
  decToHex ${#1}
  PACKET_BODY+=("$VALUE_HEX")
  n=0
  while [ "$n" -lt ${#1} ]; do
    decToHex "'${1:$n:1}"
    PACKET_BODY+=("$VALUE_HEX")
    n=$(( n + 1 ))
  done
}

function writeUInt32BE {
  writeUInt 32 "$1"
}
function writeUInt16BE {
  writeUInt 16 "$1"
}

function writeUInt8 {
  writeUInt 8 "$1"
}

function writeUInt {
  local hex

  case $1 in
      
       8)  #printf -v hex "%02x" "$2" 2>/dev/null ||  
           hex=$( printf "%02x" "$2")
           VALUE_HEX=$hex
            ;;
      
      16) #printf -v hex "%04x" "$2" 2>/dev/null ||  
          hex=$( printf  "%04x" "$2")
          VALUE_UINT16BE_HEX=$hex
           ;;
      
      32) #printf -v hex "%08x" "$2" 2>/dev/null ||
          hex=$(  printf "%08x" "$2" )
          VALUE_UINT32BE_HEX=$hex
          ;;
  esac
   
  n=0
  while  [ "$n" -lt ${#hex} ]; do # Convert to byte array
    PACKET_BODY+=(0x"${hex:$n:2}")
    n=$(( n + 2))
  done
}

function decToHex {
  [ $DEBUG -eq 1 ] && echo >&2 $BASHPID "$1"
  #printf -v VALUE_HEX "0x%02x" "$1" >/dev/null 2>/dev/null ||  
  VALUE_HEX=$( printf "0x%02x" "$1" ) 
    
}

function newCustomizedPacket {
  newPacketBody $CMD_write_customized
  writeString "${CONFIGURATION[$CONF_customized_id]}"
  writeString "${CONFIGURATION[$CONF_customized_password]}"
  writeString "${CONFIGURATION[$CONF_customized_server]}"
  writeUInt16BE "${CONFIGURATION[$CONF_customized_port]}"
  writeUInt16BE "${CONFIGURATION[$CONF_customized_interval]}"
  writeUInt8 "${CONFIGURATION[$CONF_customized_type]}"
  writeUInt8 "${CONFIGURATION[$CONF_customized_enabled]}"
}

function newPathPacket {
  newPacketBody $CMD_write_path
  writeString "${CONFIGURATION[$CONF_customized_wunderground_path]}"
  writeString "${CONFIGURATION[$CONF_customized_ecowitt_path]}"
}

function sendSystem
{
 
  local dst
  dst=0

  if ! isNumber "$1" || [ "$1" -gt 1 ]; then
    echo Error: System type must be 0 for WH24, or 1 for WH65 - "$1" invalid
    return $ERROR_SYSTEMPARAM_NOTSPECIFIED
  fi

  if ! isNumber "$2" || [ "$2" -ge ${#SYSTEM_TIMEZONE[@]} ]; then
     echo Error: System timezone index must be 0 -  $(( ${#SYSTEM_TIMEZONE[@]} - 1 )) - "$2" invalid
     printTimezones 
     return $ERROR_SYSTEMPARAM_NOTSPECIFIED
  fi

  if ! isNumber "$3" || [ "$3" -gt 1 ]; then
    echo Error: Daylight saving must be 0 for disabled, or 1 for enabled - "$3" invalid
    return $ERROR_SYSTEMPARAM_NOTSPECIFIED
  fi


  if ! isNumber "$4" || [ "$4" -gt 1 ]; then
    echo Error: Auto timezone must be 0 for disabled, or 1 for enabled - "$4" invalid
    return $ERROR_SYSTEMPARAM_NOTSPECIFIED
  fi

  #TODO dst=

#        CONFIGURATION[$CONF_system_dst_status_bit]=$(( "${CONFIGURATION[$CONF_system_dst_status]}" & 0x1 ))
#     CONFIGURATION[$CONF_system_timezone_auto_bit]=$(( ( "${CONFIGURATION[$CONF_system_dst_status]}" & 0x2 ) >> 1 )) # bit 2 1= off, 0=on ?
  
  if [  "$4" -eq 0 ]; then
    dst=$(( $3 | 2 ))
  else
    dst=$(( $3 ))
  fi

  newPacketBody $CMD_write_system
  writeUInt8 0    #frequency - only read
  writeUInt8 "$1"   #sensortype 0=WH24, 1=WH65
  writeUInt32BE 0 #UTC time - only read
  writeUInt8 "$2"   #timezone index
  writeUInt8 "$dst"   #daylight saving - dst
  sendPacket
}

function sendRaindata {
 # if ! [[ "$1" =~ ^[0-9]+$ ]] || ! [[ "$2" =~ ^[0-9]+$ ]] || ! [[ "$3" =~ ^[0-9]+$ ]] || ! [[ "$4" =~ ^[0-9]+$ ]]; then
 if ! isNumber "$1" || ! isNumber "$2" || ! isNumber "$3" || ! isNumber "$4"; then
    echo Error: Raindata has "element(s)" which is not a number
    return $ERROR_RAINDATA_NOTSPECIFIED
  fi 

  [ $DEBUG -eq 1 ] && >&2 echo  rainday "$2" rainweek "$3" rainmonth "$4" rainyear "$5"
  
  newPacketBody $CMD_write_raindata
  writeUInt32BE "$1" #rainday
  writeUInt32BE "$2" #rainweek
  writeUInt32BE "$3" #rainmonth
  writeUInt32BE "$4" #rainyear
  [ $DEBUG -eq 1 ] && echo >&2 "Sending raindata rd $1 rw $2 rm $3 ry $4"
  sendPacket
}

function sendEcowittInterval {
# observation: GW1000 red-wifi led blinks slowly if not sending data to ecowitt when 0=off
  case "$1" in
    0|1|2|3|4|5)
      newPacketBody $CMD_write_ecowitt_interval
      writeUInt8 "$1" #interval
      [ $DEBUG -eq 1 ] && echo >&2 Sending ecowitt interval "$1"
      sendPacket
      ;;
    *) >&2 echo Error Not a valid ecowitt interval, range 0-5 minutes
      ;;
   esac
}

function sendWeatherservice {

  newPacketBody "$1"
  writeString "$2"
  writeString "$3"
  
  case "$1" in
      "$CMD_write_wow")
        writeUInt8 0 # stationnum size - unused
        writeUInt8 1
        ;;
        
      "$CMD_write_weathercloud")
        writeUInt8 1
        ;;
  esac
  [ $DEBUG -eq 1 ] && echo >&2 "Sending weather service $1 id $2 password $3"
  sendPacket
}

function sendCustomized {
  newCustomizedPacket
  sendPacket

  newPathPacket
  sendPacket

  if [ $DEBUG -eq 1 ]; then
    echo >&2 "Sending customized settings"
    printCustomized >&2
  fi
}

function sendSensor
{
  newPacketBody $CMD_write_sensor_id
  
  for STYPE in "${!CONFIGURATION_SENSOR[@]}"; do
    [ $DEBUG -eq 1 ] && >&2 echo sendSensor SensorType "$STYPE" "${CONFIGURATION_SENSOR[$STYPE]}"
     writeUInt8 "$STYPE"
     writeUInt32BE "${CONFIGURATION_SENSOR[$STYPE]}" 
  done

  sendPacket
}

function updateCustomized {
  local needUpdate
  local key_value
  local value
  local key
  local n

  newPacketBody $CMD_read_path
  sendPacket

  newPacketBody $CMD_read_customized # read previous configuration
  sendPacket

  #format enabled=1,port=8000,server=test.no
  IFS=","
  read -r -a OPTION_CUSTOMIZED <<< "$1"
  #readarray -d ',' -t OPTION_CUSTOMIZED < <(echo -n "$1") # <<< HERE string appends 0x0a -> using process substitution

  [ $DEBUG -eq 1 ] && echo >&2 "${FUNCNAME[0]} OPTION_CUSTOMIZED" "${OPTION_CUSTOMIZED[@]}" "${#OPTION_CUSTOMIZED[@]}"

  for n in "${!OPTION_CUSTOMIZED[@]}"; do

    [ $DEBUG -eq 1 ] && echo >&2 "${FUNCNAME[0]} OPTION_CUSTOMIZED LOOP " "${OPTION_CUSTOMIZED[$n]} n=$n"

    IFS='='
    read -r -a key_value <<< "${OPTION_CUSTOMIZED[$n]}"
    #readarray -d '=' -t key_value < <(echo -n "${OPTION_CUSTOMIZED[$n]}")

    key=${key_value[0]}
    value=${key_value[1]}

    [ $DEBUG -eq 1 ] && echo >&2 "${FUNCNAME[0]} KEY $key len ${#key} VALUE $value len ${#value}"

    case "$key" in

    id)
      if [ "${CONFIGURATION[$CONF_customized_id]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_id from "${CONFIGURATION[$CONF_customized_id]} to $value"
        CONFIGURATION[$CONF_customized_id]=$value
        needUpdate=1
      fi
      ;;
    password)
      if [ "${CONFIGURATION[$CONF_customized_password]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_password from "${CONFIGURATION[$CONF_customized_password]} to $value"
        CONFIGURATION[$CONF_customized_password]=$value
        needUpdate=1
      fi
      ;;

    server)
      if [ "${CONFIGURATION[$CONF_customized_server]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_server from "${CONFIGURATION[$CONF_customized_server]} to $value"
        CONFIGURATION[$CONF_customized_server]=$value
        needUpdate=1
      fi
      ;;

    port)

      if [ "${CONFIGURATION[$CONF_customized_port]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_type from "${CONFIGURATION[$CONF_customized_port]} to $value"
        CONFIGURATION[$CONF_customized_port]=$value
        needUpdate=1
      fi
      ;;

    type)
      if [ "${CONFIGURATION[$CONF_customized_type]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_type from "${CONFIGURATION[$CONF_customized_type]} to $value"
        CONFIGURATION[$CONF_customized_type]=$value
        needUpdate=1
      fi
      ;;

    enabled)
      if [ "${CONFIGURATION[$CONF_customized_enabled]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_enabled from "${CONFIGURATION[$CONF_customized_enabled]} to $value"
        CONFIGURATION[$CONF_customized_enabled]=$value
        needUpdate=1
      fi
      ;;

    interval)
      if [ "${CONFIGURATION[$CONF_customized_interval]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_interval from "${CONFIGURATION[$CONF_customized_interval]} to $value"
        CONFIGURATION[$CONF_customized_interval]=$value
        needUpdate=1
      fi
      ;;
    wunderground_path)
      if [ "${CONFIGURATION[$CONF_customized_wunderground_path]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_wunderground_path from "${CONFIGURATION[$CONF_customized_wunderground_path]} to $value"
        CONFIGURATION[$CONF_customized_wunderground_path]=$value
        needUpdate=1
      fi
      ;;
    ecowitt_path)
      if [ "${CONFIGURATION[$CONF_customized_ecowitt_path]}" != "$value" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Update customized_ecowitt_path from "${CONFIGURATION[$CONF_customized_ecowitt_path]} to $value"
        CONFIGURATION[$CONF_customized_ecowitt_path]=$value
        needUpdate=1
      fi
      ;;

    *)
      echo updateCustomized: unknown key "$key" value: "$value"
      ;;
    esac

  done

  #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash
  if [ $needUpdate -eq 1 ]; then
    newCustomizedPacket
    sendPacket

    newPathPacket
    sendPacket

    printCustomized

  else
    echo >&2 Warning: no update needed for customized "$1"
  fi

}

function convertScale10ToFloat {
  local int
  local frac

  if [ "$1" -lt  10 ]; then
    #printf -v VALUE_SCALE10_FLOAT "%s" "0.$1" 2>/dev/null ||
     VALUE_SCALE10_FLOAT="0.$1"
  else
    int=$(($1 / 10))
    frac=$(($1 - int * 10))
    #printf -v VALUE_SCALE10_FLOAT "%u.%u" $int $frac 2>/dev/null ||
     VALUE_SCALE10_FLOAT="$int.$frac" 
  fi
}

function initConfigDir {

  DIR=$HOME'/.config/gw'
  [ -n "$EXTERNAL_STORAGE" ] && DIR=$EXTERNAL_STORAGE # testing in Android 11 adb shell
  [ $DEBUG -eq 1 ] && echo >&2 Configuration directory "$DIR"
  [ ! -d "$DIR" ] && mkdir -v "$DIR" 1>&2

  FILENAME_tx=$DIR'/txpacket'
  FILENAME_rx=$DIR'/rxpacket'
  FILENAME_discovery=$DIR'/rxsocat'
  FILENAME_discovery_sorted=$DIR/'rxsocat_sorted'
  FILENAME_udp_server="$FILENAME_discovery"_UDP_"$PORT_udp_discovery_server"
  FILENAME_udp_client="$FILENAME_discovery"_UDP_"$PORT_udp_discovery_client"
  FILENAME_nc_hex=$DIR/'nc_hex.txt'
  FILENAME_livedata_description=$DIR/'livedata-description.txt'
  FILENAME_od_hex=$DIR/'od-hex.txt'

}

function initLivedataFieldDescriptionRenaming
{
  if [ ! -s "$FILENAME_livedata_description" ]; then
     >&2 echo Warning File is empty or does not exists "$FILENAME_livedata_description" - using default names for livedata fields
     return 1
  fi

  #mapping from livedata field in decimal to names
  #26=bedroom,  #27=livingroom
  
  IFS='='
  while read -r LDFTYPE LDNAME; do
    if [ -z "$LDFTYPE" ] || expr "$LDFTYPE" : "#" >/dev/null; then #skip comments
      continue;
    fi
     LIVEDATA_FIELDRENAME[$LDFTYPE]=$LDNAME
     [ $DEBUG -eq 1 ] && >&2 echo Livedata field type to name "$LDFTYPE=$LDNAME"
  done < "$FILENAME_livedata_description"

}


function showRainInfoMessage {
  which notify-send >/dev/null && notify-send -t 3000 -i dialog-warning "gw script" "$1" &
  #https://www.shell-tips.com/linux/how-to-format-date-and-time-in-linux-macos-and-bash/
  echo -e "$(date)" "$1" # may add bell \a
  if [ -n "$2" ]; then
    which espeak >/dev/null && espeak -p10 "$2" &
  fi
}

function runRainNotification { 
  # $1 - number of seconds between each rain probe
  # $2 - show start/stop messages only (1 on, 0 off)
  local rr
  local rd
  local rainInterval # raining continously for "$1" seconds
  local rainDuration # minutes raining
  local simulation
  local showStartStopEventOnly
  local rainTimeout
  rainTimeout=$1
  showStartStopEventOnly=$2

  simulation=0 # 1 = on for testing
  [ $DEBUG -eq 1 ] && >&2 echo Rain simulation $simulation
  [ "$simulation" -eq 1 ] && {
    rainTimeout=5
    showStartStopEventOnly=1
    CONFIGURATION[$CONF_rainrate]=0
    CONFIGURATION[$CONF_raindaily]=10
  } # { list ; } run in current shell

  [ $DEBUG -eq 1 ] && echo >&2 "Rain event interval $rainTimeout s. Show start/stop events only $showStartStopEventOnly"

  rainInterval=0
  while true; do
    [ "$simulation" -eq 0 ] && sendPacket $CMD_read_raindata >/dev/null
    [ "$simulation" -eq 1 ] && { CONFIGURATION[$CONF_rainrate]=$(("${CONFIGURATION[$CONF_rainrate]}" + 10 ))
    [ ${CONFIGURATION[$CONF_rainrate]} -eq 50 ] && CONFIGURATION[CONF_rainrate]=0; }
    convertScale10ToFloat "${CONFIGURATION[$CONF_rainrate]}"
    rr=$VALUE_SCALE10_FLOAT
    convertScale10ToFloat "${CONFIGURATION[$CONF_raindaily]}"
    rd=$VALUE_SCALE10_FLOAT
    if [ "${CONFIGURATION[$CONF_rainrate]}" -ne 0 ]; then
      rainInterval=$((rainInterval+1))
      if [ "$rainInterval" -eq 1 ]; then
        showRainInfoMessage "☂ Raining $rr mm/h.Today $rd mm" "Its raining! $rr millimeter per hour. Today $rd millimeter"
      else
        if [ "$showStartStopEventOnly" != "1" ]; then
          showRainInfoMessage "☂ Raining $rr mm/h. Today $rd mm"
        fi
      fi
    fi
    if [ "$rainInterval" -gt 0 ] && [ "${CONFIGURATION[$CONF_rainrate]}" -eq 0 ]; then
      rainDuration=$((rainInterval * rainTimeout / 60)) # integer only in bash
      showRainInfoMessage "Raining stopped! Today $rd mm. Rained for $rainDuration minutes." "Raining stopped! Today $rd millimeter. It rained for $rainDuration minutes."
      rainInterval=0
    fi
    sleep "$rainTimeout"
  done
}

function updateSensorId
#$1 - STYPE sensor type
#$2 - SID sensor id
{
 [[ DEBUG -eq 1 ]] &&  >&2 echo "Setting sensor type $1 to $2"
                                                          
  CONFIGURATION_SENSOR[$1]=$(( 0x$2 ))
  CONFIGURATION_SENSOR_UPDATE+=( "$1" )
}

function writeSensorId
{
  local type
  #debug : WSVIEW sensor overview is updated periodically to reflect current state

  if [ ${#CONFIGURATION_SENSOR_UPDATE[@]} -gt 0 ]; then

        newPacketBody $CMD_write_sensor_id

        for type in "${CONFIGURATION_SENSOR_UPDATE[@]}"; do
        
          writeUInt8 "$type"                  # 1 byte packet length? (255-3)/5 bytes pr field = 50 sensor types max
          writeUInt32BE "${CONFIGURATION_SENSOR[$type]}"

          [ $DEBUG -eq 1 ] && >&2 printf "Update sensor type %3d id %8x\n" "$type" "${CONFIGURATION_SENSOR[$type]}"
        done

        sendPacket
  fi

}

function connectGW {
  local lan_mac
  local lan_mac_lc #lowercase
  local ap_mac
  local ap_all_scan
  local ap_scan
  local ap_scan_result
  local connect_result
  local connect_str
  local connect_attempt
  local connect_attempt_MAX
  local connected
  local timeout
  local bssid_pattern

  timeout=5
  connected=1
  connect_attempt=0
  connect_attempt_MAX=15

  #useful for debugging: sudo nmcli device monitor and  sudo iw event -r

  if ! which nmcli >/dev/null; then
    return "$ERROR_NO_NMCLI"
  fi

  sudo nmcli radio wifi on
  echo >&2 Attempting to reconnect to device, waiting $timeout s for device to bootup after reset
  sleep $timeout # wait for reset/bootup

  # Station mode/LAN: MAC 48:3F:DA:54:14:EC, ssid/version GW1000A-WIFI14EC, AP-mode: MAC 4A:3F:DA:54:14:EC, GW1000-WIFI4EC
  # 48:3F:DA - EspressIf Inc. https://www.wireshark.org/tools/oui-lookup.html
  #  nmcli dev wifi list : 4A:3F:DA:54:14:EC  GW1000-WIFI14EC  Infra  1     54 Mbit/s   77      ▂▄▆_  --
  # observation/seldom : 4A:3F:DA:54:14:EC SSID  ESP_5414EC -> hotsport started before ssid rename in firmware v.1.6.8?
  lan_mac=${CONFIGURATION[$CONF_broadcast_mac]//:/}
  toLowercase "${CONFIGURATION[$CONF_broadcast_mac]}"
  lan_mac_lc=$lowercase
  bssid_pattern=${lan_mac:9}

  while ((connected == 1 && connect_attempt < "$connect_attempt_MAX")); do
    ((connect_attempt++))

    [ $DEBUG -eq 1 ] && echo >&2 Connect attempt "$connect_attempt"
    if [ "$connect_attempt" -eq 1 ]; then
      ap_all_scan=$(sudo nmcli -t -e no -f BSSID,SSID,IN-USE dev wifi list --rescan yes) #use terse mode for fixed format string
    else
      ap_all_scan=$(sudo nmcli -t -e no -f BSSID,SSID,IN-USE dev wifi list --rescan auto)
    fi
    ap_scan=$(grep -F "$bssid_pattern" <<<"$ap_all_scan")
    ap_scan_result=$?

    if [ $ap_scan_result -eq 0 ] && [ -n "$ap_scan" ]; then
      [ $DEBUG -eq 1 ] && echo >&2 AP scan "$ap_scan"
      [[ -n "$BASH_VERSION" ]] && readarray -d':' nmcli_result <<< "$ap_scan"
      [[ -n "$ZSH_VERSION" || -n "$KSH_VERSION" ]] && read -r -A  -d':' nmcli_result <<< "$ap_scan"
      #FIX readarray -d':' nmcli_result < <(echo -n "$ap_scan")
      in_use=${nmcli_result[7]}
      ap_mac=${nmcli_result[0]}${nmcli_result[1]}${nmcli_result[2]}${nmcli_result[3]}${nmcli_result[4]}${nmcli_result[5]}
      ap_mac=${ap_mac:0:-1}

      if [ "$in_use" != "*" ]; then
        [ $DEBUG -eq 1 ] && echo >&2 Connecting to bssid "$ap_mac"
        connect_str=$(sudo nmcli -w 5 dev wifi connect "$ap_mac") #nmcli has a default timeout of 45 seconds, try just waiting 5 s
        connect_result=$?
        echo >&2 "$connect_str"
      fi

      if [ $connect_result -eq 0 ] && [[ $connect_str != Error* ]] || [ "$in_use" == "*" ]; then
        [ $DEBUG -eq 1 ] && arp -n | grep -F "${lan_mac_lc:9}" >&2
        connected=0
        #ip -4 -o address
      fi

    fi

    ((connected == 1)) && sleep 5
  done

  ip address

}

function initSearchPatternForCommand
{
     SPATTERN=$1
     if [ -z "$SPATTERN" ] || [ "$SPATTERN" == "*" ]; then
        SPATTERN='.*' #add default search for any pattern
     fi
     toLowercase "$SPATTERN"
     SPATTERN=$lowercase
}


function argEmptyOrNotOption
{
  [[ -z "$1"  ||  ! "${1:0:1}" = "-" ]]
}

function processCommand {
#$1 - field pattern for livedata/sensor id

  case $COMMAND in

        reset)
          
          sendPacket $CMD_broadcast $FD_UDP >/dev/null
          
          read -r -p "Reset ${CONFIGURATION[$CONF_broadcast_mac]} ${CONFIGURATION[$CONF_broadcast_ssid]} (Y/N)? "
          
          case $REPLY in
          Y)
            sendPacket $CMD_write_reset # 3 blink in red LED
            connectGW                     # assume user wants to reconnect for setting up new WIFI
            ;;
          esac
          
          ;;

        reboot)
          
          sendPacket "$CMD_reboot"
          ;;

        mac)
          
          sendPacket "$CMD_read_mac"
          ;;

        version)
          
          sendPacket $CMD_read_version
          ;;

        system)
          
          if argEmptyOrNotOption "$1"; then 
            sendPacket $CMD_read_system
          else
            if [ $# -lt  4 ]; then
              echo >&2 "Error {sensortype} {timezoneindex} {dst} {autotimezone} must be specified"
            else
              sendSystem "$1" "$2" "$3" "$4"
            fi
          fi
          ;;

        ecowitt)

          if argEmptyOrNotOption "$1"; then
            sendPacket $CMD_read_ecowitt_interval
          else
           sendEcowittInterval "$1"
          fi
          ;;

        wunderground)

            if argEmptyOrNotOption "$1"; then
              sendPacket $CMD_read_wunderground;
            else
              if [ $# -lt 2 ]; then
                 echo >&2 "Error {id} {password} must be specified"
              else
                  sendWeatherservice "$CMD_write_wunderground" "$1" "$2"
              fi
            fi 

          ;;

        wow)
          
          if argEmptyOrNotOption "$1"; then
            sendPacket $CMD_read_wow
          else
            if [ $# -lt 2 ]; then
                 echo >&2 "Error {id} {password} must be specified"
              else
                  sendWeatherservice "$CMD_write_wow" "$1" "$2"
              fi
          fi
          ;;

        weathercloud)

          if argEmptyOrNotOption "$1"; then
            sendPacket $CMD_read_weathercloud
          else
                if [ $# -lt 2 ]; then
                  echo >&2 "Error {id} {key} must be specified"
                else
                    sendWeatherservice "$CMD_write_weathercloud" "$1" "$2"
                fi
          fi
          ;;

        customized)
          
          sendPacket $CMD_read_path
          sendPacket $CMD_read_customized
          ;;

        broadcast)
          sendPacket $CMD_broadcast $FD_UDP
          ;;

        rain)

          if argEmptyOrNotOption "$1"; then
            sendPacket $CMD_read_raindata
          else

            if [ $# -lt 4 ]; then # validate rain input
              echo >&2 "Error: {rainday} {week} {month} {year} parameters not specified"
            else
               sendRaindata "$1" "$2" "$3" "$4"
            fi
          
          fi
            
          ;;

        livedata)
          
          initSearchPatternForCommand "$1"
          sendPacket $CMD_livedata
                ;;

        sensor_id)
          
          initSearchPatternForCommand "$1"
          sendPacket $CMD_read_sensor_id
          ;;

        sensor_id_new) # for new SENSOR_TYPE types
        
        if expr "$1" : "-"; then # probably new option - or --
          initSearchPatternForCommand
        else
          initSearchPatternForCommand "$1"
        fi
        
          sendPacket $CMD_read_sensor_id_new
          ;;

        *)
          
          echo >&2 Error Unkown command "$COMMAND"
          return 1
          ;;
  esac

  return 0
}

function isNumber
{
#https://www.grymoire.com/Unix/Bourne.html#uh-84
  local number
  number=$(expr "$1" : "\([0-9]*\)") # number is extracted when using parentheses
  if [ "$number" != "$1" ]; then
    return 1  
  else
    return 0 
  fi
}

function getConfigurationIndexFromName
{
  typeset -i i

  i=0
  while [ $i -lt ${#CONFIGURATION_NAME[@]} ]; do
    if [ -n "${CONFIGURATION_NAME[$i]}" ] && [ "${CONFIGURATION_NAME[$i]}" = "$1" ]; then
       CONFIGURATION_INDEX=$i
           echo i $i name ${CONFIGURATION_NAME[$i]} 

       break;
    fi
   i=$((i + 1))
  done
}

function local
#just ignore local for ksh
{
  :
}

#read -r -u 0 -t 0 STDIN

#if [ -n "$STDIN" ]; then
#  echo STDIN "$STDIN"
   :
  #maybe parse packet if gw used as filter echo hex dump | gw

#fi

initConfigDir
initLivedataFieldDescriptionRenaming

#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
unset POSITIONAL

while [ $# -gt 0 ]; do
  key="$1"

  case $key in

  -b | --backup)
    sendPacket $CMD_read_mac >/dev/null
    sendPacket $CMD_read_version >/dev/null
    sendPacket $CMD_broadcast >/dev/null
    sendPacket $CMD_read_ecowitt_interval >/dev/null
    sendPacket $CMD_read_wunderground >/dev/null
    sendPacket $CMD_read_wow >/dev/null
    sendPacket $CMD_read_weathercloud >/dev/null
    sendPacket $CMD_read_customized >/dev/null
    sendPacket $CMD_read_path >/dev/null
    sendPacket $CMD_read_raindata >/dev/null
    sendPacket $CMD_read_sensor_id_new 
    #>/dev/null
    # some data probably saved to device EEPROM
    # TODO? calibration data?
    if [ -n "$2" ]; then #save to file
      printConfiguration >"$2"
      shift 2
    else
      printConfiguration #or just stdout
      shift 1
    fi
    ;;
  
  -c | --command)
    toLowercase "$2"
    COMMAND=$lowercase
    shift 2 # remove -c {commmand}
    
    if processCommand "$@"; then # $3 pass field pattern to livedata/sensor_id_new

     for param in "$@"; do #remove param which is not an option 
       if [ "${param:0:1}" != "-" ]; then
         (( DEBUG)) && >&2 echo Shift param "$@" "$param"
         shift
        else
          break
       fi

     done
 #     echo AFTER "$@"
        #if [[ ($COMMAND == "livedata" || $COMMAND == "sensor_id_new"  || $COMMAND == "sensor_id" ) && -n "$3" && ! "$3" =~ ^"-" ]]; then # ^"-" don't shift 3 for following new options
        #    shift 3
        #  else
        #    shift 2
        #fi
    #else
    #  shift 1
    fi

    unset COMMAND
    ;;

  -d | --debug)
    DEBUG=1
    DEBUG_OPTIONS_socat='-d -d -x'
    DEBUG_OPTIONS_nc="-v"
    shift
    ;;

  -f | --firmware)
    HTTP_UA_NAME="gw script BASH ${BASH_VERSION} $(uname -srv)"
    HTTP_FIRMWARE="http://download.ecowitt.net/down/filewave?v=FirwaveReadme.txt"
    [ $DEBUG -eq 1 ] && printf >&2 "%s\n%s" "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
    curl --silent --show-error --user-agent "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
    shift 2
    ;;

  -h | --host)
    HOST_PREV=$HOST
    HOST="$2" # this arg must come first to open socketsopen file descriptors to UDP/TCP port on HOST

    #if ! connect "$2"; then
    #  echo >&2 "$HOST" "Error Failed to connect host $2, exiting"
    #  disconnect
    #  exit $ERROR_CONNECTION
    #fi
    CONFIGURATION[$CONF_host]=$HOST

    #sendPacket "$CMD_read_mac" >/dev/null
    sendPacket "$CMD_read_version" >/dev/null

    sendPacket "$CMD_read_system" >/dev/null 2>/dev/null # find sensor type WH65/WH24 - &> redirect stderr+stdout - read_system not available on EasyWeather
    
    if [ "${CONFIGURATION[$CONF_system_sensor_type]}" -eq "$SYSTEM_SENSOR_TYPE_WH24" ]; then
      SENSOR_TYPE[WH24_type]="WH24:Outdoor Weather Sensor:16.0:"
    fi

    >&2  printf "%s %s\n\n" "${CONFIGURATION[$CONF_version]}" "${CONFIGURATION[$CONF_system_utc_state]}" 

    shift 2
    ;;
 
  -l | --listen)
    echo >&2 Listening for http request on port "$2"
    eval 'mapfile HTTP_REQUEST < <(nc -l "$2")'
    n=0
    while [ "$n" -lt  ${#HTTP_REQUEST[@]} ]; do
      echo "${HTTP_REQUEST[$n]}"
      n=$(( n + 1))
    done
    shift 2
    ;;
    # Wunderground
    #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
    #Accept: */*
    #Host: 192.168.3.174
    #Connection: Close

    # Ecowitt
    #POST /ecowitt HTTP/1.1
    #HOST: 192.168.3.174
    #Connection: Close
    #Content-Type: application/x-www-form-urlencoded
    #Content-Length:591
    #
    #PASSKEY=976D09F15C41FD8DC6E9A9E8C4F39707&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro
    #
    #A = 868 Mhz GW1000A, B= , C= 433
  -r | --restore)

    unset CONFIGURATION
    unset CONFIGURATION_SENSOR
    typeset -a CONFIGURATION
    typeset -a CONFIGURATION_SENSOR

    if [ -s "$2" ]; then 
      IFS=' '
      while read -r K V REST; do
        unset CONFIGURATION_INDEX
        STYPE=$(expr "$K" : "$CONFIGURATION_SENSORFIELD\([0-9]*\)" ) # extracts number part from sensortype_{number}
        if [ -n "$STYPE" ]; then
          CONFIGURATION_SENSOR[$STYPE]=$V 
        else
           getConfigurationIndexFromName "$K"
           if [ -n "$CONFIGURATION_INDEX" ]; then 
             CONFIGURATION["$CONFIGURATION_INDEX"]="$V"
           fi
        fi
      
      done < "$2"
      
      printConfiguration

      sendEcowittInterval "${CONFIGURATION[$CONF_ecowitt_interval]}"
      sendWeatherservice "$CMD_write_wunderground" "${CONFIGURATION[$CONF_wunderground_id]}" "${CONFIGURATION[$CONF_wunderground_password]}"
      sendWeatherservice "$CMD_write_wow"          "${CONFIGURATION[$CONF_wow_id]}"          "${CONFIGURATION[$CONF_wow_password]}"
      sendWeatherservice "$CMD_write_weathercloud" "${CONFIGURATION[$CONF_weathercloud_id]}" "${CONFIGURATION[$CONF_weathercloud_password]}"
      sendCustomized
      sendRaindata "${CONFIGURATION[$CONF_raindaily]}" "${CONFIGURATION[$CONF_rainweek]}" "${CONFIGURATION[$CONF_rainmonth]}" "${CONFIGURATION[$CONF_rainyear]}"
      sendSensor
    else
      >&2 echo Error File "$2 does not exists or is not empty";
    fi

    shift 2

    ;;

  -m | --sensor)

    if [[ -n "$2" && ${2:0:1} != '-' ]]; then 

          case $2 in
           
            *=*) # parameter contains =

                      unset CONFIGURATION_SENSOR_UPDATE #array -> contains sensortype to update

                      sendPacket "$CMD_read_sensor_id_new" >/dev/null
                    
                        # $2 -  {sensortype}=search|disable|hexid,{st1-stn}=search|disable|hexid,...
                        IFS=","
                        if [[ -n $BASH_VERSION ]]; then
                          arrayOption='-a'
                        elif [[ -n $KSH_VERSION || -n $ZSH_VERSION ]]; then
                          arrayOption='-A'
                        else
                          arrayOption='-A'
                        fi

                        read -r $arrayOption SENSOR_MANAGEMENT  <<< "$2" 

                        s_disable="disable"
                        s_search="search"
                        n=0

                        while [ "$n" -lt ${#SENSOR_MANAGEMENT[@]} ];  do

                                IFS='='
                                read -r STYPE SID <<< "${SENSOR_MANAGEMENT[$n]}" # {st1-stn}=search|disable|hexid (for example 1-10=search)
                                
                                IFS='-'
                                read -r STYPE_MIN STYPE_MAX <<< "$STYPE" 
                                
                                #https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash/806923
                                ! isNumber  "$STYPE_MIN"  && >&2 echo "$STYPE_MIN is not a sensor type/number"  && continue;
                                [ -n "$STYPE_MAX" ] && ! isNumber "$STYPE_MAX" && >&2 echo "$STYPE_MAX is not a sensor type/number"  && continue;
                                
                                [ -z "$STYPE_MAX" ] && STYPE_MAX=$STYPE_MIN

                                 [[ $DEBUG -eq  1 ]] &&  >&2 echo Parsing expression $n "${SENSOR_MANAGEMENT[$n]}" STYPE "$STYPE" SID "$SID"

                                toLowercase "$SID"
                                SID=$lowercase
                                s_search=${s_search:0:${#SID}}
                                [[ ${#SID} -gt 1 ]] && s_disable=${s_disable:0:${#SID}} # shrink search pattern for case pattern matching, but not single d hex

                                case $SID in
                                
                                    "$s_search")
                                              
                                                        r=$STYPE_MIN
                                                        while [ "$r" -le "$STYPE_MAX" ]; do 
                                                          #    for (( r=STYPE_MIN; r<= STYPE_MAX; r++ )); do 
                                                                  updateSensorId "$r" "$SENSOR_SEARCH_STRING"
                                                                  r=$(( r + 1))
                                                        done
                                                      ;;

                                  "$s_disable")
                                                        r=$STYPE_MIN
                                                        while [ "$r" -le "$STYPE_MAX" ]; do 
                                                            #   for (( r=STYPE_MIN; r<= STYPE_MAX; r++ )); do 
                                                                      updateSensorId "$r" "$SENSOR_DISABLE_STRING"
                                                                      r=$(( r + 1 ))
                                                        done
                                                        set +x
                                                      ;;
                                  
                                            *)
                                                  r=$STYPE_MIN
                                                  if [[ $r -eq $STYPE_MAX ]]; then 
                                                        if [[ -n $BASH_VERSION || -n $ZSH_VERSION ]]; then 
                                                                  #extended regular expression ^ -start of line $-end of line - {1,8} iterator/quantifier
                                                            eval 'if [[ $SID =~ ^[a-fA-F0-9]{1,8}$ ]]; then 
                                                                            updateSensorId "$r" "$SID" 
                                                                  else
                                                                          >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                                  fi'
                                                            #use eval to avoid syntax error in mirbsd korn shell/android
                                                        elif [[ $KSH_VERSION == Version* ]]; then
                                                           eval 'if [[ $SID == {1,8}([a-fA-F0-9]) ]]; then
                                                                            updateSensorId "$r" "$SID" 
                                                                  else
                                                                          >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                                 fi'
                                                          #http://www.mirbsd.org/htman/i386/man1/mksh.htm
                                                        elif [[ $KSH_VERSION == *MIRBSD* ]]; then #android shell
                                                            eval 'if [[ $SID == +([a-f]|[A-F]|[0-9]) && ${#SID} -le 8 ]]; then 
                                                                            updateSensorId "$r" "$SID" 
                                                                  else
                                                                     >&2 echo "Error unknown or invalid sensor id $SID, use disable/search/hexid"
                                                                  fi'
                                                        elif echo "$SID" | grep -E -q "^[a-fA-F0-9]{1,8}$"; then  
                                                                   updateSensorId "$r" "$SID"
                                                        else
                                                            echo >&2 "Error shell not supported, cannot set $r to $SID"
                                                        fi
                                                         r=$(( r + 1 ))
                                                  else
                                                     echo >&2 "Error: Cannot set type $STYPE_MIN-$STYPE_MAX to same id $SID"
                                                  fi
                      
                                                  ;;
                                esac
                          
                                n=$(( n + 1 ))
                          
                          done

                          writeSensorId

                        shift 2
                          ;;

             *) # assume its a search pattern if it does not contain =

                        initSearchPatternForCommand "$2"
                        sendPacket "$CMD_read_sensor_id_new"
                        shift 2
                        ;;

          esac
         
     else
         initSearchPatternForCommand
         sendPacket $CMD_read_sensor_id_new
         shift
     fi

     ;;

  -n | --notifyrain)
    runRainNotification "$2" "$3" #tested on GNOME
    shift 3
    ;;

  -s | --scan)
    if which socat >/dev/null; then
      discovery
    else
      Echo >&2 Error socat not found, cannot scan for devices
      return "$ERROR_NO_SOCAT"
    fi
    shift
    ;;

  -t | --timezones)
      printTimezones
      ;;

  -z | --customized)

    updateCustomized "$2"
    shift 2
    ;;

  -w | --wifi)
    
    newPacketBody $CMD_write_ssid
    #ssid packet has two byte length
    # TEST wsview android app, wireshark: ffff | 11 |001b| 08536b6f676c756e640d6c756775626572313934322d2e | a9
    #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/ConfigrouterFragment.java - SaveData
    writeString "$2" # ssid
    writeString "$3" # password
    sendPacket

    shift 3
    ;;

  *)                   # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift              # past argument
    ;;
  esac

done

[ ${#POSITIONAL[@]} -ge 1 ] && echo >&2 Failed to recognize options "${POSITIONAL[@]}"

set -- "${POSITIONAL[@]}" # restore positional parameters

#disconnect

##echo CMD_BROADCAST
#command '\x12\x00\x04\x15' $FD_UDP
#https://unix.stackexchange.com/questions/612193/socat-send-a-udp-broadcast-from-stdin-but-handling-responses-with-system
#printf "\xff\xff\x12\x00\x04\x16" | socat -d -d -x -t 1 - udp-datagram:255.255.255.255:46000,broadcast
