#!/bin/bash
# example /gw -h 10.42.0.180  -s 3
# scan for 3 seconds
# example ./gw -h 10.42.0.180 -c mac
# read mac
# Info  from https://www.xmodulo.com/tcp-udp-socket-bash-shell.html
# Writing CMD_BROADCAST 0x12 to HOST port 46000
# https://brendanzagaeski.appspot.com/0006.html - hexdump examples
#Protocol documentation : https://osswww.ecowitt.net/uploads/20210716/WN1900%20GW1000,1100%20WH2680,2650%20telenet%20v1.6.0%20.pdf (https://www.ecowitt.com/shop/forum/forumDetails/255)

#for debugging
#echo PID "$$"
#read -p "PAUSING"

HTTP_UA_NAME="gw ShellScript"
HTTP_FIRMWARE="http://download.ecowitt.net/down/filewave?v=FirwaveReadme.txt"

DEBUG=0

PORT_TCP_COMMAND_SERVER=45000
PORT_UDP_DISCOVERY_SERVER=59387
PORT_UDP_DISCOVERY_CLIENT=46000

#COMMANDS AT BYTE 2 ff ff |COMMAND| ...

CMD_READ_PATH=0x51
CMD_WRITE_PATH=0x52

CMD_READ_VERSION=0x50
CMD_REBOOT=0x40
CMD_READ_MAC=0x26
CMD_READ_WUNDERGROUND=0x20
CMD_READ_ECOWITT=0x1e

CMD_READ_CUSTOMIZED=0x2a
CMD_WRITE_CUSTOMIZED=0x2b

CMD_WRITE_SSID=0x11
CMD_BROADCAST=0x12

CMD_WRITE_RESET=0x41

# PACKET BODY STARTING AT BYTE 2
PACKET_BODY=()

#CONNECT ERRORS
ERROR_CONNECTION=1
#ERROR_READ_RESPONSE=3

FILENAME_RXSOCAT_SORTED='rxsocat_sorted'
FILENAME_COMMAND='txpacket'
FILENAME_RESPONSE='rxpacket'
FILENAME_RXSOCAT='rxsocat'

declare -A CONFIGURATION

function connect {

  #https://www.gnu.org/software/bash/manual/bash.html - 3.6 Redirections
   if exec {FD_UDP}<>/dev/udp/"$1"/"$PORT_UDP_DISCOVERY_CLIENT"; then
     [ "$DEBUG" -eq 1 ] && echo  >&2 "$1:$PORT_UDP_DISCOVERY_CLIENT Connected (UDP FD $FD_UDP)"
   else
     return $ERROR_CONNECTION
   fi

  if [ -v FD_TCP ]; then
    [ "$DEBUG" -eq 1 ] && >&2 echo "$HOST_PREV closing connection"
    disconnect
  fi

  if exec {FD_TCP}<>/dev/tcp/"$1"/"$PORT_TCP_COMMAND_SERVER"; then
    [ "$DEBUG" -eq 1 ] && >&2 echo "$1:$PORT_TCP_COMMAND_SERVER Connected (TCP FD $FD_TCP)"
  else
    return $ERROR_CONNECTION
  fi

  #echo Current shell PID $$

  if [ "$DEBUG" -eq 1 ]; then netstat -tunp | grep "$$"; fi

}

function disconnect {
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
  #close sockets
   if [ -n "${FD_UDP+x}" ]; then

     if ! exec {FD_UDP}>&-; then >&2 echo Failed to close $FD_UDP; fi
   fi

  if [ -n "${FD_TCP+x}" ]; then

    if ! exec {FD_TCP}>&-; then >&2 echo Failed to close $FD_TCP; fi
  fi
}

function parseResult {
  local cmd="0x${PACKET_RX[2]}"
  declare -A cmd_name # -A associative array
  cmd_name[$CMD_REBOOT]="reboot"
  cmd_name[$CMD_WRITE_PATH]="write path"
  cmd_name[$CMD_WRITE_SSID]="write SSID"
  cmd_name[$CMD_WRITE_CUSTOMIZED]="write customized"
  cmd_name[$CMD_WRITE_RESET]="write reset"

  STATUS=0x${PACKET_RX[4]}
  echo -n "$HOST" "${cmd_name[$cmd]}" "$STATUS"
  if ((STATUS == 0)); then
    echo " OK"
  elif ((STATUS == 1)); then
    echo " FAIL"
  else
    echo -e '\n'
  fi
}

function hexToString {
  local n
  HEXTOSTRING=""
  NEXT_LENGTH=$(($1 + 1 + 0x${PACKET_RX[$1]}))
  #HEXTOSTRING=""
  HEXTOSTRING="HEXTOSTRING=$'"
  for ((n = $(($1 + 1)); n < NEXT_LENGTH; n++)); do
  #https://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/escapingsection.html
  #https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
  #https://unix.stackexchange.com/questions/48106/what-does-it-mean-to-have-a-dollarsign-prefixed-string-in-a-script
    HEXTOSTRING+="\x${PACKET_RX[$n]}"
  # HEXTOSTRING+=$(echo -ne "\x${PACKET_RX[$n]}")
  done
  HEXTOSTRING+="'"
  eval $HEXTOSTRING
}

function printCustomized {
  echo "$HOST" id "${CONFIGURATION[customized_id]}"
  echo "$HOST" password "${CONFIGURATION[customized_password]}"
  echo "$HOST" server "${CONFIGURATION[customized_server]}"
  echo "$HOST" port "${CONFIGURATION[customized_port]}"
  echo "$HOST" interval "${CONFIGURATION[customized_interval]}"

  if ((CONFIGURATION[customized_type] == 1)); then
    echo "$HOST" "type 1 Wunderground "
  elif ((CONFIGURATION[customized_type] == 0)); then
    echo "$HOST" "type 0 Ecowitt "
  else
    echo "$HOST" "type ${CONFIGURATION[customized_type]}" "UNKNOWN"
  fi

  if ((CONFIGURATION[customized_enabled] == 1)); then
    echo "$HOST" enabled '1 ON'
  elif ((CONFIGURATION[customized_enabled] == 0)); then
    echo "$HOST" enabled '0 OFF'
  else
    echo "$HOST" enabled "${CONFIGURATION[customized_enabled]}" "UNKNOWN"
  fi
}

function dumpConfiguration
{
  #echo "${!CONFIGURATION[@]}"
  for K in "${!CONFIGURATION[@]}"; do printf "%-30s %s\n" "$K" "${CONFIGURATION[$K]}"; done
}

function echoBroadcastConfiguration
{
    echo "$HOST ${CONFIGURATION[broadcast_mac]} ${CONFIGURATION[broadcast_ip]}:${CONFIGURATION[broadcast_port]} ${CONFIGURATION[broadcast_ssid]} ${CONFIGURATION[broadcast_version]}"
}


function parsePacket {
  local cmd
  local pos=4

  cmd=0x${PACKET_RX[2]}

  #Packet length
  case $cmd in
  "$CMD_BROADCAST")
    lsb=${PACKET_RX[4]}
    msb=${PACKET_RX[3]}
    PACKET_LENGTH=$(((0x$msb << 8) | 0x$lsb))
    ;;
  *)
    PACKET_LENGTH=${PACKET_RX[3]}
    ;;
  esac

  [ "$DEBUG" -eq 1 ] && echo "Parse packet ${PACKET_RX[*]} length $PACKET_LENGTH"

  case $cmd in
  "$CMD_WRITE_RESET")
    parseResult
    ;;
  "$CMD_WRITE_CUSTOMIZED")
    parseResult
    ;;
  "$CMD_REBOOT")
    parseResult
    ;;
  "$CMD_READ_MAC")
    CONFIGURATION[mac]=$(printf "%02X:%02X:%02X:%02X:%02X:%02X"  0x"${PACKET_RX[4]}" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}")
    echo "$HOST ${CONFIGURATION[mac]}"
    ;;
  "$CMD_READ_VERSION")
    hexToString $pos
    CONFIGURATION[version]=$HEXTOSTRING
    echo "$HOST" Version "${CONFIGURATION[version]}"
    ;;
  "$CMD_READ_ECOWITT")
    CONFIGURATION[ecowitt_interval]=$(( "${PACKET_RX[$pos]}" ))
    echo "$HOST ecowitt interval ${CONFIGURATION[ecowitt_interval]} minutes"
    ;;
  "$CMD_READ_WUNDERGROUND")
    hexToString $pos
    CONFIGURATION[wunderground_id]=$HEXTOSTRING
    echo "$HOST id wunderground ${CONFIGURATION[wunderground_id]}"

    (( pos=pos+${#HEXTOSTRING}+1 ))
    hexToString "$pos"
    CONFIGURATION[wunderground_password]=$HEXTOSTRING
    echo "$HOST password wunderground ${CONFIGURATION[wunderground_password]}"
    ;;
  "$CMD_READ_CUSTOMIZED")
    hexToString "$pos"
    CONFIGURATION[customized_id]=$HEXTOSTRING
  
    (( pos=pos+${#HEXTOSTRING}+1 ))
    hexToString  "$pos"
    CONFIGURATION[customized_password]=$HEXTOSTRING

    (( pos=pos+${#HEXTOSTRING}+1 ))
    hexToString "$pos"
    CONFIGURATION[customized_server]=$HEXTOSTRING
    #http://mywiki.wooledge.org/ArithmeticExpression

    CONFIGURATION[customized_port]=$((     ( 0x${PACKET_RX[-7]} << 8) | 0x${PACKET_RX[-6]} ))
    CONFIGURATION[customized_interval]=$(( ( 0x${PACKET_RX[-5]} << 8) | 0x${PACKET_RX[-4]} ))
    CONFIGURATION[customized_type]=$((       0x${PACKET_RX[-3]} ))
    CONFIGURATION[customized_enabled]=$((    0x${PACKET_RX[-2]} ))

    printCustomized
    ;;
  "$CMD_READ_PATH")
    hexToString "$pos"
    CONFIGURATION[ecowitt_path]=$HEXTOSTRING
    echo "$HOST" path "${CONFIGURATION[ecowitt_path]}" Ecowitt

    (( pos=pos+${#HEXTOSTRING}+1 ))
    hexToString "$pos"
    CONFIGURATION[wunderground_path]=$HEXTOSTRING
    
    echo "$HOST" path "${CONFIGURATION[wunderground_path]}" Wunderground
    ;;
  "$CMD_WRITE_PATH")
    parseResult
    ;;
  "$CMD_WRITE_SSID")
    parseResult
    ;;
  "$CMD_BROADCAST")



    if ((PACKET_LENGTH > 4)); then
      {

        CONFIGURATION[broadcast_mac]=$(printf "%02X:%02X:%02X:%02X:%02X:%02X\n" 0x"${PACKET_RX[5]}" 0x"${PACKET_RX[6]}" 0x"${PACKET_RX[7]}" 0x"${PACKET_RX[8]}" 0x"${PACKET_RX[9]}" 0x"${PACKET_RX[10]}")
        CONFIGURATION[broadcast_ip]=$(printf "%d.%d.%d.%d" 0x"${PACKET_RX[11]}" 0x"${PACKET_RX[12]}" 0x"${PACKET_RX[13]}" 0x"${PACKET_RX[14]}")
        hexToString 17
        local ssid
        local version
        read -r ssid version <<< "$HEXTOSTRING" # ssid appends space+version
        CONFIGURATION[broadcast_ssid]=$ssid
        CONFIGURATION[broadcast_version]=$version
        CONFIGURATION[broadcast_port]=$(printf "%d" 0x"${PACKET_RX[15]}""${PACKET_RX[16]}")
        echoBroadcastConfiguration
      }
    else
      {
        [ "$DEBUG" -eq 1 ] && echo "Failed: unable to parse broadcast, too small length $PACKET_LENGTH"
      }
    fi

    ;;
  *)
    >&2 echo "$HOST" Warning unable to parse command "$cmd"
    ;;

  esac
}

function newPacketBody {
  PACKET_BODY=()
  PACKET_BODY+=("$1" "0x00")
  case "$1" in
  "$CMD_BROADCAST") # WSVIEW sends 2 byte field for size
    PACKET_BODY+=("0x00")
    ;;
  esac

  # [ -n "$1" ] &&  PACKET_BODY+=("0x00")  # Append for two byte packet length
}
function createPacketTX {
  local packetLengthLSB
  local packetLengthMSB
  local n

  case ${PACKET_BODY[0]} in # Take care of 2 or 1 byte packet length
  "$CMD_WRITE_SSID" | "$CMD_BROADCAST")
    packetLengthLSB=$(((${#PACKET_BODY[@]} + 1) & 0xff))
    packetLengthMSB=$((((${#PACKET_BODY[@]} + 1) & 0xff00) >> 8))
    PACKET_BODY[1]=$(decToHex $packetLengthMSB)
    PACKET_BODY[2]=$(decToHex $packetLengthLSB)
    ;;
  *)
    PACKET_BODY[1]=$(decToHex $((${#PACKET_BODY[@]} + 1))) # set packet length including checksum byte
    ;;
  esac

  checksum

  PACKET_TX=(0xff 0xff "${PACKET_BODY[@]}" "$CHECKSUM")

  [ "$DEBUG" -eq 1 ] && echo PACKET_TX "${PACKET_TX[@]//0x/''}"

  PACKET_TX_ECHO=''
  for ((n = 0; n < ${#PACKET_TX[@]}; n++)); do
    PACKET_TX_ECHO+=${PACKET_TX[$n]}
  done
  PACKET_TX_ECHO=${PACKET_TX_ECHO//0x/'\x'}

}

#including checksum byte
function sendPacket {

  local response_hexdump
  local timeoutCat=0.3 # 300ms
  local FD=$FD_TCP # default TCP command port

  [ -n "$2" ] && FD="$2" #may also use UDP for broadcast (ssid etc.)
  if [ ! -v FD ]; then
   >&2 echo Error connection to host not available, missing -h to host? 
    exit $ERROR_CONNECTION
  fi

  [ "$DEBUG" -eq 1 ] && echo >&2 "Using FD $FD for sending packet"

  #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
  if [  $# -ge 1 ] ; then
    newPacketBody "$1"
  fi

  # write command/read response

  createPacketTX && echo -ne "$PACKET_TX_ECHO" >$FILENAME_COMMAND
  echo -ne "$PACKET_TX_ECHO" >&"$FD"
  #echo -ne "$PACKET_TX_ECHO" | socat $SOCAT_DEBUG_OPTIONS -u  - fd:$FD_TCP
  #[ "$DEBUG" -eq 1 ] && (
  #  echo PACKET TX WRITE STATUS to FD $FD_TCP $?
  #  hexdump -C $FILENAME_COMMAND
  #  echo Compiled command: echo "-ne" "'$PACKET_TX_ECHO'"
  #)

  #dd_status_option='status=none'
  #[ "$DEBUG" -eq 1 ] && dd_status_option=""
  #if ! dd bs=1024 count=1 $dd_status_option <&$FD_TCP >$FILENAME_RESPONSE; then

  timeout $timeoutCat cat <&"$FD" >$FILENAME_RESPONSE

  #TEST NUL bytes echo -ne "\x00\x00\x00\x0a\x00\x0b\x00\x0c\x00" | cat | hexdump -C

  #  if ! socat $SOCAT_DEBUG_OPTIONS -u -T 0.1 fd:$FD_TCP CREATE:$FILENAME_RESPONSE; then
  #    echo Error: Failed to read response
  #    return "$ERROR_READ_RESPONSE"
  #  fi

  #[ "$DEBUG" -eq 1 ] && (
  #  echo PACKET RX READ STATUS from FD $FD_TCP $?
  #  echo -ne "$response_hexdump" | hexdump -C
  #)

  #Copy response to byte array in hex ff ff .. .. ..
  response_hexdump=$(hexdump -v -e '/1 "%02x "' $FILENAME_RESPONSE) #a NUL termination is inserted for string, must be deleted

  if (( ${#response_hexdump} == 0 )); then
  
     >&2 echo "$HOST Warning no response received from host, timeout $timeoutCat s too low for cat FD $FD_TCP ?" 
  else
    {
      response_hexdump=${response_hexdump::-1}
      mapfile -d ' ' -t PACKET_RX <<< "$response_hexdump"

      [ "$DEBUG" -eq 1 ] && echo PACKET RX && hexdump -C $FILENAME_RESPONSE

       parsePacket
    }
  fi

}

function discovery {
  local TIMEOUT_SCAN=2 #seconds

  local rxscan
  local rxscan_sorted
  local response_hexdump
  local filename_udp_client
  local filename_udp_server
  local n

  filename_udp_server="$FILENAME_RXSOCAT"_UDP_"$PORT_UDP_DISCOVERY_SERVER"
  filename_udp_client="$FILENAME_RXSOCAT"_UDP_"$PORT_UDP_DISCOVERY_CLIENT"

  [ "$DEBUG" -eq 1 ] && echo "UDP discovery on GW port "$PORT_UDP_DISCOVERY_CLIENT
  [ "$DEBUG" -eq 1 ] && echo "UDP discovery on local port "$PORT_UDP_DISCOVERY_SERVER
  # shellcheck disable=SC2086
  socat $SOCAT_DEBUG_OPTIONS -u UDP-RECV:"$PORT_UDP_DISCOVERY_SERVER" CREATE:$filename_udp_server &
  #-R socat appends to file
  newPacketBody $CMD_BROADCAST
  createPacketTX
  # shellcheck disable=SC2086
  (
    echo -ne "$PACKET_TX_ECHO"
    sleep $TIMEOUT_SCAN
  ) | socat $SOCAT_DEBUG_OPTIONS -R "$filename_udp_client" - udp-datagram:255.255.255.255:$PORT_UDP_DISCOVERY_CLIENT,broadcast 1>/dev/null #disable stdout echo of rx data, sleep timeout EOF on STDIN
  # $PACKET_TX_ECHO is also copied over to $filename_udp, strange behavior of socat?
  #(echo -ne "\xff\xff\x12\x00\x04\x16"; sleep 3) | socat -d -d -x -R rxsocat  - udp-datagram:255.255.255.255:46000,broadcast
  kill %1
  cat $filename_udp_client $filename_udp_server >"$FILENAME_RXSOCAT" # Merge results from udp/tcp discovery
  rxscan=$(hexdump -v -e '/1 "%02x"' "$FILENAME_RXSOCAT")
  rm "$FILENAME_RXSOCAT" "$filename_udp_client" "$filename_udp_server"

  #result_sorted=$(echo -en ${result//"ff ff"/"\nff ff"} | sort -u)
  rxscan_sorted=$(echo -en "${rxscan//"ffff"/"\nffff"}" | sort -u)
  [ "$DEBUG" -eq 1 ] && echo -n "$rxscan_sorted" >"$FILENAME_RXSOCAT_SORTED"

  while read -r line; do
    if [[ "{$line:0:4}" =~ ffff.* ]]; then
      for ((n = 0, i=0; n < ${#line}; n = n + 2, i++)); do
        PACKET_RX[$i]=${line:$n:2}
      done
      parsePacket
    fi
  done <<< "$rxscan_sorted"
  
}

function checksum {
  local n
  #caller 0
  CHECKSUM=0
  [ "$DEBUG" -eq 1 ] && echo CHECKSUM PACKET_BODY "${PACKET_BODY[@]}"
  for ((n = 0; n < ${#PACKET_BODY[@]}; n++)); do
    CHECKSUM=$(( (CHECKSUM + ${PACKET_BODY[$n]}) & 0xff ))
  done
   CHECKSUM=$(decToHex $CHECKSUM)
  [ "$DEBUG" -eq 1 ] && echo CHECKSUM "$CHECKSUM"
}

function writeString {
  local n
  PACKET_BODY+=("$(decToHex ${#1})")
  for ((n = 0; n < ${#1}; n++)); do
    PACKET_BODY+=("$(decToHex "'${1:$n:1}")")
  done
}

function writeUInt16BE {
  PACKET_BODY+=("$(decToHex $((($1 & 0xff00) >> 8)))" "$(decToHex $(($1 & 0x00ff)))")
}

function writeUInt8 {
  PACKET_BODY+=("$(decToHex "$1")")
}

function decToHex {
  printf "0x%02x" "$1"
}

function newCustomizedPacket {
  newPacketBody $CMD_WRITE_CUSTOMIZED
  writeString  "$CUSTOMIZED_ID"
  writeString  "$CUSTOMIZED_PASSWORD"
  writeString  "$CUSTOMIZED_SERVER"
  writeUInt16BE "$CUSTOMIZED_PORT"
  writeUInt16BE "$CUSTOMIZED_INTERVAL"
  writeUInt8    "$CUSTOMIZED_TYPE"
  writeUInt8    "$CUSTOMIZED_ENABLED"
}

function updateCustomized {
  local needUpdate
  local key_value
  local value
  local key
  local n

  newPacketBody $CMD_READ_CUSTOMIZED # read previous configuration
  sendPacket

  #format enabled=1,port=8000,server=test.no
  readarray -d ',' -t OPTION_CUSTOMIZED <<< "$1"

  for ((n = 0; n < ${#OPTION_CUSTOMIZED[@]}; n++)); do

    readarray -d '=' -t key_value <<<"${OPTION_CUSTOMIZED[$n]}"

    key=${key_value[0]}
    value=${key_value[1]}

    case "$key" in

    id)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_ID="$value"
      [ "$CUSTOMIZED_ID" != "$value" ] && CUSTOMIZED_ID="$value" && needUpdate=1
      ;;
    password)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_PASSWORD="$value"
      [ "$CUSTOMIZED_PASSWORD" != "$value" ] && CUSTOMIZED_PASSWORD=$value && needUpdate=1
      ;;

    server)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_SERVER="$value"
      [ "$CUSTOMIZED_SERVER" != "$value" ] && CUSTOMIZED_SERVER=$value && needUpdate=1
      ;;

    port)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_PORT="$value"
      [ "$CUSTOMIZED_TYPE" != "$value" ] && CUSTOMIZED_TYPE=$value && needUpdate=1
      ;;

    type)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_TYPE="$value"
      [ "$CUSTOMIZED_TYPE" != "$value" ] && CUSTOMIZED_TYPE=$value && needUpdate=1
      ;;

    enabled)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_ENABLED="$value"
      [ "$CUSTOMIZED_ENABLED" != "$value" ] && CUSTOMIZED_ENABLED=$value && needUpdate=1
      ;;

    interval)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_INTERVAL="$value"
      [ "$CUSTOMIZED_INTERVAL" != "$value" ] && CUSTOMIZED_INTERVAL=$value && needUpdate=1
      ;;
    *)
      echo updateCustomized: unknown key "$key" value: "$value"
      ;;
    esac

  done

  #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash
  if ((needUpdate == 1)); then
    newCustomizedPacket
    sendPacket
    printCustomized
  else
    echo No update needed
  fi
}

#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  key="$1"
  COMMAND=""
  OPTION=""

  case $key in
  -b | --backup)
      sendPacket $CMD_READ_MAC
      sendPacket $CMD_READ_VERSION
      sendPacket $CMD_READ_ECOWITT
      sendPacket $CMD_READ_WUNDERGROUND
      sendPacket $CMD_READ_CUSTOMIZED
      sendPacket $CMD_READ_PATH
      dumpConfiguration
      shift
     ;;
  -d | --debug)
    DEBUG=1
    SOCAT_DEBUG_OPTIONS='-d -d -x'
    echo "Debug ON"
    shift
    ;;
  -h | --host)
    HOST_PREV=$HOST
    HOST="$2" # this arg must come first to open sockets
    #open file descriptors to UDP/TCP port on HOST
    connect "$2"
    CONNECT_STATUS=$?
    [ "$CONNECT_STATUS" -ne 0 ] && (
      >&2 echo "$HOST" "Error Failed to connect host, exiting"
      disconnect
      exit $CONNECT_STATUS
    )
    CONFIGURATION[host]=$HOST
    shift # past argument
    shift # past value
    ;;
  -c | --command | -r | --read)
    COMMAND="$2"
    shift
    shift
    ;;
  -s | --scan)
    discovery
    shift
    ;;
  -u | --update)
    COMMAND=$key
    OPTION="$2"
    updateCustomized "$OPTION"
    shift
    shift
    ;;
  -f | --firmware)
    curl --silent --show-error --user-agent "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
    shift
    shift
    ;;
  -l | --listen)
    >&2 echo  Listening on port "$2"
    mapfile HTTP_RESPONSE <<<"$(nc -l "$2")"
    for ((n = 0; n < ${#HTTP_RESPONSE[@]}; n++)); do
      echo "${HTTP_RESPONSE[$n]}"
    done
    shift
    shift
    ;;
    # Wunderground
    #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
    #Accept: */*
    #Host: 192.168.3.174
    #Connection: Close

    # Ecowitt
    #POST /ecowitt HTTP/1.1
    #HOST: 192.168.3.174
    #Connection: Close
    #Content-Type: application/x-www-form-urlencoded
    #Content-Length:591
    #
    #PASSKEY=976D09F15C41FD8DC6E9A9E8C4F39707&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro
    #
  *)                   # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift              # past argument
    ;;
  esac

  case $COMMAND in
  reset)
    sendPacket $CMD_BROADCAST $FD_UDP
    read  -r -p "Are you sure to reset, maybe perform configuration backup first (Y/N)? "
    case $REPLY in 
      Y) sendPacket $CMD_WRITE_RESET
      #BROADCAST annoncing GW1000A-WIFI4EC, but after reset GW1000-WIFI4EC is annonced (without A?)
      echo Fedora sudo nmcli dev wifi rescan; sudo nmcli dev wifi list | grep "${CONFIGURATION[broadcast_ssid]:0:4}"
      echo "Fedora sudo nmcli connect {ssid}"
      ;;
    esac
    ;;
  reboot)
    sendPacket $CMD_REBOOT
    ;;
  mac)
    sendPacket $CMD_READ_MAC
    ;;
  version)
    sendPacket $CMD_READ_VERSION
    ;;
  ecowitt)
    sendPacket $CMD_READ_ECOWITT
    ;;
  wunderground)
    sendPacket $CMD_READ_WUNDERGROUND
    ;;
  customized)
    sendPacket $CMD_READ_CUSTOMIZED
    ;;
  path)
    sendPacket $CMD_READ_PATH
    ;;
  broadcast)
    sendPacket $CMD_BROADCAST $FD_UDP
    ;;

  esac

  # -l enabled=1,port=8000,server=server.no
  case $OPTION in
  ssid)
    newPacketBody $CMD_WRITE_SSID
    #ssid packet has two byte length
    # TEST wsview android app, wireshark: ffff | 11 |001b| 08536b6f676c756e640d6c756775626572313934322d2e | a9
    #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/ConfigrouterFragment.java - SaveData
    writeString "$1"
    writeString "$2"
    sendPacket
    shift
    shift
    ;;
  path)
    newPacketBody $CMD_WRITE_PATH
    writeString "$1"
    writeString "$2"
    SOCAT_DEBUG_OPTIONS
    shift # remove ecowitt path
    shift # remove wu path
    ;;

  esac

done

set -- "${POSITIONAL[@]}" # restore positional parameters

disconnect

##echo CMD_BROADCAST
#command '\x12\x00\x04\x15' $FD_UDP
#https://unix.stackexchange.com/questions/612193/socat-send-a-udp-broadcast-from-stdin-but-handling-responses-with-system
#echo -ne "\xff\xff\x12\x00\x04\x16" | socat -d -d -x -t 1 - udp-datagram:255.255.255.255:46000,broadcast

