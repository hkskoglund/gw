#!/bin/bash
# example /gw -h 10.42.0.180  -s 3
# scan for 3 seconds
# example ./gw -h 10.42.0.180 -c mac
# read mac
# Info  from https://www.xmodulo.com/tcp-udp-socket-bash-shell.html
# Writing CMD_BROADCAST 0x12 to HOST port 46000
# https://brendanzagaeski.appspot.com/0006.html - hexdump examples
#Protocol documentation : https://osswww.ecowitt.net/uploads/20210716/WN1900%20GW1000,1100%20WH2680,2650%20telenet%20v1.6.0%20.pdf (https://www.ecowitt.com/shop/forum/forumDetails/255)

#for debugging
#echo PID "$$"
#read -p "PAUSING"

HTTP_UA_NAME="gw ShellScript"
HTTP_FIRMWARE="http://download.ecowitt.net/down/filewave?v=FirwaveReadme.txt"

DEBUG=0

PORT_TCP_COMMAND_SERVER=45000
PORT_UDP_DISCOVERY_SERVER=59387
PORT_UDP_DISCOVERY_CLIENT=46000

#COMMANDS AT BYTE 2 ff ff |COMMAND| ...

CMD_READ_PATH=0x51
CMD_WRITE_PATH=0x52

CMD_READ_VERSION=0x50
CMD_REBOOT=0x40
CMD_READ_MAC=0x26
CMD_READ_WUNDERGROUND=0x20
CMD_READ_ECOWITT=0x1e

CMD_READ_CUSTOMIZED=0x2a
CMD_WRITE_CUSTOMIZED=0x2b

CMD_WRITE_SSID=0x11
CMD_BROADCAST=0x12

# PACKET BODY STARTING AT BYTE 2
PACKET_BODY=()

#CONNECT ERRORS
ERROR_TCP_CONNECTION=1
ERROR_UDP_CONNECTION=2
ERROR_READ_RESPONSE=3

FILENAME_RXSOCAT_SORTED='rxsocat_sorted'
FILENAME_COMMAND='txpacket'
FILENAME_RESPONSE='rxpacket'
FILENAME_RXSOCAT='rxsocat'

function connect {
  
  #https://www.gnu.org/software/bash/manual/bash.html - 3.6 Redirections
 # if exec {FD_UDP}<>/dev/udp/"$1"/$GW_UDP_SERVER_PORT; then
 #   echo "Connected $1:$GW_UDP_SERVER_PORT (UDP FD $FD_UDP)"
 # else
 #   return $ERROR_UDP_CONNECTION
 # fi

  if exec {FD_TCP}<>/dev/tcp/"$1"/"$PORT_TCP_COMMAND_SERVER"; then
    [ "$DEBUG" -eq 1 ] && echo Connected "$1:$PORT_TCP_COMMAND_SERVER" "(TCP FD $FD_TCP)"
  else
    return $ERROR_TCP_CONNECTION
  fi

  #echo Current shell PID $$

  if [ "$DEBUG" -eq 1 ]; then netstat -tunp | grep "$$"; fi

}

function disconnect {
  #https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
  #close sockets
 # if [ -n "${FD_UDP+x}" ]; then

 #   if ! exec {FD_UDP}>&-; then echo Failed to close $FD_UDP; fi
 # fi

  if [ -n "${FD_TCP+x}" ]; then

    if ! exec {FD_TCP}>&-; then echo Failed to close $FD_TCP; fi
  fi
}

function result {
  STATUS=${PACKET[4]}
  if [ "$STATUS" == "00" ]; then
    echo "$1" OK
  else
    echo "$1" FAILED
  fi
}

function hexToString {
  HEXTOSTRING=""
  NEXT_LENGTH=$(( $1 + 1 + 0x${PACKET[$1]} ))
 
  for ((n = $(($1 + 1)); n < NEXT_LENGTH; n++)); do
    HEXTOSTRING+=$(echo -en "\x${PACKET[$n]}")
  done
}

function printCustomized {
    echo -n Customized: id: "$CUSTOMIZED_ID "
    echo -n password : "$CUSTOMIZED_PASSWORD "
    echo -n server: "$CUSTOMIZED_SERVER "
    echo -n port: "$CUSTOMIZED_PORT "
    echo -n interval: "$CUSTOMIZED_INTERVAL "
    if ((CUSTOMIZED_TYPE == 1)); then
      echo -n "type: 1 (Wunderground) "
    else
      echo -n "type: 0 (Ecowitt) "
    fi

      if ((CUSTOMIZED_ENABLED == 1)); then
      echo enabled: '1 (ON)'
    else
      echo enabled: '0 (OFF)'
    fi
}

function checkEmptyString {
  [ -z "$1" ] && echo Warning: "$2" empty
}

function parsePacketLength
{
  local packet_cmd
  local lsb
  local msb

  packet_cmd=0x${PACKET[2]}
  case $packet_cmd in
    "$CMD_BROADCAST")
       lsb=${PACKET[4]}
       msb=${PACKET[3]}
       PACKET_LENGTH=$(( (0x$msb << 8) | 0x$lsb ))
       ;;
    *)
       PACKET_LENGTH=${PACKET[3]}
    ;;
  esac
}

function parsePacket {
  local response_cmd

  parsePacketLength

  [ "$DEBUG" -eq 1 ] && echo "Parse packet ${PACKET[@]} length $PACKET_LENGTH"

  response_cmd=0x${PACKET[2]}

  case $response_cmd in
  "$CMD_WRITE_CUSTOMIZED")
    result "Write Customized"
    ;;
  "$CMD_REBOOT")
    result "Reboot"
    ;;
  "$CMD_READ_MAC")
    printf "MAC %02X:%02X:%02X:%02X:%02X:%02X\n" 0x"${PACKET[4]}" 0x"${PACKET[5]}" 0x"${PACKET[6]}" 0x"${PACKET[7]}" 0x"${PACKET[8]}" 0x"${PACKET[9]}"
    ;;
  "$CMD_READ_VERSION")
    hexToString 4
    VERSION=$HEXTOSTRING
    echo Version : "$VERSION"
    ;;
  "$CMD_READ_ECOWITT")
    ECOWITT_INTERVAL=$(( "${PACKET[4]}" ))
    echo Ecowitt upload interval: $ECOWITT_INTERVAL minutes
    ;;
  "$CMD_READ_WUNDERGROUND")
    hexToString 4
    WUNDERGROUND_STATION_ID=$HEXTOSTRING
    
    checkEmptyString "$WUNDERGROUND_STATION_ID" "Wunderground station id"
    echo Wunderground station ID: "$WUNDERGROUND_STATION_ID"
    
    hexToString $NEXT_LENGTH
    WUNDERGROUND_PASSWORD=$HEXTOSTRING
    checkEmptyString "$WUNDERGROUND_PASSWORD" "Wunderground password"
    echo Wunderground password : "$WUNDERGROUND_PASSWORD"
    ;;
  "$CMD_READ_CUSTOMIZED")
    hexToString 4
    CUSTOMIZED_ID=$HEXTOSTRING
    checkEmptyString "$CUSTOMIZED_ID" "Customized station id"

    hexToString $NEXT_LENGTH
    CUSTOMIZED_PASSWORD=$HEXTOSTRING
    checkEmptyString "$CUSTOMIZED_PASSWORD" "Customized password"
    
    hexToString $NEXT_LENGTH
    CUSTOMIZED_SERVER=$HEXTOSTRING
    checkEmptyString "$CUSTOMIZED_SERVER" "Customized server"
    #http://mywiki.wooledge.org/ArithmeticExpression

    CUSTOMIZED_PORT=$(((0x${PACKET[-7]} << 8) | 0x${PACKET[-6]}))
    CUSTOMIZED_INTERVAL=$(((0x${PACKET[-5]} << 8) | 0x${PACKET[-4]}))
    CUSTOMIZED_TYPE=$((0x${PACKET[-3]}))
    CUSTOMIZED_ENABLED=$((0x${PACKET[-2]}))

    printCustomized

    ;;
  "$CMD_READ_PATH")
    hexToString 4
    PATH_ECOWITT=$HEXTOSTRING
    checkEmptyString "$PATH_ECOWITT" "Path ecowitt"
    echo Ecowitt "$PATH_ECOWITT"

    hexToString $NEXT_LENGTH
    PATH_WUNDERGROUND=$HEXTOSTRING
    checkEmptyString "$PATH_WUNDERGROUND" "Path wunderground"
    echo Wunderground "$PATH_WUNDERGROUND"
    ;;
  "$CMD_WRITE_PATH")
    result "Update path"
    ;;
  "$CMD_WRITE_SSID")
    result "Update SSID"
    ;;
  "$CMD_BROADCAST")

     if (( PACKET_LENGTH > 4 )); then
     {
          MAC=$(printf "%02X:%02X:%02X:%02X:%02X:%02X\n" 0x"${PACKET[5]}" 0x"${PACKET[6]}" 0x"${PACKET[7]}" 0x"${PACKET[8]}" 0x"${PACKET[9]}" 0x"${PACKET[10]}")
          IP=$(printf "%d.%d.%d.%d" 0x"${PACKET[11]}" 0x"${PACKET[12]}" 0x"${PACKET[13]}" 0x"${PACKET[14]}")
          hexToString 17
          SSID=$HEXTOSTRING
          PORT=$(printf "%d" 0x"${PACKET[15]}""${PACKET[16]}")
          echo "$MAC" "$IP":"$PORT" "$SSID"  
     }
     else
     {
       [ "$DEBUG" -eq 1 ] && echo "Failed: unable to parse broadcast, too small length $PACKET_LENGTH"
     }
     fi
    
    ;;
  *)
    echo Warning: unable to parse command "$response_cmd"
    ;;

  esac
}

function newPacketTX
{
  local packetLengthLSB
  local packetLengthMSB
# Take care of 2 or 1 byte packet length

  case ${PACKET_BODY[0]} in
  "$CMD_WRITE_SSID" | "$CMD_BROADCAST")
    packetLengthLSB=$(( (  ${#PACKET_BODY[@]} + 1) & 0xff ))
    packetLengthMSB=$(( ( (${#PACKET_BODY[@]} + 1) & 0xff00) >> 8 ))
    PACKET_BODY[1]=$(decToHex $packetLengthMSB)
    PACKET_BODY[2]=$(decToHex $packetLengthLSB)
    ;;
  *)
    PACKET_BODY[1]=$(decToHex $((${#PACKET_BODY[@]} + 1))) # set packet length including checksum byte
    ;;
  esac

  checksum
  PACKET_TX=(0xff 0xff "${PACKET_BODY[@]}" "$CHECKSUM")

  #[ "$DEBUG" -eq 1 ] && echo PACKET_TX "${PACKET_TX[@]//0x/''}"

  for ((n = 0; n < ${#PACKET_TX[@]}; n++)); do
    PACKET_TX_ECHO+=${PACKET_TX[$n]}
  done
  PACKET_TX_ECHO=${PACKET_TX_ECHO//0x/'\x'}

}

#including checksum byte
function sendPacket {
  
  local response_hexdump

  #simple command https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
  if [ $# -eq 1 ]; then
    newPacket "$1"
  fi

  newPacketTX

  # write command/read response

  echo -ne "$PACKET_TX_ECHO" >$FILENAME_COMMAND
  echo -ne "$PACKET_TX_ECHO" >&$FD_TCP
 #echo -ne "$PACKET_TX_ECHO" | socat $SOCAT_DEBUG_OPTIONS -u  - fd:$FD_TCP
  #[ "$DEBUG" -eq 1 ] && (
  #  echo PACKET TX WRITE STATUS to FD $FD_TCP $?
  #  hexdump -C $FILENAME_COMMAND
  #  echo Compiled command: echo "-ne" "'$PACKET_TX_ECHO'"
  #)

  #dd_status_option='status=none'
  #[ "$DEBUG" -eq 1 ] && dd_status_option=""
  #if ! dd bs=1024 count=1 $dd_status_option <&$FD_TCP >$FILENAME_RESPONSE; then

timeout 0.1 cat <&$FD_TCP >$FILENAME_RESPONSE
    
#TEST NUL bytes echo -ne "\x00\x00\x00\x0a\x00\x0b\x00\x0c\x00" | cat | hexdump -C

#  if ! socat $SOCAT_DEBUG_OPTIONS -u -T 0.1 fd:$FD_TCP CREATE:$FILENAME_RESPONSE; then
#    echo Error: Failed to read response
#    return "$ERROR_READ_RESPONSE"
#  fi

  #[ "$DEBUG" -eq 1 ] && (
  #  echo PACKET RX READ STATUS from FD $FD_TCP $?
  #  echo -ne "$response_hexdump" | hexdump -C
  #)
  
  #Copy response to byte array in hex ff ff .. .. ..
  response_hexdump=$(hexdump -v -e '/1 "%02x "' $FILENAME_RESPONSE) #a NUL termination is inserted for string, must be deleted
  response_hexdump=${response_hexdump::-1} 
  mapfile -d ' ' -t PACKET <<< "$response_hexdump"

  [ "$DEBUG" -eq 1 ] && hexdump -C $FILENAME_RESPONSE

  parsePacket

}

function discovery {
  local TIMEOUT_SCAN=2 #seconds
  
  local rxscan
  local rxscan_sorted
  local response_hexdump
  local filename_udp_client
  local filename_udp_server

  filename_udp_server="$FILENAME_RXSOCAT"_UDP_"$PORT_UDP_DISCOVERY_SERVER"
  filename_udp_client="$FILENAME_RXSOCAT"_UDP_"$PORT_UDP_DISCOVERY_CLIENT"
  
  [ "$DEBUG" -eq 1 ] && echo "UDP discovery on GW port "$PORT_UDP_DISCOVERY_CLIENT
  [ "$DEBUG" -eq 1 ] && echo "UDP discovery on local port "$PORT_UDP_DISCOVERY_SERVER

  socat $SOCAT_DEBUG_OPTIONS  -u UDP-RECV:"$PORT_UDP_DISCOVERY_SERVER" CREATE:$filename_udp_server &
  #-R socat appends to file
  newPacket $CMD_BROADCAST
  newPacketTX 
  (echo -ne "$PACKET_TX_ECHO"; sleep $TIMEOUT_SCAN) | socat $SOCAT_DEBUG_OPTIONS -R "$filename_udp_client" - udp-datagram:255.255.255.255:$PORT_UDP_DISCOVERY_CLIENT,broadcast 1>/dev/null #disable stdout echo of rx data, sleep timeout EOF on STDIN 
  # $PACKET_TX_ECHO is also copied over to $filename_udp, strange behavior of socat?
  #(echo -ne "\xff\xff\x12\x00\x04\x16"; sleep 3) | socat -d -d -x -R rxsocat  - udp-datagram:255.255.255.255:46000,broadcast
  kill %1
  cat $filename_udp_client $filename_udp_server >"$FILENAME_RXSOCAT" # Merge results from udp/tcp discovery
  rxscan=$(hexdump -v -e '/1 "%02x"' "$FILENAME_RXSOCAT" )
  rm "$FILENAME_RXSOCAT" "$filename_udp_client" "$filename_udp_server"
  
  #result_sorted=$(echo -en ${result//"ff ff"/"\nff ff"} | sort -u)
  rxscan_sorted=$(echo -en "${rxscan//"ffff"/"\nffff"}" | sort -u)
  [ "$DEBUG" -eq 1 ] && echo -n "$rxscan_sorted" >"$FILENAME_RXSOCAT_SORTED"

  while read -r line; do
    if [[ "{$line:0:4}" =~ ffff.* ]]; then
      #PACKET=
      response_hexdump=
      for ((n = 0; n < ${#line}; n = n + 2)); do
        response_hexdump+="${line:$n:2} " # insert space between each byte
      done
      #[ $DEBUG -eq 1 ] && echo "$response_hexdump"
      mapfile -d ' ' -t PACKET <<<"$response_hexdump"
      #PACKET_SCAN+=( "$response_hexdump" )
      parsePacket
    fi
  done <<<"$rxscan_sorted"

  #echo "${PACKET_SCAN[@]}"
}

function newPacket { #also add premliminary length, which is updated in command when sending
  PACKET_BODY=()
  PACKET_BODY+=("$1" "0x00")
  case "$1" in
     "$CMD_BROADCAST") # WSVIEW sends 2 byte field for size
          PACKET_BODY+=("0x00")
           ;;
  esac
        
 # [ -n "$1" ] &&  PACKET_BODY+=("0x00")  # Append for two byte packet length
}

function checksum {
  #caller 0
  CHECKSUM=0
  [ "$DEBUG" -eq 1 ] && echo CHECKSUM PACKET_BODY "${PACKET_BODY[@]}"
  for ((n = 0; n < ${#PACKET_BODY[@]}; n++)); do
    CHECKSUM=$((CHECKSUM + ${PACKET_BODY[$n]}))
  done
  CHECKSUM=$(decToHex $((CHECKSUM & 0xff)))
  [ "$DEBUG" -eq 1 ] && echo CHECKSUM "$CHECKSUM"
}

function writeString {
  PACKET_BODY+=("$(decToHex ${#1})")
  for ((n = 0; n < ${#1}; n++)); do
    PACKET_BODY+=("$(decToHex "'${1:$n:1}")")
  done
}

function writeUInt16BE {
  PACKET_BODY+=( "$(decToHex $((($1 & 0xff00) >> 8)))" "$(decToHex $(($1 & 0x00ff)))" )
}

function writeUInt8 {
  PACKET_BODY+=("$(decToHex "$1")")
}

function decToHex
{
  printf "0x%02x" "$1"
}

function newCustomizedPacket {
  newPacket $CMD_WRITE_CUSTOMIZED
  writeString "$CUSTOMIZED_ID"
  writeString "$CUSTOMIZED_PASSWORD"
  writeString "$CUSTOMIZED_SERVER"
  writeUInt16BE $CUSTOMIZED_PORT
  writeUInt16BE $CUSTOMIZED_INTERVAL
  writeUInt8 $CUSTOMIZED_TYPE
  writeUInt8 $CUSTOMIZED_ENABLED
}

function updateCustomized {
  local needUpdate
  local key_value
  local value
  local key

  newPacket $CMD_READ_CUSTOMIZED # read previous configuration
  sendPacket

#format enabled=1,port=8000,server=test.no
  readarray -d ',' -t OPTION_CUSTOMIZED <<< "$1"

  for ((n=0; n < ${#OPTION_CUSTOMIZED[@]}; n++ )); do
    
    readarray -d '='  -t key_value <<< "${OPTION_CUSTOMIZED[$n]}"

    key=${key_value[0]}
    value=${key_value[1]}
    
    case "$key" in

    id)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_ID="$value"
      [ "$CUSTOMIZED_ID" != "$value" ] && CUSTOMIZED_ID="$value" && needUpdate=1
      ;;
    password)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_PASSWORD="$value"
      [ "$CUSTOMIZED_PASSWORD" != "$value" ] && CUSTOMIZED_PASSWORD=$value && needUpdate=1
      ;;

    server)
      [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_SERVER="$value"
      [ "$CUSTOMIZED_SERVER" != "$value" ] && CUSTOMIZED_SERVER=$value && needUpdate=1
      ;;

    port)
          [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_PORT="$value"
           [ "$CUSTOMIZED_TYPE" != "$value" ] && CUSTOMIZED_TYPE=$value && needUpdate=1
       ;;

    type)
          [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_TYPE="$value"
          [ "$CUSTOMIZED_TYPE" != "$value" ] && CUSTOMIZED_TYPE=$value && needUpdate=1
     ;;

    enabled)
          [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_ENABLED="$value"
          [ $CUSTOMIZED_ENABLED != "$value" ] && CUSTOMIZED_ENABLED=$value && needUpdate=1
      ;;

    interval)
          [ "$DEBUG" -eq 1 ] && echo Update CUSTOMIZED_INTERVAL="$value"
          [ "$CUSTOMIZED_INTERVAL" != "$value" ] && CUSTOMIZED_INTERVAL=$value && needUpdate=1
          ;;
    *)
      echo updateCustomized: unknown key "$key" value: "$value"
    esac
    
  done

  #https://stackoverflow.com/questions/18668556/how-can-i-compare-numbers-in-bash
  if ((needUpdate == 1)); then
    newCustomizedPacket
    sendPacket
    printCustomized 
  else
    echo No update needed
  fi
}

#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  key="$1"
  COMMAND=""
  OPTION=""

  case $key in
  -d | --debug)
     DEBUG=1
     SOCAT_DEBUG_OPTIONS='-d -d -x'
     echo "Debug ON"
     shift
     ;;
  -h | --host)
    HOST="$2" # this arg must come first to open sockets
    #open file descriptors to UDP/TCP port on HOST
    connect "$2"
    CONNECT_STATUS=$?
    [ "$CONNECT_STATUS" -ne 0 ] && (
      echo "Failed to connect host $HOST, exiting"
      disconnect
      exit $CONNECT_STATUS
    )
    shift # past argument
    shift # past value
    ;;
  -c | --command | -r | --read)
    COMMAND="$2"
    shift
    shift
    ;;
  -s | --scan)
    discovery
    shift
    
    ;;
  -u | --update)
    COMMAND=$key
    OPTION="$2"
    updateCustomized "$OPTION"
    shift
    shift
    ;;
  -f | --firmware)
    curl --silent --show-error --user-agent "$HTTP_UA_NAME" "$HTTP_FIRMWARE"
    shift
    shift
    ;;
  -l | --listen)
    echo Listening on port "$2"
    mapfile HTTP_RESPONSE <<<"$(nc -l "$2")"
    for ((n = 0; n < ${#HTTP_RESPONSE[@]}; n++)); do
      echo "${HTTP_RESPONSE[$n]}"
    done
    shift
    shift
    ;;
    # Wunderground
    #GET /wundergroundID=testid&PASSWORD=testpassword&tempf=63.0&humidity=82&dewptf=57.4&windchillf=63.0&winddir=355&windspeedmph=3.36&windgustmph=4.47&rainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&solarradiation=206.87&UV=2&indoortempf=74.3&indoorhumidity=61&baromin=29.760&soilmoisture=16&lowbatt=0&dateutc=now&softwaretype=GW1000A_V1.6.8&action=updateraw&realtime=1&rtfreq=5 HTTP/1.0
    #Accept: */*
    #Host: 192.168.3.174
    #Connection: Close

    # Ecowitt
    #POST /ecowitt HTTP/1.1
    #HOST: 192.168.3.174
    #Connection: Close
    #Content-Type: application/x-www-form-urlencoded
    #Content-Length:591
    #
    #PASSKEY=976D09F15C41FD8DC6E9A9E8C4F39707&stationtype=GW1000A_V1.6.8&dateutc=2021-08-10+12:08:12&tempinf=74.1&humidityin=61&baromrelin=29.754&baromabsin=29.754&tempf=63.0&humidity=82&winddir=15&windspeedmph=3.80&windgustmph=4.47&maxdailygust=5.82&solarradiation=206.01&uv=2&rainratein=0.000&eventrainin=0.051&hourlyrainin=0.000&dailyrainin=0.020&weeklyrainin=0.051&monthlyrainin=0.311&yearlyrainin=4.811&totalrainin=4.811&temp1f=68.72&humidity1=67&temp2f=72.14&humidity2=63&temp3f=80.24&humidity3=48&soilmoisture1=16&wh65batt=0&batt1=0&batt2=0&batt3=0&soilbatt1=1.4&freq=868M&model=GW1000_Pro
    #
  *)                   # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift              # past argument
    ;;
  esac

  case $COMMAND in
  reboot)
    sendPacket $CMD_REBOOT
    ;;
  mac)
    sendPacket $CMD_READ_MAC
    ;;
  version)
    sendPacket $CMD_READ_VERSION
    ;;
  ecowitt)
    sendPacket $CMD_READ_ECOWITT
    ;;
  wunderground)
    sendPacket $CMD_READ_WUNDERGROUND
    ;;
  customized)
    sendPacket $CMD_READ_CUSTOMIZED
    ;;
  path)
    sendPacket $CMD_READ_PATH
    ;;

  esac

# -l enabled=1,port=8000,server=server.no
  case $OPTION in
  ssid)
    newPacket $CMD_WRITE_SSID
    #ssid packet has two byte length
    # TEST wsview android app, wireshark: ffff | 11 |001b| 08536b6f676c756e640d6c756775626572313934322d2e | a9
    #WSView_v1.1.51_apkpure.com_source_from_JADX/sources/com/ost/newnettool/Fragment/ConfigrouterFragment.java - SaveData
    writeString "$1"
    writeString "$2"
    sendPacket
    shift
    shift
    ;;
  path)
    newPacket $CMD_WRITE_PATH
    writeString "$1"
    writeString "$2"
    SOCAT_DEBUG_OPTIONS
    shift # remove ecowitt path
    shift # remove wu path
    ;;
 
  esac

done

set -- "${POSITIONAL[@]}" # restore positional parameters

disconnect

##echo CMD_BROADCAST
#command '\x12\x00\x04\x15' $FD_UDP
#https://unix.stackexchange.com/questions/612193/socat-send-a-udp-broadcast-from-stdin-but-handling-responses-with-system
#echo -ne "\xff\xff\x12\x00\x04\x16" | socat -d -d -x -t 1 - udp-datagram:255.255.255.255:46000,broadcast 

